<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ToolDAQFramework: src/ServiceDiscovery/zstd.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ToolDAQFramework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3a890d004d00eddb185727401c501745.html">ServiceDiscovery</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">zstd.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFSE__CState__t.html">FSE_CState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFSE__DState__t.html">FSE_DState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFSE__symbolCompressionTransform.html">FSE_symbolCompressionTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFSE__DTableHeader.html">FSE_DTableHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFSE__decode__t.html">FSE_decode_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__CTableHeader.html">HUF_CTableHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFSE__DecompressWksp.html">FSE_DecompressWksp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__bounds.html">ZSTD_bounds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__FrameHeader.html">ZSTD_FrameHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__frameProgression.html">ZSTD_frameProgression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPOOL__job__s.html">POOL_job_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPOOL__ctx__s.html">POOL_ctx_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__cpuid__t.html">ZSTD_cpuid_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structXXH32__canonical__t.html">XXH32_canonical_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonical (big endian) representation of XXH32_hash_t.  <a href="structXXH32__canonical__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structXXH64__canonical__t.html">XXH64_canonical_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonical (big endian) representation of XXH64_hash_t.  <a href="structXXH64__canonical__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structXXH32__state__s.html">XXH32_state_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structXXH64__state__s.html">XXH64_state_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__frameSizeInfo.html">ZSTD_frameSizeInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblockProperties__t.html">blockProperties_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnodeElt__s.html">nodeElt_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__CompressWeightsWksp.html">HUF_CompressWeightsWksp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__WriteCTableWksp.html">HUF_WriteCTableWksp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrankPos.html">rankPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__buildCTable__wksp__tables.html">HUF_buildCTable_wksp_tables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__compress__tables__t.html">HUF_compress_tables_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__prefixDict__s.html">ZSTD_prefixDict_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__localDict.html">ZSTD_localDict</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__hufCTables__t.html">ZSTD_hufCTables_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__fseCTables__t.html">ZSTD_fseCTables_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__entropyCTables__t.html">ZSTD_entropyCTables_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSeqDef__s.html">SeqDef_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSeqStore__t.html">SeqStore_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__SequenceLength.html">ZSTD_SequenceLength</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__hufCTablesMetadata__t.html">ZSTD_hufCTablesMetadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__fseCTablesMetadata__t.html">ZSTD_fseCTablesMetadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__entropyCTablesMetadata__t.html">ZSTD_entropyCTablesMetadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__match__t.html">ZSTD_match_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrawSeq.html">rawSeq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRawSeqStore__t.html">RawSeqStore_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__optimal__t.html">ZSTD_optimal_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoptState__t.html">optState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__compressedBlockState__t.html">ZSTD_compressedBlockState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__blockState__t.html">ZSTD_blockState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldmEntry__t.html">ldmEntry_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldmMatchCandidate__t.html">ldmMatchCandidate_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldmState__t.html">ldmState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldmParams__t.html">ldmParams_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSeqCollector.html">SeqCollector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__blockSplitCtx.html">ZSTD_blockSplitCtx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepcodes__s.html">repcodes_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__SequencePosition.html">ZSTD_SequencePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlockSummary.html">BlockSummary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__BuildCTableWksp.html">ZSTD_BuildCTableWksp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEstimatedBlockSize.html">EstimatedBlockSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFingerprint.html">Fingerprint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFPStats.html">FPStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__symbolEncodingTypeStats__t.html">ZSTD_symbolEncodingTypeStats_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseqStoreSplits.html">seqStoreSplits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldmRollingHashState__t.html">ldmRollingHashState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__optLdm__t.html">ZSTD_optLdm_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuffer__s.html">buffer_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTDMT__bufferPool__s.html">ZSTDMT_bufferPool_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTDMT__CCtxPool.html">ZSTDMT_CCtxPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRange.html">Range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSerialState.html">SerialState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTDMT__jobDescription.html">ZSTDMT_jobDescription</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInBuff__t.html">InBuff_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRoundBuff__t.html">RoundBuff_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRSyncState__t.html">RSyncState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSyncPoint.html">SyncPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDTableDesc.html">DTableDesc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__DecompressFastArgs.html">HUF_DecompressFastArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__DEltX1.html">HUF_DEltX1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__ReadDTableX1__Workspace.html">HUF_ReadDTableX1_Workspace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__DEltX2.html">HUF_DEltX2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsortedSymbol__t.html">sortedSymbol_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHUF__ReadDTableX2__Workspace.html">HUF_ReadDTableX2_Workspace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalgo__time__t.html">algo_time_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__seqSymbol__header.html">ZSTD_seqSymbol_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__seqSymbol.html">ZSTD_seqSymbol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__entropyDTables__t.html">ZSTD_entropyDTables_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__DDictHashSet.html">ZSTD_DDictHashSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq__t.html">seq_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__fseState.html">ZSTD_fseState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseqState__t.html">seqState_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZSTD__OffsetInfo.html">ZSTD_OffsetInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZDICT__params__t.html">ZDICT_params_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZDICT__fastCover__params__t.html">ZDICT_fastCover_params_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structZDICT__legacy__params__t.html">ZDICT_legacy_params_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCOVER__best__s.html">COVER_best_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCOVER__segment__t.html">COVER_segment_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCOVER__epoch__info__t.html">COVER_epoch_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCOVER__dictSelection.html">COVER_dictSelection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCOVER__map__pair__t__s.html">COVER_map_pair_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCOVER__map__s.html">COVER_map_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCOVER__ctx__t.html">COVER_ctx_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCOVER__tryParameters__data__s.html">COVER_tryParameters_data_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__trbudget__t.html">_trbudget_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFASTCOVER__accel__t.html">FASTCOVER_accel_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFASTCOVER__ctx__t.html">FASTCOVER_ctx_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFASTCOVER__tryParameters__data__s.html">FASTCOVER_tryParameters_data_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdictItem.html">dictItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEStats__ress__t.html">EStats_ress_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoffsetCount__t.html">offsetCount_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a98e1870af5a087143c11d0004159eef4"><td class="memItemLeft" align="right" valign="top"><a id="a98e1870af5a087143c11d0004159eef4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEBUGLEVEL</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a98e1870af5a087143c11d0004159eef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d9b620a75ca60cd5d24b51309af887"><td class="memItemLeft" align="right" valign="top"><a id="a02d9b620a75ca60cd5d24b51309af887"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_MODULE</b></td></tr>
<tr class="separator:a02d9b620a75ca60cd5d24b51309af887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde9dad44d3e0e432474bef93e12f9e7"><td class="memItemLeft" align="right" valign="top"><a id="acde9dad44d3e0e432474bef93e12f9e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_NAMESPACE</b>&#160;&#160;&#160;ZSTD_</td></tr>
<tr class="separator:acde9dad44d3e0e432474bef93e12f9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6589b6ea961ec073de006a47282c9a41"><td class="memItemLeft" align="right" valign="top"><a id="a6589b6ea961ec073de006a47282c9a41"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_PRIVATE_API</b></td></tr>
<tr class="separator:a6589b6ea961ec073de006a47282c9a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a61b869708b770ad75e3e063a2f9273"><td class="memItemLeft" align="right" valign="top"><a id="a5a61b869708b770ad75e3e063a2f9273"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_INLINE_ALL</b></td></tr>
<tr class="separator:a5a61b869708b770ad75e3e063a2f9273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61169a87ccc08b7c57050d9d777b354e"><td class="memItemLeft" align="right" valign="top"><a id="a61169a87ccc08b7c57050d9d777b354e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LEGACY_SUPPORT</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a61169a87ccc08b7c57050d9d777b354e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510978d81ba500af1831d2fe3cc2c105"><td class="memItemLeft" align="right" valign="top"><a id="a510978d81ba500af1831d2fe3cc2c105"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MULTITHREAD</b></td></tr>
<tr class="separator:a510978d81ba500af1831d2fe3cc2c105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04dc2d966881bc030021e41046bcde8"><td class="memItemLeft" align="right" valign="top"><a id="ad04dc2d966881bc030021e41046bcde8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_TRACE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ad04dc2d966881bc030021e41046bcde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f2036614c97d4eb4ea7d8e9d231fcf"><td class="memItemLeft" align="right" valign="top"><a id="aa9f2036614c97d4eb4ea7d8e9d231fcf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DISABLE_ASM</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa9f2036614c97d4eb4ea7d8e9d231fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec470b07ea51d527cd012ee2d1e545b6"><td class="memItemLeft" align="right" valign="top"><a id="aec470b07ea51d527cd012ee2d1e545b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_NEED_MALLOC</b></td></tr>
<tr class="separator:aec470b07ea51d527cd012ee2d1e545b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30e0f5c0a2a6d94509053d1daa6e102"><td class="memItemLeft" align="right" valign="top"><a id="ac30e0f5c0a2a6d94509053d1daa6e102"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_NEED_MATH64</b></td></tr>
<tr class="separator:ac30e0f5c0a2a6d94509053d1daa6e102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad620af343d8477fb559ff20e3f7b861f"><td class="memItemLeft" align="right" valign="top"><a id="ad620af343d8477fb559ff20e3f7b861f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_COMMON</b></td></tr>
<tr class="separator:ad620af343d8477fb559ff20e3f7b861f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9c0eec04d0a310dc55ab1602358bd9"><td class="memItemLeft" align="right" valign="top"><a id="abf9c0eec04d0a310dc55ab1602358bd9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_memcpy</b>(d,  s,  l)&#160;&#160;&#160;memcpy((d),(s),(l))</td></tr>
<tr class="separator:abf9c0eec04d0a310dc55ab1602358bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297fb1a30353e3a90ccddb4d793af747"><td class="memItemLeft" align="right" valign="top"><a id="a297fb1a30353e3a90ccddb4d793af747"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_memmove</b>(d,  s,  l)&#160;&#160;&#160;memmove((d),(s),(l))</td></tr>
<tr class="separator:a297fb1a30353e3a90ccddb4d793af747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04cbb94fc7fd2c47b6a4059ff8cd2e3"><td class="memItemLeft" align="right" valign="top"><a id="ae04cbb94fc7fd2c47b6a4059ff8cd2e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_memset</b>(p,  v,  l)&#160;&#160;&#160;memset((p),(v),(l))</td></tr>
<tr class="separator:ae04cbb94fc7fd2c47b6a4059ff8cd2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa953355263e9044cd0e12ed30ad87dd0"><td class="memItemLeft" align="right" valign="top"><a id="aa953355263e9044cd0e12ed30ad87dd0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_MALLOC</b></td></tr>
<tr class="separator:aa953355263e9044cd0e12ed30ad87dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04498a23c732d4955a060f7923b6009d"><td class="memItemLeft" align="right" valign="top"><a id="a04498a23c732d4955a060f7923b6009d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_malloc</b>(s)&#160;&#160;&#160;malloc(s)</td></tr>
<tr class="separator:a04498a23c732d4955a060f7923b6009d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5e83c48252878c3250c51a599116fe"><td class="memItemLeft" align="right" valign="top"><a id="abc5e83c48252878c3250c51a599116fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_calloc</b>(n,  s)&#160;&#160;&#160;calloc((n), (s))</td></tr>
<tr class="separator:abc5e83c48252878c3250c51a599116fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2d331de21de19885a4eea32e2df21f"><td class="memItemLeft" align="right" valign="top"><a id="a1d2d331de21de19885a4eea32e2df21f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_free</b>(p)&#160;&#160;&#160;free((p))</td></tr>
<tr class="separator:a1d2d331de21de19885a4eea32e2df21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142d9ba063fca548e99b137f053de83"><td class="memItemLeft" align="right" valign="top"><a id="aa142d9ba063fca548e99b137f053de83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_MATH64</b></td></tr>
<tr class="separator:aa142d9ba063fca548e99b137f053de83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd779202d5d9e3d59f68cf68db9ef23d"><td class="memItemLeft" align="right" valign="top"><a id="acd779202d5d9e3d59f68cf68db9ef23d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_div64</b>(dividend,  divisor)&#160;&#160;&#160;((dividend) / (divisor))</td></tr>
<tr class="separator:acd779202d5d9e3d59f68cf68db9ef23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe062dc6ec033b09926fa96d09aba2ad"><td class="memItemLeft" align="right" valign="top"><a id="abe062dc6ec033b09926fa96d09aba2ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEBUG_H_12987983217</b></td></tr>
<tr class="separator:abe062dc6ec033b09926fa96d09aba2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb676ca6c75ca5c67f93092d6f39fc0"><td class="memItemLeft" align="right" valign="top"><a id="a0eb676ca6c75ca5c67f93092d6f39fc0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEBUG_STATIC_ASSERT</b>(c)&#160;&#160;&#160;(void)sizeof(char[(c) ? 1 : -1])</td></tr>
<tr class="separator:a0eb676ca6c75ca5c67f93092d6f39fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcc5aaebf3f273c1762f24a6ece2e5e"><td class="memItemLeft" align="right" valign="top"><a id="acdcc5aaebf3f273c1762f24a6ece2e5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>assert</b>(condition)&#160;&#160;&#160;((void)0)   /* disable assert (default) */</td></tr>
<tr class="separator:acdcc5aaebf3f273c1762f24a6ece2e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ae9de40961bbf331641c73a0a00e88"><td class="memItemLeft" align="right" valign="top"><a id="aa1ae9de40961bbf331641c73a0a00e88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RAWLOG</b>(l, ...)&#160;&#160;&#160;do { } while (0)    /* disabled */</td></tr>
<tr class="separator:aa1ae9de40961bbf331641c73a0a00e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8728fe9e99fe783be28c0f38bb0d0761"><td class="memItemLeft" align="right" valign="top"><a id="a8728fe9e99fe783be28c0f38bb0d0761"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEBUGLOG</b>(l, ...)&#160;&#160;&#160;do { } while (0)    /* disabled */</td></tr>
<tr class="separator:a8728fe9e99fe783be28c0f38bb0d0761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade58910edd970fcfd9dc46bbe96616ea"><td class="memItemLeft" align="right" valign="top"><a id="ade58910edd970fcfd9dc46bbe96616ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_H_MODULE</b></td></tr>
<tr class="separator:ade58910edd970fcfd9dc46bbe96616ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a58c4e6afae74b737ab505466c54374"><td class="memItemLeft" align="right" valign="top"><a id="a6a58c4e6afae74b737ab505466c54374"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPILER_H</b></td></tr>
<tr class="separator:a6a58c4e6afae74b737ab505466c54374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ecb13afb97b810bb159d5a8005c1b9"><td class="memItemLeft" align="right" valign="top"><a id="a83ecb13afb97b810bb159d5a8005c1b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_PORTABILITY_MACROS_H</b></td></tr>
<tr class="separator:a83ecb13afb97b810bb159d5a8005c1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d2d7742701f3f112afbcd8d4f9ccdb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a54d2d7742701f3f112afbcd8d4f9ccdb">__has_attribute</a>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:a54d2d7742701f3f112afbcd8d4f9ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447121dcab4275b7839a56082b7a1ab8"><td class="memItemLeft" align="right" valign="top"><a id="a447121dcab4275b7839a56082b7a1ab8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__has_builtin</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:a447121dcab4275b7839a56082b7a1ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af989845e24678c452b9222afdac95e7f"><td class="memItemLeft" align="right" valign="top"><a id="af989845e24678c452b9222afdac95e7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__has_feature</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:af989845e24678c452b9222afdac95e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156ed2bbe21615175aa17b6362df3902"><td class="memItemLeft" align="right" valign="top"><a id="a156ed2bbe21615175aa17b6362df3902"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MEMORY_SANITIZER</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a156ed2bbe21615175aa17b6362df3902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b5950357214b72e9d7dc8c807b5532"><td class="memItemLeft" align="right" valign="top"><a id="a66b5950357214b72e9d7dc8c807b5532"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ADDRESS_SANITIZER</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a66b5950357214b72e9d7dc8c807b5532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25b96d1ca6422eafca85ae89739eda0"><td class="memItemLeft" align="right" valign="top"><a id="ab25b96d1ca6422eafca85ae89739eda0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DATAFLOW_SANITIZER</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab25b96d1ca6422eafca85ae89739eda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540ea4e6a91b438c14ff315ff2fa919b"><td class="memItemLeft" align="right" valign="top"><a id="a540ea4e6a91b438c14ff315ff2fa919b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HIDE_ASM_FUNCTION</b>(func)</td></tr>
<tr class="separator:a540ea4e6a91b438c14ff315ff2fa919b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb35fef0715144073aa8d817f29fda7b"><td class="memItemLeft" align="right" valign="top"><a id="acb35fef0715144073aa8d817f29fda7b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STATIC_BMI2</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:acb35fef0715144073aa8d817f29fda7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a6c7b850aa43dd7e4f93698f19dd2e"><td class="memItemLeft" align="right" valign="top"><a id="a23a6c7b850aa43dd7e4f93698f19dd2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DYNAMIC_BMI2</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a23a6c7b850aa43dd7e4f93698f19dd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae0a8c39456420987044c8e361752f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#acae0a8c39456420987044c8e361752f2">ZSTD_ASM_SUPPORTED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:acae0a8c39456420987044c8e361752f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8084640e001328f56badaf0fd91cf6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad8084640e001328f56badaf0fd91cf6a">ZSTD_ENABLE_ASM_X86_64_BMI2</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ad8084640e001328f56badaf0fd91cf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f637c8d55c55bf07d69985e555d67d8"><td class="memItemLeft" align="right" valign="top"><a id="a9f637c8d55c55bf07d69985e555d67d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CET_ENDBRANCH</b></td></tr>
<tr class="separator:a9f637c8d55c55bf07d69985e555d67d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dceeddd8c95c1559b57a34cc9cd32c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8dceeddd8c95c1559b57a34cc9cd32c6">ZSTD_IS_DETERMINISTIC_BUILD</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a8dceeddd8c95c1559b57a34cc9cd32c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ec650a4045eb3e9c0b1e22f11183f7"><td class="memItemLeft" align="right" valign="top"><a id="ae7ec650a4045eb3e9c0b1e22f11183f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INLINE_KEYWORD</b></td></tr>
<tr class="separator:ae7ec650a4045eb3e9c0b1e22f11183f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb32e49e718aa032c6b04b4a237131e"><td class="memItemLeft" align="right" valign="top"><a id="acdb32e49e718aa032c6b04b4a237131e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FORCE_INLINE_ATTR</b></td></tr>
<tr class="separator:acdb32e49e718aa032c6b04b4a237131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d26640d57defb61b302b1ad663fed8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a10d26640d57defb61b302b1ad663fed8">WIN_CDECL</a></td></tr>
<tr class="separator:a10d26640d57defb61b302b1ad663fed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58a705ceeb200925bb0a7e302959982"><td class="memItemLeft" align="right" valign="top"><a id="ab58a705ceeb200925bb0a7e302959982"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNUSED_ATTR</b></td></tr>
<tr class="separator:ab58a705ceeb200925bb0a7e302959982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf752dd6259117e6d4da3b8b1fb13aaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a>&#160;&#160;&#160;static INLINE_KEYWORD FORCE_INLINE_ATTR UNUSED_ATTR</td></tr>
<tr class="separator:abf752dd6259117e6d4da3b8b1fb13aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e6fde6004400522b2ff1da3c080363"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a>&#160;&#160;&#160;<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a></td></tr>
<tr class="separator:a18e6fde6004400522b2ff1da3c080363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4d568511d5e964c3579616a28ab62b"><td class="memItemLeft" align="right" valign="top"><a id="acf4d568511d5e964c3579616a28ab62b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_STATIC</b>&#160;&#160;&#160;static  /* this version may generate warnings for unused static functions; disable the relevant warning */</td></tr>
<tr class="separator:acf4d568511d5e964c3579616a28ab62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ab899ba72c9f276c582f97019962a8"><td class="memItemLeft" align="right" valign="top"><a id="a59ab899ba72c9f276c582f97019962a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FORCE_NOINLINE</b>&#160;&#160;&#160;static</td></tr>
<tr class="separator:a59ab899ba72c9f276c582f97019962a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c78874b4598aa064513de22c63f8b22"><td class="memItemLeft" align="right" valign="top"><a id="a3c78874b4598aa064513de22c63f8b22"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TARGET_ATTRIBUTE</b>(target)</td></tr>
<tr class="separator:a3c78874b4598aa064513de22c63f8b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7854df18b0aef76741751b50d2d4ed9f"><td class="memItemLeft" align="right" valign="top"><a id="a7854df18b0aef76741751b50d2d4ed9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BMI2_TARGET_ATTRIBUTE</b>&#160;&#160;&#160;TARGET_ATTRIBUTE(&quot;lzcnt,bmi,bmi2&quot;)</td></tr>
<tr class="separator:a7854df18b0aef76741751b50d2d4ed9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef9ca0bddea71f0fd375204c53dc594"><td class="memItemLeft" align="right" valign="top"><a id="a6ef9ca0bddea71f0fd375204c53dc594"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PREFETCH_L1</b>(ptr)&#160;&#160;&#160;do { (void)(ptr); } while (0)  /* disabled */</td></tr>
<tr class="separator:a6ef9ca0bddea71f0fd375204c53dc594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443feb0bd0c92430a75d4f12507097e9"><td class="memItemLeft" align="right" valign="top"><a id="a443feb0bd0c92430a75d4f12507097e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PREFETCH_L2</b>(ptr)&#160;&#160;&#160;do { (void)(ptr); } while (0)  /* disabled */</td></tr>
<tr class="separator:a443feb0bd0c92430a75d4f12507097e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05da5eff6babaf91257a4accdf8e0b6"><td class="memItemLeft" align="right" valign="top"><a id="ae05da5eff6babaf91257a4accdf8e0b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CACHELINE_SIZE</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:ae05da5eff6babaf91257a4accdf8e0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cce918a4f05f32c0950e5b26283341"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>PREFETCH_AREA</b>(p,  s)</td></tr>
<tr class="separator:a64cce918a4f05f32c0950e5b26283341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb568b4457858d8f44c8f0d40ba33613"><td class="memItemLeft" align="right" valign="top"><a id="abb568b4457858d8f44c8f0d40ba33613"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DONT_VECTORIZE</b></td></tr>
<tr class="separator:abb568b4457858d8f44c8f0d40ba33613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affde14445f49f65ff4f5b592e44ee71a"><td class="memItemLeft" align="right" valign="top"><a id="affde14445f49f65ff4f5b592e44ee71a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LIKELY</b>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:affde14445f49f65ff4f5b592e44ee71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10d0a221f4d7a706701b806c8135fd7"><td class="memItemLeft" align="right" valign="top"><a id="ab10d0a221f4d7a706701b806c8135fd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNLIKELY</b>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:ab10d0a221f4d7a706701b806c8135fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa044456089664d6fc153162494a5ac"><td class="memItemLeft" align="right" valign="top"><a id="aafa044456089664d6fc153162494a5ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_UNREACHABLE</b>&#160;&#160;&#160;do { assert(0); } while (0)</td></tr>
<tr class="separator:aafa044456089664d6fc153162494a5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8212387312dcd18c78e1c8fcf77973c8"><td class="memItemLeft" align="right" valign="top"><a id="a8212387312dcd18c78e1c8fcf77973c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HAS_C_ATTRIBUTE</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:a8212387312dcd18c78e1c8fcf77973c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e49ccf63edd5b4897d1fb70dc4a3832"><td class="memItemLeft" align="right" valign="top"><a id="a4e49ccf63edd5b4897d1fb70dc4a3832"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HAS_CPP_ATTRIBUTE</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:a4e49ccf63edd5b4897d1fb70dc4a3832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab140b6922b01b84dd6b5fb25202f00cf"><td class="memItemLeft" align="right" valign="top"><a id="ab140b6922b01b84dd6b5fb25202f00cf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FALLTHROUGH</b></td></tr>
<tr class="separator:ab140b6922b01b84dd6b5fb25202f00cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f62fae7cc02c3c4b1b0503ff6abc2f"><td class="memItemLeft" align="right" valign="top"><a id="a13f62fae7cc02c3c4b1b0503ff6abc2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ALIGNOF</b>(T)&#160;&#160;&#160;(sizeof(void*) &lt; sizeof(T) ? sizeof(void*) : sizeof(T))</td></tr>
<tr class="separator:a13f62fae7cc02c3c4b1b0503ff6abc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac160ce67ca1e6eb69999166127116e4a"><td class="memItemLeft" align="right" valign="top"><a id="ac160ce67ca1e6eb69999166127116e4a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ALIGNED</b>(...)</td></tr>
<tr class="separator:ac160ce67ca1e6eb69999166127116e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae888a667f541f813c6766c53154e99cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a></td></tr>
<tr class="separator:ae888a667f541f813c6766c53154e99cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2733f481af0b54786b85603606218d08"><td class="memItemLeft" align="right" valign="top"><a id="a2733f481af0b54786b85603606218d08"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ERROR_H_MODULE</b></td></tr>
<tr class="separator:a2733f481af0b54786b85603606218d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0f0edb498136ba78bd12472e6cfe75"><td class="memItemLeft" align="right" valign="top"><a id="a5f0f0edb498136ba78bd12472e6cfe75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ERRORS_H_398273423</b></td></tr>
<tr class="separator:a5f0f0edb498136ba78bd12472e6cfe75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27690417b3c1f8cef5e551f13a2f7e3"><td class="memItemLeft" align="right" valign="top"><a id="aa27690417b3c1f8cef5e551f13a2f7e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDERRORLIB_VISIBLE</b></td></tr>
<tr class="separator:aa27690417b3c1f8cef5e551f13a2f7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6ffab9b0f11783bba2ea000c42dd8b"><td class="memItemLeft" align="right" valign="top"><a id="a2f6ffab9b0f11783bba2ea000c42dd8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDERRORLIB_HIDDEN</b></td></tr>
<tr class="separator:a2f6ffab9b0f11783bba2ea000c42dd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba638ca88c24aaf1c6c1e1250cfee5d3"><td class="memItemLeft" align="right" valign="top"><a id="aba638ca88c24aaf1c6c1e1250cfee5d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDERRORLIB_API</b>&#160;&#160;&#160;ZSTDERRORLIB_VISIBLE</td></tr>
<tr class="separator:aba638ca88c24aaf1c6c1e1250cfee5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b364ef62042e1a3403bce515d066f37"><td class="memItemLeft" align="right" valign="top"><a id="a0b364ef62042e1a3403bce515d066f37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ERR_STATIC</b>&#160;&#160;&#160;static  /* this version may generate warnings for unused static functions; disable the relevant warning */</td></tr>
<tr class="separator:a0b364ef62042e1a3403bce515d066f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22c6a0ee6c5435c890ee2b86da1678a"><td class="memItemLeft" align="right" valign="top"><a id="aa22c6a0ee6c5435c890ee2b86da1678a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PREFIX</b>(name)&#160;&#160;&#160;ZSTD_error_##name</td></tr>
<tr class="separator:aa22c6a0ee6c5435c890ee2b86da1678a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24803eff45eace63df5ec3f331e3fccc"><td class="memItemLeft" align="right" valign="top"><a id="a24803eff45eace63df5ec3f331e3fccc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ERROR</b>(name)&#160;&#160;&#160;ZSTD_ERROR(name)</td></tr>
<tr class="separator:a24803eff45eace63df5ec3f331e3fccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e2c9f7c3e71cf77be96d3b4f8d32cc"><td class="memItemLeft" align="right" valign="top"><a id="a96e2c9f7c3e71cf77be96d3b4f8d32cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ERROR</b>(name)&#160;&#160;&#160;((size_t)-PREFIX(name))</td></tr>
<tr class="separator:a96e2c9f7c3e71cf77be96d3b4f8d32cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b01d485e392c08dde3559f5d5b95b7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHECK_V_F</b>(e,  f)</td></tr>
<tr class="separator:a2b01d485e392c08dde3559f5d5b95b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d46f205af270855cb30ab9c9dd646d"><td class="memItemLeft" align="right" valign="top"><a id="a16d46f205af270855cb30ab9c9dd646d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHECK_F</b>(f)&#160;&#160;&#160;do { CHECK_V_F(_var_err__, f); } while (0)</td></tr>
<tr class="separator:a16d46f205af270855cb30ab9c9dd646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc6aaeda475e2edd35a7c63f93b14f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aebc6aaeda475e2edd35a7c63f93b14f5">_FORCE_HAS_FORMAT_STRING</a>(...)</td></tr>
<tr class="separator:aebc6aaeda475e2edd35a7c63f93b14f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17755a585a5ef282997b7db35c81cf6"><td class="memItemLeft" align="right" valign="top"><a id="aa17755a585a5ef282997b7db35c81cf6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ERR_QUOTE</b>(str)&#160;&#160;&#160;#str</td></tr>
<tr class="separator:aa17755a585a5ef282997b7db35c81cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0783e849b3fc286fe720307a952d26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5d0783e849b3fc286fe720307a952d26">RETURN_ERROR_IF</a>(cond,  err, ...)</td></tr>
<tr class="separator:a5d0783e849b3fc286fe720307a952d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4f39f1cb8d10dd9b7ea6ce7badaae1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2d4f39f1cb8d10dd9b7ea6ce7badaae1">RETURN_ERROR</a>(err, ...)</td></tr>
<tr class="separator:a2d4f39f1cb8d10dd9b7ea6ce7badaae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee8764705277539a9c911cfb62dd077"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3ee8764705277539a9c911cfb62dd077">FORWARD_IF_ERROR</a>(err, ...)</td></tr>
<tr class="separator:a3ee8764705277539a9c911cfb62dd077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b>&#160;&#160;&#160;/* FSE_MIN_TABLELOG */</td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cec868b238deb86970e093aae8d6b38"><td class="memItemLeft" align="right" valign="top"><a id="a1cec868b238deb86970e093aae8d6b38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_H</b></td></tr>
<tr class="separator:a1cec868b238deb86970e093aae8d6b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64c31fdae2f9c52905c234c012876f2"><td class="memItemLeft" align="right" valign="top"><a id="af64c31fdae2f9c52905c234c012876f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_PUBLIC_API</b></td></tr>
<tr class="separator:af64c31fdae2f9c52905c234c012876f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af5f622dcc34fd0a33b98c66fd358ff"><td class="memItemLeft" align="right" valign="top"><a id="a5af5f622dcc34fd0a33b98c66fd358ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_VERSION_MAJOR</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a5af5f622dcc34fd0a33b98c66fd358ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47997dfd178c4bf77ac40ffade1d24b"><td class="memItemLeft" align="right" valign="top"><a id="ac47997dfd178c4bf77ac40ffade1d24b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_VERSION_MINOR</b>&#160;&#160;&#160;9</td></tr>
<tr class="separator:ac47997dfd178c4bf77ac40ffade1d24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7b5e77328e0f234a846d7cb6d1692a"><td class="memItemLeft" align="right" valign="top"><a id="a8f7b5e77328e0f234a846d7cb6d1692a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_VERSION_RELEASE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a8f7b5e77328e0f234a846d7cb6d1692a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0951d8b4dc1c667d953f9d60a8ba27a"><td class="memItemLeft" align="right" valign="top"><a id="af0951d8b4dc1c667d953f9d60a8ba27a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_LIB_VERSION</b>&#160;&#160;&#160;FSE_VERSION_MAJOR.FSE_VERSION_MINOR.FSE_VERSION_RELEASE</td></tr>
<tr class="separator:af0951d8b4dc1c667d953f9d60a8ba27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b19a697d63cebe17a2e6962e83595f"><td class="memItemLeft" align="right" valign="top"><a id="aa1b19a697d63cebe17a2e6962e83595f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_QUOTE</b>(str)&#160;&#160;&#160;#str</td></tr>
<tr class="separator:aa1b19a697d63cebe17a2e6962e83595f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230320373751af9c40ec6d15a91e6e82"><td class="memItemLeft" align="right" valign="top"><a id="a230320373751af9c40ec6d15a91e6e82"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_EXPAND_AND_QUOTE</b>(str)&#160;&#160;&#160;FSE_QUOTE(str)</td></tr>
<tr class="separator:a230320373751af9c40ec6d15a91e6e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6659b5c04342f9cadda7d69494384b26"><td class="memItemLeft" align="right" valign="top"><a id="a6659b5c04342f9cadda7d69494384b26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_VERSION_STRING</b>&#160;&#160;&#160;FSE_EXPAND_AND_QUOTE(FSE_LIB_VERSION)</td></tr>
<tr class="separator:a6659b5c04342f9cadda7d69494384b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8e8fc30886fab320168bcd278ce33f"><td class="memItemLeft" align="right" valign="top"><a id="ada8e8fc30886fab320168bcd278ce33f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_VERSION_NUMBER</b>&#160;&#160;&#160;(FSE_VERSION_MAJOR *100*100 + FSE_VERSION_MINOR *100 + FSE_VERSION_RELEASE)</td></tr>
<tr class="separator:ada8e8fc30886fab320168bcd278ce33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8a6c61f28b45d06a787bc1627e994c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7e8a6c61f28b45d06a787bc1627e994c">FSE_H_FSE_STATIC_LINKING_ONLY</a></td></tr>
<tr class="separator:a7e8a6c61f28b45d06a787bc1627e994c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f434fb74cbcf6942af37a1a7266d03"><td class="memItemLeft" align="right" valign="top"><a id="ac6f434fb74cbcf6942af37a1a7266d03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BITSTREAM_H_MODULE</b></td></tr>
<tr class="separator:ac6f434fb74cbcf6942af37a1a7266d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22b1dfe10f9a2bea9ddd7c06954479b"><td class="memItemLeft" align="right" valign="top"><a id="ad22b1dfe10f9a2bea9ddd7c06954479b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BITS_H</b></td></tr>
<tr class="separator:ad22b1dfe10f9a2bea9ddd7c06954479b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3240ab50c3f9ef13130e9ab1581c819"><td class="memItemLeft" align="right" valign="top"><a id="af3240ab50c3f9ef13130e9ab1581c819"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STREAM_ACCUMULATOR_MIN_32</b>&#160;&#160;&#160;25</td></tr>
<tr class="separator:af3240ab50c3f9ef13130e9ab1581c819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1135fd5f07bb4a097952829cd86cddbf"><td class="memItemLeft" align="right" valign="top"><a id="a1135fd5f07bb4a097952829cd86cddbf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STREAM_ACCUMULATOR_MIN_64</b>&#160;&#160;&#160;57</td></tr>
<tr class="separator:a1135fd5f07bb4a097952829cd86cddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8674f969501cfe0e0f8b46474d1397c"><td class="memItemLeft" align="right" valign="top"><a id="ae8674f969501cfe0e0f8b46474d1397c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STREAM_ACCUMULATOR_MIN</b>&#160;&#160;&#160;((U32)(MEM_32bits() ? STREAM_ACCUMULATOR_MIN_32 : STREAM_ACCUMULATOR_MIN_64))</td></tr>
<tr class="separator:ae8674f969501cfe0e0f8b46474d1397c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3cf8c5431e47edb91eb0f502c34207"><td class="memItemLeft" align="right" valign="top"><a id="a8f3cf8c5431e47edb91eb0f502c34207"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT_MASK_SIZE</b>&#160;&#160;&#160;(sizeof(BIT_mask) / sizeof(BIT_mask[0]))</td></tr>
<tr class="separator:a8f3cf8c5431e47edb91eb0f502c34207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e0574b20e0b81990614a3b071cbedf"><td class="memItemLeft" align="right" valign="top"><a id="a96e0574b20e0b81990614a3b071cbedf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_NCOUNTBOUND</b>&#160;&#160;&#160;512</td></tr>
<tr class="separator:a96e0574b20e0b81990614a3b071cbedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd917b54dc6e60048924a1d5bb8d5eb5"><td class="memItemLeft" align="right" valign="top"><a id="afd917b54dc6e60048924a1d5bb8d5eb5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_BLOCKBOUND</b>(size)&#160;&#160;&#160;((size) + ((size)&gt;&gt;7) + 4 /* fse states */ + sizeof(size_t) /* bitContainer */)</td></tr>
<tr class="separator:afd917b54dc6e60048924a1d5bb8d5eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072eb2b7604a2adccc976cc96f1bd02c"><td class="memItemLeft" align="right" valign="top"><a id="a072eb2b7604a2adccc976cc96f1bd02c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_COMPRESSBOUND</b>(size)&#160;&#160;&#160;(FSE_NCOUNTBOUND + FSE_BLOCKBOUND(size))   /* Macro version, useful for static allocation */</td></tr>
<tr class="separator:a072eb2b7604a2adccc976cc96f1bd02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28314c25142a77707cbc7e9d82ac2d1f"><td class="memItemLeft" align="right" valign="top"><a id="a28314c25142a77707cbc7e9d82ac2d1f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_CTABLE_SIZE_U32</b>(maxTableLog,  maxSymbolValue)&#160;&#160;&#160;(1 + (1&lt;&lt;((maxTableLog)-1)) + (((maxSymbolValue)+1)*2))</td></tr>
<tr class="separator:a28314c25142a77707cbc7e9d82ac2d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469d5b77c26b9a1d5fd6e312aa9ae56e"><td class="memItemLeft" align="right" valign="top"><a id="a469d5b77c26b9a1d5fd6e312aa9ae56e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_DTABLE_SIZE_U32</b>(maxTableLog)&#160;&#160;&#160;(1 + (1&lt;&lt;(maxTableLog)))</td></tr>
<tr class="separator:a469d5b77c26b9a1d5fd6e312aa9ae56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787f207c14e311fa0aae568800b79a14"><td class="memItemLeft" align="right" valign="top"><a id="a787f207c14e311fa0aae568800b79a14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_CTABLE_SIZE</b>(maxTableLog,  maxSymbolValue)&#160;&#160;&#160;(FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) * sizeof(<a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a>))</td></tr>
<tr class="separator:a787f207c14e311fa0aae568800b79a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aa265f18b6603a1c97ecdafe14fe95"><td class="memItemLeft" align="right" valign="top"><a id="a73aa265f18b6603a1c97ecdafe14fe95"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_DTABLE_SIZE</b>(maxTableLog)&#160;&#160;&#160;(FSE_DTABLE_SIZE_U32(maxTableLog) * sizeof(FSE_DTable))</td></tr>
<tr class="separator:a73aa265f18b6603a1c97ecdafe14fe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe16485fbc1da8723222218d16df9612"><td class="memItemLeft" align="right" valign="top"><a id="afe16485fbc1da8723222218d16df9612"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32</b>(maxSymbolValue,  tableLog)&#160;&#160;&#160;(((maxSymbolValue + 2) + (1ull &lt;&lt; (tableLog)))/2 + sizeof(U64)/sizeof(U32) /* additional 8 bytes for potential table overwrite */)</td></tr>
<tr class="separator:afe16485fbc1da8723222218d16df9612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf03986ef069fd12a74e100f8944d7af"><td class="memItemLeft" align="right" valign="top"><a id="adf03986ef069fd12a74e100f8944d7af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_BUILD_CTABLE_WORKSPACE_SIZE</b>(maxSymbolValue,  tableLog)&#160;&#160;&#160;(sizeof(unsigned) * FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(maxSymbolValue, tableLog))</td></tr>
<tr class="separator:adf03986ef069fd12a74e100f8944d7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dc49afb72116452ac809d74ed808d1"><td class="memItemLeft" align="right" valign="top"><a id="a73dc49afb72116452ac809d74ed808d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_BUILD_DTABLE_WKSP_SIZE</b>(maxTableLog,  maxSymbolValue)&#160;&#160;&#160;(sizeof(short) * (maxSymbolValue + 1) + (1ULL &lt;&lt; maxTableLog) + 8)</td></tr>
<tr class="separator:a73dc49afb72116452ac809d74ed808d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc70a2bea32622b484509c2ec412f417"><td class="memItemLeft" align="right" valign="top"><a id="adc70a2bea32622b484509c2ec412f417"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_BUILD_DTABLE_WKSP_SIZE_U32</b>(maxTableLog,  maxSymbolValue)&#160;&#160;&#160;((FSE_BUILD_DTABLE_WKSP_SIZE(maxTableLog, maxSymbolValue) + sizeof(unsigned) - 1) / sizeof(unsigned))</td></tr>
<tr class="separator:adc70a2bea32622b484509c2ec412f417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1af02c0f89f03bffb41474cf224cb0e"><td class="memItemLeft" align="right" valign="top"><a id="af1af02c0f89f03bffb41474cf224cb0e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_DECOMPRESS_WKSP_SIZE_U32</b>(maxTableLog,  maxSymbolValue)&#160;&#160;&#160;(FSE_DTABLE_SIZE_U32(maxTableLog) + 1 + FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxTableLog, maxSymbolValue) + (<a class="el" href="zstd_8c.html#a1588af42cea714b4f3ec46d40da716c5">FSE_MAX_SYMBOL_VALUE</a> + 1) / 2 + 1)</td></tr>
<tr class="separator:af1af02c0f89f03bffb41474cf224cb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b47699da8d6e91233ecb4dd0b4a7e39"><td class="memItemLeft" align="right" valign="top"><a id="a1b47699da8d6e91233ecb4dd0b4a7e39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_DECOMPRESS_WKSP_SIZE</b>(maxTableLog,  maxSymbolValue)&#160;&#160;&#160;(FSE_DECOMPRESS_WKSP_SIZE_U32(maxTableLog, maxSymbolValue) * sizeof(unsigned))</td></tr>
<tr class="separator:a1b47699da8d6e91233ecb4dd0b4a7e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ccde461aac2d6c8dbcc17959d9618e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a56ccde461aac2d6c8dbcc17959d9618e">FSE_MAX_MEMORY_USAGE</a>&#160;&#160;&#160;14</td></tr>
<tr class="separator:a56ccde461aac2d6c8dbcc17959d9618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be6d0a890864f1fcbf8148926e38b9"><td class="memItemLeft" align="right" valign="top"><a id="a33be6d0a890864f1fcbf8148926e38b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_DEFAULT_MEMORY_USAGE</b>&#160;&#160;&#160;13</td></tr>
<tr class="separator:a33be6d0a890864f1fcbf8148926e38b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1588af42cea714b4f3ec46d40da716c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1588af42cea714b4f3ec46d40da716c5">FSE_MAX_SYMBOL_VALUE</a>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a1588af42cea714b4f3ec46d40da716c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f80a620738f0e6e2e50163bf27bf1e"><td class="memItemLeft" align="right" valign="top"><a id="ab6f80a620738f0e6e2e50163bf27bf1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_FUNCTION_TYPE</b>&#160;&#160;&#160;BYTE</td></tr>
<tr class="separator:ab6f80a620738f0e6e2e50163bf27bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9de5fea5680db139a34f327cc1560e"><td class="memItemLeft" align="right" valign="top"><a id="afb9de5fea5680db139a34f327cc1560e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_FUNCTION_EXTENSION</b></td></tr>
<tr class="separator:afb9de5fea5680db139a34f327cc1560e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e93bbfab6eabe4168a4e67c2f112a9e"><td class="memItemLeft" align="right" valign="top"><a id="a2e93bbfab6eabe4168a4e67c2f112a9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_DECODE_TYPE</b>&#160;&#160;&#160;<a class="el" href="structFSE__decode__t.html">FSE_decode_t</a></td></tr>
<tr class="separator:a2e93bbfab6eabe4168a4e67c2f112a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2a8ebf95a47fd43d74e503875bc75c"><td class="memItemLeft" align="right" valign="top"><a id="aec2a8ebf95a47fd43d74e503875bc75c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_MAX_TABLELOG</b>&#160;&#160;&#160;(<a class="el" href="zstd_8c.html#a56ccde461aac2d6c8dbcc17959d9618e">FSE_MAX_MEMORY_USAGE</a>-2)</td></tr>
<tr class="separator:aec2a8ebf95a47fd43d74e503875bc75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ec4087906baa1626bc8ecfcc536044"><td class="memItemLeft" align="right" valign="top"><a id="a80ec4087906baa1626bc8ecfcc536044"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_MAX_TABLESIZE</b>&#160;&#160;&#160;(1U&lt;&lt;FSE_MAX_TABLELOG)</td></tr>
<tr class="separator:a80ec4087906baa1626bc8ecfcc536044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fee4640938ab1e8ccb5f56cfbbfd7f9"><td class="memItemLeft" align="right" valign="top"><a id="a6fee4640938ab1e8ccb5f56cfbbfd7f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_MAXTABLESIZE_MASK</b>&#160;&#160;&#160;(FSE_MAX_TABLESIZE-1)</td></tr>
<tr class="separator:a6fee4640938ab1e8ccb5f56cfbbfd7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053d769479dccfc3b6d63a5a9e15f794"><td class="memItemLeft" align="right" valign="top"><a id="a053d769479dccfc3b6d63a5a9e15f794"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_DEFAULT_TABLELOG</b>&#160;&#160;&#160;(FSE_DEFAULT_MEMORY_USAGE-2)</td></tr>
<tr class="separator:a053d769479dccfc3b6d63a5a9e15f794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ae1ca1a1b29f44cf290c28dd5b4584"><td class="memItemLeft" align="right" valign="top"><a id="a60ae1ca1a1b29f44cf290c28dd5b4584"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_MIN_TABLELOG</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a60ae1ca1a1b29f44cf290c28dd5b4584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b73acaed6445a95cfe77bd20d2b31"><td class="memItemLeft" align="right" valign="top"><a id="acb6b73acaed6445a95cfe77bd20d2b31"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_TABLELOG_ABSOLUTE_MAX</b>&#160;&#160;&#160;15</td></tr>
<tr class="separator:acb6b73acaed6445a95cfe77bd20d2b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd844498efb40171b6767970177aa870"><td class="memItemLeft" align="right" valign="top"><a id="abd844498efb40171b6767970177aa870"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_TABLESTEP</b>(tableSize)&#160;&#160;&#160;(((tableSize)&gt;&gt;1) + ((tableSize)&gt;&gt;3) + 3)</td></tr>
<tr class="separator:abd844498efb40171b6767970177aa870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1c22f5cc7bed4607fe7200f346d544"><td class="memItemLeft" align="right" valign="top"><a id="a1c1c22f5cc7bed4607fe7200f346d544"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_H_298734234</b></td></tr>
<tr class="separator:a1c1c22f5cc7bed4607fe7200f346d544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85a93e7aec3443f516c69bc9f41afd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1a85a93e7aec3443f516c69bc9f41afd">HUF_BLOCKSIZE_MAX</a>&#160;&#160;&#160;(128 * 1024)</td></tr>
<tr class="separator:a1a85a93e7aec3443f516c69bc9f41afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c2d50f510f73bd3886e232704f5c89"><td class="memItemLeft" align="right" valign="top"><a id="a64c2d50f510f73bd3886e232704f5c89"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_WORKSPACE_SIZE</b>&#160;&#160;&#160;((8 &lt;&lt; 10) + 512 /* sorting scratch space */)</td></tr>
<tr class="separator:a64c2d50f510f73bd3886e232704f5c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cccb07604149b28386b618700df59a"><td class="memItemLeft" align="right" valign="top"><a id="a93cccb07604149b28386b618700df59a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_WORKSPACE_SIZE_U64</b>&#160;&#160;&#160;(HUF_WORKSPACE_SIZE / sizeof(U64))</td></tr>
<tr class="separator:a93cccb07604149b28386b618700df59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b43a42d12141e7d38b3f44caada9ed"><td class="memItemLeft" align="right" valign="top"><a id="ad3b43a42d12141e7d38b3f44caada9ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_TABLELOG_MAX</b>&#160;&#160;&#160;12      /* max runtime value of tableLog (due to static allocation); can be modified up to HUF_TABLELOG_ABSOLUTEMAX */</td></tr>
<tr class="separator:ad3b43a42d12141e7d38b3f44caada9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5732d5d976ee82e06a13bf9023b17c"><td class="memItemLeft" align="right" valign="top"><a id="a4d5732d5d976ee82e06a13bf9023b17c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_TABLELOG_DEFAULT</b>&#160;&#160;&#160;11      /* default tableLog value when none specified */</td></tr>
<tr class="separator:a4d5732d5d976ee82e06a13bf9023b17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c49eb9cf4f83431910d65d1e7ba1cbc"><td class="memItemLeft" align="right" valign="top"><a id="a4c49eb9cf4f83431910d65d1e7ba1cbc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_SYMBOLVALUE_MAX</b>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a4c49eb9cf4f83431910d65d1e7ba1cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a44d8542571fe6f29aa469aa639c47"><td class="memItemLeft" align="right" valign="top"><a id="a86a44d8542571fe6f29aa469aa639c47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_TABLELOG_ABSOLUTEMAX</b>&#160;&#160;&#160;12  /* absolute limit of HUF_MAX_TABLELOG. Beyond that value, code does not work */</td></tr>
<tr class="separator:a86a44d8542571fe6f29aa469aa639c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1993a33bb7873bde979bf97f673a77c9"><td class="memItemLeft" align="right" valign="top"><a id="a1993a33bb7873bde979bf97f673a77c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_CTABLEBOUND</b>&#160;&#160;&#160;129</td></tr>
<tr class="separator:a1993a33bb7873bde979bf97f673a77c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7018b7f1e3f7698b2a5c95a37d6888c6"><td class="memItemLeft" align="right" valign="top"><a id="a7018b7f1e3f7698b2a5c95a37d6888c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_BLOCKBOUND</b>(size)&#160;&#160;&#160;(size + (size&gt;&gt;8) + 8)   /* only true when incompressible is pre-filtered with fast heuristic */</td></tr>
<tr class="separator:a7018b7f1e3f7698b2a5c95a37d6888c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09bda2bd694073f7898e624450d447f"><td class="memItemLeft" align="right" valign="top"><a id="aa09bda2bd694073f7898e624450d447f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_COMPRESSBOUND</b>(size)&#160;&#160;&#160;(HUF_CTABLEBOUND + HUF_BLOCKBOUND(size))   /* Macro version, useful for static allocation */</td></tr>
<tr class="separator:aa09bda2bd694073f7898e624450d447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c652de77186e9db165db475381c995b"><td class="memItemLeft" align="right" valign="top"><a id="a5c652de77186e9db165db475381c995b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_CTABLE_SIZE_ST</b>(maxSymbolValue)&#160;&#160;&#160;((maxSymbolValue)+2)   /* Use tables of size_t, for proper alignment */</td></tr>
<tr class="separator:a5c652de77186e9db165db475381c995b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e92c42a24215f3cf252462e840315e"><td class="memItemLeft" align="right" valign="top"><a id="af1e92c42a24215f3cf252462e840315e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_CTABLE_SIZE</b>(maxSymbolValue)&#160;&#160;&#160;(HUF_CTABLE_SIZE_ST(maxSymbolValue) * sizeof(size_t))</td></tr>
<tr class="separator:af1e92c42a24215f3cf252462e840315e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6e775f786b0750cda6473ccc8c705"><td class="memItemLeft" align="right" valign="top"><a id="acea6e775f786b0750cda6473ccc8c705"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_CREATE_STATIC_CTABLE</b>(name,  maxSymbolValue)&#160;&#160;&#160;    HUF_CElt name[HUF_CTABLE_SIZE_ST(maxSymbolValue)] /* no final ; */</td></tr>
<tr class="separator:acea6e775f786b0750cda6473ccc8c705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5ac395eab5eacc5f40d2003152b96d"><td class="memItemLeft" align="right" valign="top"><a id="a7e5ac395eab5eacc5f40d2003152b96d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DTABLE_SIZE</b>(maxTableLog)&#160;&#160;&#160;(1 + (1&lt;&lt;(maxTableLog)))</td></tr>
<tr class="separator:a7e5ac395eab5eacc5f40d2003152b96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c5cdf667d88e84ec5ba4deccbd2122"><td class="memItemLeft" align="right" valign="top"><a id="af6c5cdf667d88e84ec5ba4deccbd2122"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_CREATE_STATIC_DTABLEX1</b>(DTable,  maxTableLog)&#160;&#160;&#160;        HUF_DTable DTable[HUF_DTABLE_SIZE((maxTableLog)-1)] = { ((U32)((maxTableLog)-1) * 0x01000001) }</td></tr>
<tr class="separator:af6c5cdf667d88e84ec5ba4deccbd2122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f06b59e5487c8c3e1acf74d79ef1b2"><td class="memItemLeft" align="right" valign="top"><a id="a89f06b59e5487c8c3e1acf74d79ef1b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_CREATE_STATIC_DTABLEX2</b>(DTable,  maxTableLog)&#160;&#160;&#160;        HUF_DTable DTable[HUF_DTABLE_SIZE(maxTableLog)] = { ((U32)(maxTableLog) * 0x01000001) }</td></tr>
<tr class="separator:a89f06b59e5487c8c3e1acf74d79ef1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09a45039ec098945ff722c00247d5e6"><td class="memItemLeft" align="right" valign="top"><a id="aa09a45039ec098945ff722c00247d5e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_OPTIMAL_DEPTH_THRESHOLD</b>&#160;&#160;&#160;ZSTD_btultra</td></tr>
<tr class="separator:aa09a45039ec098945ff722c00247d5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2783725221941583eda32cb70a03660f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2783725221941583eda32cb70a03660f">HUF_CTABLE_WORKSPACE_SIZE_U32</a>&#160;&#160;&#160;((4 * (HUF_SYMBOLVALUE_MAX + 1)) + 192)</td></tr>
<tr class="separator:a2783725221941583eda32cb70a03660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273a335c135dff46022b025eeb1e7132"><td class="memItemLeft" align="right" valign="top"><a id="a273a335c135dff46022b025eeb1e7132"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_CTABLE_WORKSPACE_SIZE</b>&#160;&#160;&#160;(<a class="el" href="zstd_8c.html#a2783725221941583eda32cb70a03660f">HUF_CTABLE_WORKSPACE_SIZE_U32</a> * sizeof(unsigned))</td></tr>
<tr class="separator:a273a335c135dff46022b025eeb1e7132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9d85ed12f0835a94ca738bd83eb7ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a6f9d85ed12f0835a94ca738bd83eb7ea">HUF_READ_STATS_WORKSPACE_SIZE_U32</a>&#160;&#160;&#160;FSE_DECOMPRESS_WKSP_SIZE_U32(6, HUF_TABLELOG_MAX-1)</td></tr>
<tr class="separator:a6f9d85ed12f0835a94ca738bd83eb7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26aef08ac61da4b6037edc4000a3ebe"><td class="memItemLeft" align="right" valign="top"><a id="af26aef08ac61da4b6037edc4000a3ebe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_READ_STATS_WORKSPACE_SIZE</b>&#160;&#160;&#160;(<a class="el" href="zstd_8c.html#a6f9d85ed12f0835a94ca738bd83eb7ea">HUF_READ_STATS_WORKSPACE_SIZE_U32</a> * sizeof(unsigned))</td></tr>
<tr class="separator:af26aef08ac61da4b6037edc4000a3ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05bbfb5cce4b283be29cf13ab060ef1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac05bbfb5cce4b283be29cf13ab060ef1">HUF_DECOMPRESS_WORKSPACE_SIZE</a>&#160;&#160;&#160;((2 &lt;&lt; 10) + (1 &lt;&lt; 9))</td></tr>
<tr class="separator:ac05bbfb5cce4b283be29cf13ab060ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30947d35b5dbac2677aa026f11f19c31"><td class="memItemLeft" align="right" valign="top"><a id="a30947d35b5dbac2677aa026f11f19c31"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DECOMPRESS_WORKSPACE_SIZE_U32</b>&#160;&#160;&#160;(<a class="el" href="zstd_8c.html#ac05bbfb5cce4b283be29cf13ab060ef1">HUF_DECOMPRESS_WORKSPACE_SIZE</a> / sizeof(U32))</td></tr>
<tr class="separator:a30947d35b5dbac2677aa026f11f19c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab2ee8300d3fe2724cf97953dac66d0"><td class="memItemLeft" align="right" valign="top"><a id="a7ab2ee8300d3fe2724cf97953dac66d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_isError</b>&#160;&#160;&#160;ERR_isError</td></tr>
<tr class="separator:a7ab2ee8300d3fe2724cf97953dac66d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27f061d581dff15da48c0a35fa7224b"><td class="memItemLeft" align="right" valign="top"><a id="ae27f061d581dff15da48c0a35fa7224b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_ASSERT</b>(c)&#160;&#160;&#160;DEBUG_STATIC_ASSERT(c)   /* use only *after* variable declarations */</td></tr>
<tr class="separator:ae27f061d581dff15da48c0a35fa7224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ae58a682ca765a027b6dbf0e2c1d9a"><td class="memItemLeft" align="right" valign="top"><a id="a33ae58a682ca765a027b6dbf0e2c1d9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_CAT</b>(X,  Y)&#160;&#160;&#160;X##Y</td></tr>
<tr class="separator:a33ae58a682ca765a027b6dbf0e2c1d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51c73112dc4ec4987c33a7cd8481111"><td class="memItemLeft" align="right" valign="top"><a id="ac51c73112dc4ec4987c33a7cd8481111"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_FUNCTION_NAME</b>(X,  Y)&#160;&#160;&#160;FSE_CAT(X,Y)</td></tr>
<tr class="separator:ac51c73112dc4ec4987c33a7cd8481111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8ed897c89142452e54c9974bf32c8d"><td class="memItemLeft" align="right" valign="top"><a id="a9b8ed897c89142452e54c9974bf32c8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_TYPE_NAME</b>(X,  Y)&#160;&#160;&#160;FSE_CAT(X,Y)</td></tr>
<tr class="separator:a9b8ed897c89142452e54c9974bf32c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4311cab42e252d4341a7116a1cd489b2"><td class="memItemLeft" align="right" valign="top"><a id="a4311cab42e252d4341a7116a1cd489b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_GETSYMBOL</b>(statePtr)&#160;&#160;&#160;fast ? FSE_decodeSymbolFast(statePtr, &amp;bitD) : FSE_decodeSymbol(statePtr, &amp;bitD)</td></tr>
<tr class="separator:a4311cab42e252d4341a7116a1cd489b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59007e7f6a8ca5cc9f01099593574800"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a59007e7f6a8ca5cc9f01099593574800">THREADING_H_938743</a></td></tr>
<tr class="separator:a59007e7f6a8ca5cc9f01099593574800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd4126a89e25e7191c0411b881c6ea8"><td class="memItemLeft" align="right" valign="top"><a id="a2bd4126a89e25e7191c0411b881c6ea8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_mutex_t</b>&#160;&#160;&#160;pthread_mutex_t</td></tr>
<tr class="separator:a2bd4126a89e25e7191c0411b881c6ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083f8bc02277973473a27d0a7f6b27f6"><td class="memItemLeft" align="right" valign="top"><a id="a083f8bc02277973473a27d0a7f6b27f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_mutex_init</b>(a,  b)&#160;&#160;&#160;pthread_mutex_init((a), (b))</td></tr>
<tr class="separator:a083f8bc02277973473a27d0a7f6b27f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa023dc716067253eee788b1671cc0486"><td class="memItemLeft" align="right" valign="top"><a id="aa023dc716067253eee788b1671cc0486"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_mutex_destroy</b>(a)&#160;&#160;&#160;pthread_mutex_destroy((a))</td></tr>
<tr class="separator:aa023dc716067253eee788b1671cc0486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e951617f02090ff44fe77387ae2a75"><td class="memItemLeft" align="right" valign="top"><a id="a95e951617f02090ff44fe77387ae2a75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_mutex_lock</b>(a)&#160;&#160;&#160;pthread_mutex_lock((a))</td></tr>
<tr class="separator:a95e951617f02090ff44fe77387ae2a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ec6b23d4e6733409c37fb0b6209489"><td class="memItemLeft" align="right" valign="top"><a id="a55ec6b23d4e6733409c37fb0b6209489"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_mutex_unlock</b>(a)&#160;&#160;&#160;pthread_mutex_unlock((a))</td></tr>
<tr class="separator:a55ec6b23d4e6733409c37fb0b6209489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e0b633297a7cf8e276fc0620992b41"><td class="memItemLeft" align="right" valign="top"><a id="a09e0b633297a7cf8e276fc0620992b41"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_cond_t</b>&#160;&#160;&#160;pthread_cond_t</td></tr>
<tr class="separator:a09e0b633297a7cf8e276fc0620992b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c36560a4deb29cb72a1354f1b680d"><td class="memItemLeft" align="right" valign="top"><a id="aaf2c36560a4deb29cb72a1354f1b680d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_cond_init</b>(a,  b)&#160;&#160;&#160;pthread_cond_init((a), (b))</td></tr>
<tr class="separator:aaf2c36560a4deb29cb72a1354f1b680d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3502d2daf45dd39b5eab01794556d79"><td class="memItemLeft" align="right" valign="top"><a id="af3502d2daf45dd39b5eab01794556d79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_cond_destroy</b>(a)&#160;&#160;&#160;pthread_cond_destroy((a))</td></tr>
<tr class="separator:af3502d2daf45dd39b5eab01794556d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5931ab9a5b1aa29ae2348d9f1af23649"><td class="memItemLeft" align="right" valign="top"><a id="a5931ab9a5b1aa29ae2348d9f1af23649"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_cond_wait</b>(a,  b)&#160;&#160;&#160;pthread_cond_wait((a), (b))</td></tr>
<tr class="separator:a5931ab9a5b1aa29ae2348d9f1af23649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5868de43f89ec3bc451203eeeadc22a1"><td class="memItemLeft" align="right" valign="top"><a id="a5868de43f89ec3bc451203eeeadc22a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_cond_signal</b>(a)&#160;&#160;&#160;pthread_cond_signal((a))</td></tr>
<tr class="separator:a5868de43f89ec3bc451203eeeadc22a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd264d30b033c70289773ab62243d5a"><td class="memItemLeft" align="right" valign="top"><a id="a6cd264d30b033c70289773ab62243d5a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_cond_broadcast</b>(a)&#160;&#160;&#160;pthread_cond_broadcast((a))</td></tr>
<tr class="separator:a6cd264d30b033c70289773ab62243d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccfbd3b12036ad3e4d349da1835065d"><td class="memItemLeft" align="right" valign="top"><a id="a3ccfbd3b12036ad3e4d349da1835065d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_t</b>&#160;&#160;&#160;pthread_t</td></tr>
<tr class="separator:a3ccfbd3b12036ad3e4d349da1835065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b65bada0144e6b8a4c583f5f8d39f9"><td class="memItemLeft" align="right" valign="top"><a id="a81b65bada0144e6b8a4c583f5f8d39f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_create</b>(a,  b,  c,  d)&#160;&#160;&#160;pthread_create((a), (b), (c), (d))</td></tr>
<tr class="separator:a81b65bada0144e6b8a4c583f5f8d39f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abfcedfa687701f87b42569850543cb"><td class="memItemLeft" align="right" valign="top"><a id="a3abfcedfa687701f87b42569850543cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_pthread_join</b>(a)&#160;&#160;&#160;pthread_join((a),NULL)</td></tr>
<tr class="separator:a3abfcedfa687701f87b42569850543cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec470b07ea51d527cd012ee2d1e545b6"><td class="memItemLeft" align="right" valign="top"><a id="aec470b07ea51d527cd012ee2d1e545b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_NEED_MALLOC</b></td></tr>
<tr class="separator:aec470b07ea51d527cd012ee2d1e545b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memItemLeft" align="right" valign="top"><a id="ad88034c8350c3d479ce0db09fd8ee0c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37fde4db1b3a00f5d17637df7ee7cef"><td class="memItemLeft" align="right" valign="top"><a id="ac37fde4db1b3a00f5d17637df7ee7cef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_H_235446</b></td></tr>
<tr class="separator:ac37fde4db1b3a00f5d17637df7ee7cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5253dd1efdcd3753498c73bd8f1b56a7"><td class="memItemLeft" align="right" valign="top"><a id="a5253dd1efdcd3753498c73bd8f1b56a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDLIB_VISIBLE</b></td></tr>
<tr class="separator:a5253dd1efdcd3753498c73bd8f1b56a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac019959fad7a1dcbc28d6c4b310d330b"><td class="memItemLeft" align="right" valign="top"><a id="ac019959fad7a1dcbc28d6c4b310d330b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDLIB_HIDDEN</b></td></tr>
<tr class="separator:ac019959fad7a1dcbc28d6c4b310d330b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbac0fbe1cd466cb2b82c5401e2ec49"><td class="memItemLeft" align="right" valign="top"><a id="a9dbac0fbe1cd466cb2b82c5401e2ec49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDLIB_API</b>&#160;&#160;&#160;ZSTDLIB_VISIBLE</td></tr>
<tr class="separator:a9dbac0fbe1cd466cb2b82c5401e2ec49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf0b4d3b5a4581beb7465783419a659"><td class="memItemLeft" align="right" valign="top"><a id="a8cf0b4d3b5a4581beb7465783419a659"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPRECATED</b>(message)</td></tr>
<tr class="separator:a8cf0b4d3b5a4581beb7465783419a659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a867002655c8077460a47e5960e4bc"><td class="memItemLeft" align="right" valign="top"><a id="aa4a867002655c8077460a47e5960e4bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_VERSION_MAJOR</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa4a867002655c8077460a47e5960e4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96b66eabc8a315ce4c2b6c34b29746f"><td class="memItemLeft" align="right" valign="top"><a id="ad96b66eabc8a315ce4c2b6c34b29746f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_VERSION_MINOR</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:ad96b66eabc8a315ce4c2b6c34b29746f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ca36516a6cfafe730e00f6e5cc3f23"><td class="memItemLeft" align="right" valign="top"><a id="a82ca36516a6cfafe730e00f6e5cc3f23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_VERSION_RELEASE</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a82ca36516a6cfafe730e00f6e5cc3f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac5656bb6539eae98593afd3493132"><td class="memItemLeft" align="right" valign="top"><a id="a50ac5656bb6539eae98593afd3493132"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_VERSION_NUMBER</b>&#160;&#160;&#160;(ZSTD_VERSION_MAJOR *100*100 + ZSTD_VERSION_MINOR *100 + ZSTD_VERSION_RELEASE)</td></tr>
<tr class="separator:a50ac5656bb6539eae98593afd3493132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48024c26f41157f9f013bda534ad41e6"><td class="memItemLeft" align="right" valign="top"><a id="a48024c26f41157f9f013bda534ad41e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LIB_VERSION</b>&#160;&#160;&#160;ZSTD_VERSION_MAJOR.ZSTD_VERSION_MINOR.ZSTD_VERSION_RELEASE</td></tr>
<tr class="separator:a48024c26f41157f9f013bda534ad41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbadef2056cbbc1b4d24523c2c6cb5b"><td class="memItemLeft" align="right" valign="top"><a id="adbbadef2056cbbc1b4d24523c2c6cb5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_QUOTE</b>(str)&#160;&#160;&#160;#str</td></tr>
<tr class="separator:adbbadef2056cbbc1b4d24523c2c6cb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f28056060ce509b3c9c7c6551a6ac28"><td class="memItemLeft" align="right" valign="top"><a id="a5f28056060ce509b3c9c7c6551a6ac28"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_EXPAND_AND_QUOTE</b>(str)&#160;&#160;&#160;ZSTD_QUOTE(str)</td></tr>
<tr class="separator:a5f28056060ce509b3c9c7c6551a6ac28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930937e5d86408c3c866db9af7edd8b8"><td class="memItemLeft" align="right" valign="top"><a id="a930937e5d86408c3c866db9af7edd8b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_VERSION_STRING</b>&#160;&#160;&#160;ZSTD_EXPAND_AND_QUOTE(ZSTD_LIB_VERSION)</td></tr>
<tr class="separator:a930937e5d86408c3c866db9af7edd8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8796a8b03292b1bb5847b26431e536e9"><td class="memItemLeft" align="right" valign="top"><a id="a8796a8b03292b1bb5847b26431e536e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CLEVEL_DEFAULT</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a8796a8b03292b1bb5847b26431e536e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7730eadd3460372e41676ad264102b0d"><td class="memItemLeft" align="right" valign="top"><a id="a7730eadd3460372e41676ad264102b0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MAGICNUMBER</b>&#160;&#160;&#160;0xFD2FB528    /* valid since v0.8.0 */</td></tr>
<tr class="separator:a7730eadd3460372e41676ad264102b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8022a3420a48c182e3ee25e7a69ddad1"><td class="memItemLeft" align="right" valign="top"><a id="a8022a3420a48c182e3ee25e7a69ddad1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MAGIC_DICTIONARY</b>&#160;&#160;&#160;0xEC30A437    /* valid since v0.7.0 */</td></tr>
<tr class="separator:a8022a3420a48c182e3ee25e7a69ddad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0fe574b2afcca1fa0507cd5ed39981"><td class="memItemLeft" align="right" valign="top"><a id="afe0fe574b2afcca1fa0507cd5ed39981"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MAGIC_SKIPPABLE_START</b>&#160;&#160;&#160;0x184D2A50    /* all 16 values, from 0x184D2A50 to 0x184D2A5F, signal the beginning of a skippable frame */</td></tr>
<tr class="separator:afe0fe574b2afcca1fa0507cd5ed39981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844cb3f566291c34f18c7b276c23a5f6"><td class="memItemLeft" align="right" valign="top"><a id="a844cb3f566291c34f18c7b276c23a5f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MAGIC_SKIPPABLE_MASK</b>&#160;&#160;&#160;0xFFFFFFF0</td></tr>
<tr class="separator:a844cb3f566291c34f18c7b276c23a5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332cab537cb436073ac3e96ec978a745"><td class="memItemLeft" align="right" valign="top"><a id="a332cab537cb436073ac3e96ec978a745"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BLOCKSIZELOG_MAX</b>&#160;&#160;&#160;17</td></tr>
<tr class="separator:a332cab537cb436073ac3e96ec978a745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfdbfff9ffbb6fabf009b7ad1d6ccc5"><td class="memItemLeft" align="right" valign="top"><a id="afcfdbfff9ffbb6fabf009b7ad1d6ccc5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BLOCKSIZE_MAX</b>&#160;&#160;&#160;(1&lt;&lt;ZSTD_BLOCKSIZELOG_MAX)</td></tr>
<tr class="separator:afcfdbfff9ffbb6fabf009b7ad1d6ccc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74205e53e7140614077873c76874d842"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a74205e53e7140614077873c76874d842">ZSTD_CONTENTSIZE_UNKNOWN</a>&#160;&#160;&#160;(0ULL - 1)</td></tr>
<tr class="separator:a74205e53e7140614077873c76874d842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0cd2c155fe137622fe609a91d9c570"><td class="memItemLeft" align="right" valign="top"><a id="aab0cd2c155fe137622fe609a91d9c570"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CONTENTSIZE_ERROR</b>&#160;&#160;&#160;(0ULL - 2)</td></tr>
<tr class="separator:aab0cd2c155fe137622fe609a91d9c570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968d2cc21153e3377666e3bfadbcef03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a968d2cc21153e3377666e3bfadbcef03">ZSTD_MAX_INPUT_SIZE</a>&#160;&#160;&#160;((sizeof(size_t)==8) ? 0xFF00FF00FF00FF00ULL : 0xFF00FF00U)</td></tr>
<tr class="separator:a968d2cc21153e3377666e3bfadbcef03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6245b5704088ff4a6af51e523ad268"><td class="memItemLeft" align="right" valign="top"><a id="aad6245b5704088ff4a6af51e523ad268"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBOUND</b>(srcSize)&#160;&#160;&#160;(((size_t)(srcSize) &gt;= <a class="el" href="zstd_8c.html#a968d2cc21153e3377666e3bfadbcef03">ZSTD_MAX_INPUT_SIZE</a>) ? 0 : (srcSize) + ((srcSize)&gt;&gt;8) + (((srcSize) &lt; (128&lt;&lt;10)) ? (((128&lt;&lt;10) - (srcSize)) &gt;&gt; 11) /* margin, from 64 to 0 */ : 0))  /* this formula ensures that bound(A) + bound(B) &lt;= bound(A+B) as long as A and B &gt;= 128 KB */</td></tr>
<tr class="separator:aad6245b5704088ff4a6af51e523ad268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37eeb9574b781c9a98a604259bcc96e"><td class="memItemLeft" align="right" valign="top"><a id="aa37eeb9574b781c9a98a604259bcc96e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_H_ZSTD_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:aa37eeb9574b781c9a98a604259bcc96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf29b14d970376cf7fdc063e78f6e889"><td class="memItemLeft" align="right" valign="top"><a id="abf29b14d970376cf7fdc063e78f6e889"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDLIB_STATIC_API</b>&#160;&#160;&#160;ZSTDLIB_VISIBLE</td></tr>
<tr class="separator:abf29b14d970376cf7fdc063e78f6e889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a1114de3084503d2c57e4662dafbd6"><td class="memItemLeft" align="right" valign="top"><a id="a12a1114de3084503d2c57e4662dafbd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FRAMEHEADERSIZE_PREFIX</b>(format)&#160;&#160;&#160;((format) == ZSTD_f_zstd1 ? 5 : 1)   /* minimum input size required to query frame header size */</td></tr>
<tr class="separator:a12a1114de3084503d2c57e4662dafbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ac5ae4d77c0eee631cb87df91a5d71"><td class="memItemLeft" align="right" valign="top"><a id="a29ac5ae4d77c0eee631cb87df91a5d71"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FRAMEHEADERSIZE_MIN</b>(format)&#160;&#160;&#160;((format) == ZSTD_f_zstd1 ? 6 : 2)</td></tr>
<tr class="separator:a29ac5ae4d77c0eee631cb87df91a5d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb249795c8bf82ac9b67d14a9ee2ad26"><td class="memItemLeft" align="right" valign="top"><a id="acb249795c8bf82ac9b67d14a9ee2ad26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FRAMEHEADERSIZE_MAX</b>&#160;&#160;&#160;18   /* can be useful for static allocation */</td></tr>
<tr class="separator:acb249795c8bf82ac9b67d14a9ee2ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc0784a3ead05db2cd20c89636765a9"><td class="memItemLeft" align="right" valign="top"><a id="a6bc0784a3ead05db2cd20c89636765a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SKIPPABLEHEADERSIZE</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a6bc0784a3ead05db2cd20c89636765a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd269b4ac7aa628658dcfd0056700f7"><td class="memItemLeft" align="right" valign="top"><a id="a3bd269b4ac7aa628658dcfd0056700f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WINDOWLOG_MAX_32</b>&#160;&#160;&#160;30</td></tr>
<tr class="separator:a3bd269b4ac7aa628658dcfd0056700f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904d2299a5dc245f5e545c183a4ed59a"><td class="memItemLeft" align="right" valign="top"><a id="a904d2299a5dc245f5e545c183a4ed59a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WINDOWLOG_MAX_64</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:a904d2299a5dc245f5e545c183a4ed59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c920b9e455fc7dd91394cee17b7d60c"><td class="memItemLeft" align="right" valign="top"><a id="a6c920b9e455fc7dd91394cee17b7d60c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WINDOWLOG_MAX</b>&#160;&#160;&#160;((int)(sizeof(size_t) == 4 ? ZSTD_WINDOWLOG_MAX_32 : ZSTD_WINDOWLOG_MAX_64))</td></tr>
<tr class="separator:a6c920b9e455fc7dd91394cee17b7d60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69da56534afdcd5d1ab87dd91a1253a9"><td class="memItemLeft" align="right" valign="top"><a id="a69da56534afdcd5d1ab87dd91a1253a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WINDOWLOG_MIN</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a69da56534afdcd5d1ab87dd91a1253a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3c416c34d727c7021a6e3f31001ee2"><td class="memItemLeft" align="right" valign="top"><a id="a3f3c416c34d727c7021a6e3f31001ee2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HASHLOG_MAX</b>&#160;&#160;&#160;((ZSTD_WINDOWLOG_MAX &lt; 30) ? ZSTD_WINDOWLOG_MAX : 30)</td></tr>
<tr class="separator:a3f3c416c34d727c7021a6e3f31001ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207307ff7e59ccac6abffb18539e3184"><td class="memItemLeft" align="right" valign="top"><a id="a207307ff7e59ccac6abffb18539e3184"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HASHLOG_MIN</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a207307ff7e59ccac6abffb18539e3184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0e3ecfe86efb9b2e6ff36c29bc5b0"><td class="memItemLeft" align="right" valign="top"><a id="ad2d0e3ecfe86efb9b2e6ff36c29bc5b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CHAINLOG_MAX_32</b>&#160;&#160;&#160;29</td></tr>
<tr class="separator:ad2d0e3ecfe86efb9b2e6ff36c29bc5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ef924b49c5e15d4df44860a9a9420e"><td class="memItemLeft" align="right" valign="top"><a id="a82ef924b49c5e15d4df44860a9a9420e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CHAINLOG_MAX_64</b>&#160;&#160;&#160;30</td></tr>
<tr class="separator:a82ef924b49c5e15d4df44860a9a9420e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5405e9b8df3d7d93b278f31933027b7"><td class="memItemLeft" align="right" valign="top"><a id="ab5405e9b8df3d7d93b278f31933027b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CHAINLOG_MAX</b>&#160;&#160;&#160;((int)(sizeof(size_t) == 4 ? ZSTD_CHAINLOG_MAX_32 : ZSTD_CHAINLOG_MAX_64))</td></tr>
<tr class="separator:ab5405e9b8df3d7d93b278f31933027b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d495e390ac907b072a292bfe28c5ec"><td class="memItemLeft" align="right" valign="top"><a id="a98d495e390ac907b072a292bfe28c5ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CHAINLOG_MIN</b>&#160;&#160;&#160;ZSTD_HASHLOG_MIN</td></tr>
<tr class="separator:a98d495e390ac907b072a292bfe28c5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b49543046ea1df37ad77656b1c6292"><td class="memItemLeft" align="right" valign="top"><a id="ab6b49543046ea1df37ad77656b1c6292"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SEARCHLOG_MAX</b>&#160;&#160;&#160;(ZSTD_WINDOWLOG_MAX-1)</td></tr>
<tr class="separator:ab6b49543046ea1df37ad77656b1c6292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28032b39930695254f65724bde24b3d8"><td class="memItemLeft" align="right" valign="top"><a id="a28032b39930695254f65724bde24b3d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SEARCHLOG_MIN</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a28032b39930695254f65724bde24b3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae918409e93dadbdfbcc30899a92b4f9c"><td class="memItemLeft" align="right" valign="top"><a id="ae918409e93dadbdfbcc30899a92b4f9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MINMATCH_MAX</b>&#160;&#160;&#160;7   /* only for ZSTD_fast, other strategies are limited to 6 */</td></tr>
<tr class="separator:ae918409e93dadbdfbcc30899a92b4f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad621f0744273cf1f5eca621e6537b3a8"><td class="memItemLeft" align="right" valign="top"><a id="ad621f0744273cf1f5eca621e6537b3a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MINMATCH_MIN</b>&#160;&#160;&#160;3   /* only for ZSTD_btopt+, faster strategies are limited to 4 */</td></tr>
<tr class="separator:ad621f0744273cf1f5eca621e6537b3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e449634c832e5b9c114c580e21bb57"><td class="memItemLeft" align="right" valign="top"><a id="a96e449634c832e5b9c114c580e21bb57"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_TARGETLENGTH_MAX</b>&#160;&#160;&#160;ZSTD_BLOCKSIZE_MAX</td></tr>
<tr class="separator:a96e449634c832e5b9c114c580e21bb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf5c13244167775eb0642e3eb259d25"><td class="memItemLeft" align="right" valign="top"><a id="aecf5c13244167775eb0642e3eb259d25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_TARGETLENGTH_MIN</b>&#160;&#160;&#160;0   /* note : comparing this constant to an unsigned results in a tautological test */</td></tr>
<tr class="separator:aecf5c13244167775eb0642e3eb259d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7230b0b23554d4ec7d763afd2017d0"><td class="memItemLeft" align="right" valign="top"><a id="a7d7230b0b23554d4ec7d763afd2017d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_STRATEGY_MIN</b>&#160;&#160;&#160;ZSTD_fast</td></tr>
<tr class="separator:a7d7230b0b23554d4ec7d763afd2017d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c6226cb806227a088964e4a7c10116"><td class="memItemLeft" align="right" valign="top"><a id="a05c6226cb806227a088964e4a7c10116"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_STRATEGY_MAX</b>&#160;&#160;&#160;ZSTD_btultra2</td></tr>
<tr class="separator:a05c6226cb806227a088964e4a7c10116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51cfb2d41dee4d1dac4cbdad853c591"><td class="memItemLeft" align="right" valign="top"><a id="af51cfb2d41dee4d1dac4cbdad853c591"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BLOCKSIZE_MAX_MIN</b>&#160;&#160;&#160;(1 &lt;&lt; 10) /* The minimum valid max blocksize. Maximum blocksizes smaller than this make compressBound() inaccurate. */</td></tr>
<tr class="separator:af51cfb2d41dee4d1dac4cbdad853c591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac062dcafbe7ed4e04c3138397cc5e5f3"><td class="memItemLeft" align="right" valign="top"><a id="ac062dcafbe7ed4e04c3138397cc5e5f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_OVERLAPLOG_MIN</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ac062dcafbe7ed4e04c3138397cc5e5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1779e133b333d1fa8043262392d16a"><td class="memItemLeft" align="right" valign="top"><a id="acb1779e133b333d1fa8043262392d16a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_OVERLAPLOG_MAX</b>&#160;&#160;&#160;9</td></tr>
<tr class="separator:acb1779e133b333d1fa8043262392d16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fc5f632ee86bfcdaa096773908fb99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WINDOWLOG_LIMIT_DEFAULT</b></td></tr>
<tr class="separator:a06fc5f632ee86bfcdaa096773908fb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1d8e65cb11baa249e88ed82ac8132c"><td class="memItemLeft" align="right" valign="top"><a id="a3b1d8e65cb11baa249e88ed82ac8132c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_HASHLOG_MIN</b>&#160;&#160;&#160;ZSTD_HASHLOG_MIN</td></tr>
<tr class="separator:a3b1d8e65cb11baa249e88ed82ac8132c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb21cc79efa7d027fd24dd63fe6ce0e5"><td class="memItemLeft" align="right" valign="top"><a id="adb21cc79efa7d027fd24dd63fe6ce0e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_HASHLOG_MAX</b>&#160;&#160;&#160;ZSTD_HASHLOG_MAX</td></tr>
<tr class="separator:adb21cc79efa7d027fd24dd63fe6ce0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9311bb712267ec1ba212d72f870c4291"><td class="memItemLeft" align="right" valign="top"><a id="a9311bb712267ec1ba212d72f870c4291"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_MINMATCH_MIN</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a9311bb712267ec1ba212d72f870c4291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc5ab655aee1eb22cfe732d13a67d2e"><td class="memItemLeft" align="right" valign="top"><a id="a6bc5ab655aee1eb22cfe732d13a67d2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_MINMATCH_MAX</b>&#160;&#160;&#160;4096</td></tr>
<tr class="separator:a6bc5ab655aee1eb22cfe732d13a67d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8f6c417a62de9bf1c5f056b1c8e2d"><td class="memItemLeft" align="right" valign="top"><a id="a49c8f6c417a62de9bf1c5f056b1c8e2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_BUCKETSIZELOG_MIN</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a49c8f6c417a62de9bf1c5f056b1c8e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f25277b0992bc582dc388ad003cdad"><td class="memItemLeft" align="right" valign="top"><a id="ab5f25277b0992bc582dc388ad003cdad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_BUCKETSIZELOG_MAX</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ab5f25277b0992bc582dc388ad003cdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2c9ea3574802297aed7807d2263a3a"><td class="memItemLeft" align="right" valign="top"><a id="a0d2c9ea3574802297aed7807d2263a3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_HASHRATELOG_MIN</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a0d2c9ea3574802297aed7807d2263a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c122499a0c8685e2c3ed2165816565a"><td class="memItemLeft" align="right" valign="top"><a id="a7c122499a0c8685e2c3ed2165816565a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_HASHRATELOG_MAX</b>&#160;&#160;&#160;(ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN)</td></tr>
<tr class="separator:a7c122499a0c8685e2c3ed2165816565a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8760d8502fa80eb860e2dd85d7fdad88"><td class="memItemLeft" align="right" valign="top"><a id="a8760d8502fa80eb860e2dd85d7fdad88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_TARGETCBLOCKSIZE_MIN</b>&#160;&#160;&#160;1340 /* suitable to fit into an ethernet / wifi / 4G transport frame */</td></tr>
<tr class="separator:a8760d8502fa80eb860e2dd85d7fdad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24e2f32f59bbd3aa4472565e2c83856"><td class="memItemLeft" align="right" valign="top"><a id="af24e2f32f59bbd3aa4472565e2c83856"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_TARGETCBLOCKSIZE_MAX</b>&#160;&#160;&#160;ZSTD_BLOCKSIZE_MAX</td></tr>
<tr class="separator:af24e2f32f59bbd3aa4472565e2c83856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9a75ca4b936735f7e212fa9ed0230b"><td class="memItemLeft" align="right" valign="top"><a id="a8e9a75ca4b936735f7e212fa9ed0230b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SRCSIZEHINT_MIN</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a8e9a75ca4b936735f7e212fa9ed0230b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78582c28e06975b10dd7bc3889353c9"><td class="memItemLeft" align="right" valign="top"><a id="ab78582c28e06975b10dd7bc3889353c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SRCSIZEHINT_MAX</b>&#160;&#160;&#160;INT_MAX</td></tr>
<tr class="separator:ab78582c28e06975b10dd7bc3889353c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce0293cb0f474dbfbb95533429bc4c"><td class="memItemLeft" align="right" valign="top"><a id="ae2ce0293cb0f474dbfbb95533429bc4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_paramSwitch_e</b>&#160;&#160;&#160;ZSTD_ParamSwitch_e  /* old name */</td></tr>
<tr class="separator:ae2ce0293cb0f474dbfbb95533429bc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a8ff173e9601ad3668ccd9be6b990a"><td class="memItemLeft" align="right" valign="top"><a id="a62a8ff173e9601ad3668ccd9be6b990a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_frameType_e</b>&#160;&#160;&#160;ZSTD_FrameType_e /* old name */</td></tr>
<tr class="separator:a62a8ff173e9601ad3668ccd9be6b990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b05167071095de891a73cfda94dcfc0"><td class="memItemLeft" align="right" valign="top"><a id="a5b05167071095de891a73cfda94dcfc0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_frameHeader</b>&#160;&#160;&#160;<a class="el" href="structZSTD__FrameHeader.html">ZSTD_FrameHeader</a> /* old name */</td></tr>
<tr class="separator:a5b05167071095de891a73cfda94dcfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a1ac72ca8747f89743a0c134f085d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a39a1ac72ca8747f89743a0c134f085d2">ZSTD_DECOMPRESSION_MARGIN</a>(originalSize,  blockSize)</td></tr>
<tr class="separator:a39a1ac72ca8747f89743a0c134f085d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcf6190ddd909fcd372f9f0d7df677e"><td class="memItemLeft" align="right" valign="top"><a id="acdcf6190ddd909fcd372f9f0d7df677e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_sequenceFormat_e</b>&#160;&#160;&#160;ZSTD_SequenceFormat_e /* old name */</td></tr>
<tr class="separator:acdcf6190ddd909fcd372f9f0d7df677e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603b83d43620cfc8f505303ab6854c4f"><td class="memItemLeft" align="right" valign="top"><a id="a603b83d43620cfc8f505303ab6854c4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_rsyncable</b>&#160;&#160;&#160;ZSTD_c_experimentalParam1</td></tr>
<tr class="separator:a603b83d43620cfc8f505303ab6854c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d8829d0449b75a51b31e09ac0b1f29"><td class="memItemLeft" align="right" valign="top"><a id="ae7d8829d0449b75a51b31e09ac0b1f29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_format</b>&#160;&#160;&#160;ZSTD_c_experimentalParam2</td></tr>
<tr class="separator:ae7d8829d0449b75a51b31e09ac0b1f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cf1788d9eb94b350f3b3fc7cfc251e"><td class="memItemLeft" align="right" valign="top"><a id="ac6cf1788d9eb94b350f3b3fc7cfc251e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_forceMaxWindow</b>&#160;&#160;&#160;ZSTD_c_experimentalParam3</td></tr>
<tr class="separator:ac6cf1788d9eb94b350f3b3fc7cfc251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9b0e0d977fdd0c19c6cab0ecda8356"><td class="memItemLeft" align="right" valign="top"><a id="afa9b0e0d977fdd0c19c6cab0ecda8356"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_forceAttachDict</b>&#160;&#160;&#160;ZSTD_c_experimentalParam4</td></tr>
<tr class="separator:afa9b0e0d977fdd0c19c6cab0ecda8356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4281222cc4ce2341440f68fd89dfeb6"><td class="memItemLeft" align="right" valign="top"><a id="ae4281222cc4ce2341440f68fd89dfeb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_literalCompressionMode</b>&#160;&#160;&#160;ZSTD_c_experimentalParam5</td></tr>
<tr class="separator:ae4281222cc4ce2341440f68fd89dfeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c83ae9e803f0be5210c45906fa1d8e"><td class="memItemLeft" align="right" valign="top"><a id="a45c83ae9e803f0be5210c45906fa1d8e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_srcSizeHint</b>&#160;&#160;&#160;ZSTD_c_experimentalParam7</td></tr>
<tr class="separator:a45c83ae9e803f0be5210c45906fa1d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c1897a919f00aae26aab26bdd5ccd7"><td class="memItemLeft" align="right" valign="top"><a id="a73c1897a919f00aae26aab26bdd5ccd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_enableDedicatedDictSearch</b>&#160;&#160;&#160;ZSTD_c_experimentalParam8</td></tr>
<tr class="separator:a73c1897a919f00aae26aab26bdd5ccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29fc787da7a68e7fc010d60deaa2dd2"><td class="memItemLeft" align="right" valign="top"><a id="ad29fc787da7a68e7fc010d60deaa2dd2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_stableInBuffer</b>&#160;&#160;&#160;ZSTD_c_experimentalParam9</td></tr>
<tr class="separator:ad29fc787da7a68e7fc010d60deaa2dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986b74b2dd70c4ef4518e432a9f9fcbd"><td class="memItemLeft" align="right" valign="top"><a id="a986b74b2dd70c4ef4518e432a9f9fcbd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_stableOutBuffer</b>&#160;&#160;&#160;ZSTD_c_experimentalParam10</td></tr>
<tr class="separator:a986b74b2dd70c4ef4518e432a9f9fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af763e0900aad903811c8596d88143ce0"><td class="memItemLeft" align="right" valign="top"><a id="af763e0900aad903811c8596d88143ce0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_blockDelimiters</b>&#160;&#160;&#160;ZSTD_c_experimentalParam11</td></tr>
<tr class="separator:af763e0900aad903811c8596d88143ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88cbf6450654e853f77351fa2aebb34"><td class="memItemLeft" align="right" valign="top"><a id="aa88cbf6450654e853f77351fa2aebb34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_validateSequences</b>&#160;&#160;&#160;ZSTD_c_experimentalParam12</td></tr>
<tr class="separator:aa88cbf6450654e853f77351fa2aebb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9568e4a308ad343304539496e2a54558"><td class="memItemLeft" align="right" valign="top"><a id="a9568e4a308ad343304539496e2a54558"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BLOCKSPLITTER_LEVEL_MAX</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a9568e4a308ad343304539496e2a54558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90d5b19a25aa6b39a113a30db06f70b"><td class="memItemLeft" align="right" valign="top"><a id="aa90d5b19a25aa6b39a113a30db06f70b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_blockSplitterLevel</b>&#160;&#160;&#160;ZSTD_c_experimentalParam20</td></tr>
<tr class="separator:aa90d5b19a25aa6b39a113a30db06f70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73edffe40c4e1f37934b686f0449a4b2"><td class="memItemLeft" align="right" valign="top"><a id="a73edffe40c4e1f37934b686f0449a4b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_splitAfterSequences</b>&#160;&#160;&#160;ZSTD_c_experimentalParam13</td></tr>
<tr class="separator:a73edffe40c4e1f37934b686f0449a4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7698e11cb7d587b73002acd8a616d22b"><td class="memItemLeft" align="right" valign="top"><a id="a7698e11cb7d587b73002acd8a616d22b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_useRowMatchFinder</b>&#160;&#160;&#160;ZSTD_c_experimentalParam14</td></tr>
<tr class="separator:a7698e11cb7d587b73002acd8a616d22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a00fffd1f65c8770aebe1d7d626813"><td class="memItemLeft" align="right" valign="top"><a id="ab2a00fffd1f65c8770aebe1d7d626813"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_deterministicRefPrefix</b>&#160;&#160;&#160;ZSTD_c_experimentalParam15</td></tr>
<tr class="separator:ab2a00fffd1f65c8770aebe1d7d626813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd853531b2d5ca5ad994d08e20863f31"><td class="memItemLeft" align="right" valign="top"><a id="afd853531b2d5ca5ad994d08e20863f31"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_prefetchCDictTables</b>&#160;&#160;&#160;ZSTD_c_experimentalParam16</td></tr>
<tr class="separator:afd853531b2d5ca5ad994d08e20863f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8404078b27727b81d5720b6f51a2ec2a"><td class="memItemLeft" align="right" valign="top"><a id="a8404078b27727b81d5720b6f51a2ec2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_enableSeqProducerFallback</b>&#160;&#160;&#160;ZSTD_c_experimentalParam17</td></tr>
<tr class="separator:a8404078b27727b81d5720b6f51a2ec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ed382903efa6a90675f8fe795c4b33"><td class="memItemLeft" align="right" valign="top"><a id="ac4ed382903efa6a90675f8fe795c4b33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_maxBlockSize</b>&#160;&#160;&#160;ZSTD_c_experimentalParam18</td></tr>
<tr class="separator:ac4ed382903efa6a90675f8fe795c4b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548a02510987ef2c33e7b198c82ed7e"><td class="memItemLeft" align="right" valign="top"><a id="a1548a02510987ef2c33e7b198c82ed7e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_repcodeResolution</b>&#160;&#160;&#160;ZSTD_c_experimentalParam19</td></tr>
<tr class="separator:a1548a02510987ef2c33e7b198c82ed7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f55b97c17b310f798180337a3f21e3"><td class="memItemLeft" align="right" valign="top"><a id="a31f55b97c17b310f798180337a3f21e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_c_searchForExternalRepcodes</b>&#160;&#160;&#160;ZSTD_c_experimentalParam19 /* older name */</td></tr>
<tr class="separator:a31f55b97c17b310f798180337a3f21e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdae76a6efc3bcf096b1e6a728e5367"><td class="memItemLeft" align="right" valign="top"><a id="a5bdae76a6efc3bcf096b1e6a728e5367"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_d_format</b>&#160;&#160;&#160;ZSTD_d_experimentalParam1</td></tr>
<tr class="separator:a5bdae76a6efc3bcf096b1e6a728e5367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9970c52ca11d2b90d79c2bb0635adbde"><td class="memItemLeft" align="right" valign="top"><a id="a9970c52ca11d2b90d79c2bb0635adbde"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_d_stableOutBuffer</b>&#160;&#160;&#160;ZSTD_d_experimentalParam2</td></tr>
<tr class="separator:a9970c52ca11d2b90d79c2bb0635adbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6683563da18a19ff3840ddc95cc829"><td class="memItemLeft" align="right" valign="top"><a id="a3f6683563da18a19ff3840ddc95cc829"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_d_forceIgnoreChecksum</b>&#160;&#160;&#160;ZSTD_d_experimentalParam3</td></tr>
<tr class="separator:a3f6683563da18a19ff3840ddc95cc829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f77b71af2e1adb2d95effd739e412f"><td class="memItemLeft" align="right" valign="top"><a id="ab6f77b71af2e1adb2d95effd739e412f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_d_refMultipleDDicts</b>&#160;&#160;&#160;ZSTD_d_experimentalParam4</td></tr>
<tr class="separator:ab6f77b71af2e1adb2d95effd739e412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e29631e3d4724ef869c7ad2d28b839"><td class="memItemLeft" align="right" valign="top"><a id="a98e29631e3d4724ef869c7ad2d28b839"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_d_disableHuffmanAssembly</b>&#160;&#160;&#160;ZSTD_d_experimentalParam5</td></tr>
<tr class="separator:a98e29631e3d4724ef869c7ad2d28b839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5905a9a633473bfef4ec47d77dc1e0c8"><td class="memItemLeft" align="right" valign="top"><a id="a5905a9a633473bfef4ec47d77dc1e0c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_d_maxBlockSize</b>&#160;&#160;&#160;ZSTD_d_experimentalParam6</td></tr>
<tr class="separator:a5905a9a633473bfef4ec47d77dc1e0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebb8604002af791d0bba1d2ad029f93"><td class="memItemLeft" align="right" valign="top"><a id="a9ebb8604002af791d0bba1d2ad029f93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SEQUENCE_PRODUCER_ERROR</b>&#160;&#160;&#160;((size_t)(-1))</td></tr>
<tr class="separator:a9ebb8604002af791d0bba1d2ad029f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2a6b6887864e6ee6d92958c8aff07b"><td class="memItemLeft" align="right" valign="top"><a id="a9b2a6b6887864e6ee6d92958c8aff07b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ALLOCATIONS_H</b></td></tr>
<tr class="separator:a9b2a6b6887864e6ee6d92958c8aff07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0800cbc1d3d60f134f909e8a9e6c7475"><td class="memItemLeft" align="right" valign="top"><a id="a0800cbc1d3d60f134f909e8a9e6c7475"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>POOL_H</b></td></tr>
<tr class="separator:a0800cbc1d3d60f134f909e8a9e6c7475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memItemLeft" align="right" valign="top"><a id="ad88034c8350c3d479ce0db09fd8ee0c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_STATIC_LINKING_ONLY</b>&#160;&#160;&#160;/* <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> */</td></tr>
<tr class="separator:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec470b07ea51d527cd012ee2d1e545b6"><td class="memItemLeft" align="right" valign="top"><a id="aec470b07ea51d527cd012ee2d1e545b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_NEED_MALLOC</b></td></tr>
<tr class="separator:aec470b07ea51d527cd012ee2d1e545b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896eb602f69257e3dacb821c697b9f0"><td class="memItemLeft" align="right" valign="top"><a id="a6896eb602f69257e3dacb821c697b9f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CCOMMON_H_MODULE</b></td></tr>
<tr class="separator:a6896eb602f69257e3dacb821c697b9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6472517fab56dae58a1540747a3c584e"><td class="memItemLeft" align="right" valign="top"><a id="a6472517fab56dae58a1540747a3c584e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMMON_CPU_H</b></td></tr>
<tr class="separator:a6472517fab56dae58a1540747a3c584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7964be6e3a4fa10246caa18b5df4da34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>X</b>(name,  r,  bit)</td></tr>
<tr class="separator:a7964be6e3a4fa10246caa18b5df4da34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea6500801cc6f149d5ea05a269e08d"><td class="memItemLeft" align="right" valign="top"><a id="ab4ea6500801cc6f149d5ea05a269e08d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C</b>(name,  bit)&#160;&#160;&#160;X(name, f1c, bit)</td></tr>
<tr class="separator:ab4ea6500801cc6f149d5ea05a269e08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f7db79d90030b170014ca4939fd729"><td class="memItemLeft" align="right" valign="top"><a id="a88f7db79d90030b170014ca4939fd729"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>D</b>(name,  bit)&#160;&#160;&#160;X(name, f1d, bit)</td></tr>
<tr class="separator:a88f7db79d90030b170014ca4939fd729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf6fb3d5954b7c743b07616f47166cd"><td class="memItemLeft" align="right" valign="top"><a id="a6cf6fb3d5954b7c743b07616f47166cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>B</b>(name,  bit)&#160;&#160;&#160;X(name, f7b, bit)</td></tr>
<tr class="separator:a6cf6fb3d5954b7c743b07616f47166cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea6500801cc6f149d5ea05a269e08d"><td class="memItemLeft" align="right" valign="top"><a id="ab4ea6500801cc6f149d5ea05a269e08d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C</b>(name,  bit)&#160;&#160;&#160;X(name, f7c, bit)</td></tr>
<tr class="separator:ab4ea6500801cc6f149d5ea05a269e08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memItemLeft" align="right" valign="top"><a id="ad88034c8350c3d479ce0db09fd8ee0c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546f2633ae1036f49bdc5582971d7f1e"><td class="memItemLeft" align="right" valign="top"><a id="a546f2633ae1036f49bdc5582971d7f1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_STATIC_LINKING_ONLY</b>&#160;&#160;&#160;/* <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> */</td></tr>
<tr class="separator:a546f2633ae1036f49bdc5582971d7f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2ae50bf1aef3a919862a28e48b5678"><td class="memItemLeft" align="right" valign="top"><a id="acf2ae50bf1aef3a919862a28e48b5678"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_NO_XXH3</b></td></tr>
<tr class="separator:acf2ae50bf1aef3a919862a28e48b5678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34fe09d163d2f01100f42f1a9f22b90"><td class="memItemLeft" align="right" valign="top"><a id="ad34fe09d163d2f01100f42f1a9f22b90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_INLINE_ALL_31684351384</b></td></tr>
<tr class="separator:ad34fe09d163d2f01100f42f1a9f22b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546f2633ae1036f49bdc5582971d7f1e"><td class="memItemLeft" align="right" valign="top"><a id="a546f2633ae1036f49bdc5582971d7f1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a546f2633ae1036f49bdc5582971d7f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5832897ed49938aefa629a76034b36b1"><td class="memItemLeft" align="right" valign="top"><a id="a5832897ed49938aefa629a76034b36b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_PUBLIC_API</b>&#160;&#160;&#160;static</td></tr>
<tr class="separator:a5832897ed49938aefa629a76034b36b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde9dad44d3e0e432474bef93e12f9e7"><td class="memItemLeft" align="right" valign="top"><a id="acde9dad44d3e0e432474bef93e12f9e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_NAMESPACE</b>&#160;&#160;&#160;XXH_INLINE_</td></tr>
<tr class="separator:acde9dad44d3e0e432474bef93e12f9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38abe71b45636f49518f8765ce4d984d"><td class="memItemLeft" align="right" valign="top"><a id="a38abe71b45636f49518f8765ce4d984d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_IPREF</b>(Id)&#160;&#160;&#160;XXH_NAMESPACE ## Id</td></tr>
<tr class="separator:a38abe71b45636f49518f8765ce4d984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f450fa836d3af575c4691615c5215e"><td class="memItemLeft" align="right" valign="top"><a id="ad1f450fa836d3af575c4691615c5215e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_OK</b>&#160;&#160;&#160;XXH_IPREF(XXH_OK)</td></tr>
<tr class="separator:ad1f450fa836d3af575c4691615c5215e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0579a241bb33fc70a8fd32133d536c"><td class="memItemLeft" align="right" valign="top"><a id="a5d0579a241bb33fc70a8fd32133d536c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_ERROR</b>&#160;&#160;&#160;XXH_IPREF(XXH_ERROR)</td></tr>
<tr class="separator:a5d0579a241bb33fc70a8fd32133d536c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c77c68d1d045656715d23cd37a7a831"><td class="memItemLeft" align="right" valign="top"><a id="a0c77c68d1d045656715d23cd37a7a831"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_errorcode</b>&#160;&#160;&#160;XXH_IPREF(XXH_errorcode)</td></tr>
<tr class="separator:a0c77c68d1d045656715d23cd37a7a831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2cf2f0b01123524dd1ef8b0f5093ea"><td class="memItemLeft" align="right" valign="top"><a id="ade2cf2f0b01123524dd1ef8b0f5093ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_canonical_t</b>&#160;&#160;&#160;XXH_IPREF(<a class="el" href="structXXH32__canonical__t.html">XXH32_canonical_t</a>)</td></tr>
<tr class="separator:ade2cf2f0b01123524dd1ef8b0f5093ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13646410ba1ec381fadb855da435772"><td class="memItemLeft" align="right" valign="top"><a id="ac13646410ba1ec381fadb855da435772"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_canonical_t</b>&#160;&#160;&#160;XXH_IPREF(<a class="el" href="structXXH64__canonical__t.html">XXH64_canonical_t</a>)</td></tr>
<tr class="separator:ac13646410ba1ec381fadb855da435772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2396c835f294d00c4159e2f5c806a4a3"><td class="memItemLeft" align="right" valign="top"><a id="a2396c835f294d00c4159e2f5c806a4a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH128_canonical_t</b>&#160;&#160;&#160;XXH_IPREF(XXH128_canonical_t)</td></tr>
<tr class="separator:a2396c835f294d00c4159e2f5c806a4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82dbf07f0c83b71c74fb613b0d7cd72"><td class="memItemLeft" align="right" valign="top"><a id="aa82dbf07f0c83b71c74fb613b0d7cd72"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_state_s</b>&#160;&#160;&#160;XXH_IPREF(<a class="el" href="structXXH32__state__s.html">XXH32_state_s</a>)</td></tr>
<tr class="separator:aa82dbf07f0c83b71c74fb613b0d7cd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c18948935999c41f3f3cb74db83e51e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#ga0c18948935999c41f3f3cb74db83e51e">XXH32_state_t</a>&#160;&#160;&#160;XXH_IPREF(<a class="el" href="structXXH32__state__s.html">XXH32_state_t</a>)</td></tr>
<tr class="memdesc:ga0c18948935999c41f3f3cb74db83e51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opaque state struct for the XXH32 streaming API.  <a href="group__XXH32__family.html#ga0c18948935999c41f3f3cb74db83e51e">More...</a><br /></td></tr>
<tr class="separator:ga0c18948935999c41f3f3cb74db83e51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acc86cbff2586223c63c90cec3e9581"><td class="memItemLeft" align="right" valign="top"><a id="a5acc86cbff2586223c63c90cec3e9581"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_state_s</b>&#160;&#160;&#160;XXH_IPREF(<a class="el" href="structXXH64__state__s.html">XXH64_state_s</a>)</td></tr>
<tr class="separator:a5acc86cbff2586223c63c90cec3e9581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade29c86172fdaf6f70e43b963f4b248f"><td class="memItemLeft" align="right" valign="top"><a id="ade29c86172fdaf6f70e43b963f4b248f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_state_t</b>&#160;&#160;&#160;XXH_IPREF(<a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a>)</td></tr>
<tr class="separator:ade29c86172fdaf6f70e43b963f4b248f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0621579b9d7eeff2e7f63d9f3d16e23"><td class="memItemLeft" align="right" valign="top"><a id="ad0621579b9d7eeff2e7f63d9f3d16e23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_state_s</b>&#160;&#160;&#160;XXH_IPREF(XXH3_state_s)</td></tr>
<tr class="separator:ad0621579b9d7eeff2e7f63d9f3d16e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a44e2662524d0e04aa0671fd540adfb"><td class="memItemLeft" align="right" valign="top"><a id="a6a44e2662524d0e04aa0671fd540adfb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_state_t</b>&#160;&#160;&#160;XXH_IPREF(XXH3_state_t)</td></tr>
<tr class="separator:a6a44e2662524d0e04aa0671fd540adfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7107f0330e53b69f6c412af6ce32f7a7"><td class="memItemLeft" align="right" valign="top"><a id="a7107f0330e53b69f6c412af6ce32f7a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH128_hash_t</b>&#160;&#160;&#160;XXH_IPREF(XXH128_hash_t)</td></tr>
<tr class="separator:a7107f0330e53b69f6c412af6ce32f7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233a9a49fa654f51214c38fb3874d35b"><td class="memItemLeft" align="right" valign="top"><a id="a233a9a49fa654f51214c38fb3874d35b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXHASH_H_5627135585666179</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a233a9a49fa654f51214c38fb3874d35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0349c2d8893878f5ff327129e9612d3b"><td class="memItemLeft" align="right" valign="top"><a id="a0349c2d8893878f5ff327129e9612d3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_CAT</b>(A,  B)&#160;&#160;&#160;A##B</td></tr>
<tr class="separator:a0349c2d8893878f5ff327129e9612d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f162d60f438196576459af6135a3c1e"><td class="memItemLeft" align="right" valign="top"><a id="a9f162d60f438196576459af6135a3c1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_NAME2</b>(A,  B)&#160;&#160;&#160;XXH_CAT(A,B)</td></tr>
<tr class="separator:a9f162d60f438196576459af6135a3c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf1349b5b3ea4fe93b6dc920fc9d93a"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_versionNumber</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH_versionNumber)</td></tr>
<tr class="separator:ga4bf1349b5b3ea4fe93b6dc920fc9d93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a5c5935882c5d86768b34e2afaf3e"><td class="memItemLeft" align="right" valign="top"><a id="aa68a5c5935882c5d86768b34e2afaf3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32)</td></tr>
<tr class="separator:aa68a5c5935882c5d86768b34e2afaf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51931b4d4f02a6d818aaa6a258e8c076"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#ga51931b4d4f02a6d818aaa6a258e8c076">XXH32_createState</a>(void)&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32_createState)</td></tr>
<tr class="memdesc:ga51931b4d4f02a6d818aaa6a258e8c076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an <a class="el" href="group__XXH32__family.html#ga0c18948935999c41f3f3cb74db83e51e">XXH32_state_t</a>.  <a href="group__XXH32__family.html#ga51931b4d4f02a6d818aaa6a258e8c076">More...</a><br /></td></tr>
<tr class="separator:ga51931b4d4f02a6d818aaa6a258e8c076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9a390679d913b9ad67261183d979e7"><td class="memItemLeft" align="right" valign="top"><a id="a8c9a390679d913b9ad67261183d979e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_freeState</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32_freeState)</td></tr>
<tr class="separator:a8c9a390679d913b9ad67261183d979e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ad80e6b118fbc7ed58afb784736ec3"><td class="memItemLeft" align="right" valign="top"><a id="a26ad80e6b118fbc7ed58afb784736ec3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_reset</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32_reset)</td></tr>
<tr class="separator:a26ad80e6b118fbc7ed58afb784736ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ff122f37c87e55c1f5d46acbc45fea"><td class="memItemLeft" align="right" valign="top"><a id="a08ff122f37c87e55c1f5d46acbc45fea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_update</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32_update)</td></tr>
<tr class="separator:a08ff122f37c87e55c1f5d46acbc45fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab642329481c58e318cf86c813d1cfa4a"><td class="memItemLeft" align="right" valign="top"><a id="ab642329481c58e318cf86c813d1cfa4a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_digest</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32_digest)</td></tr>
<tr class="separator:ab642329481c58e318cf86c813d1cfa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bc9b73d031dd0905db52cce2f3681b"><td class="memItemLeft" align="right" valign="top"><a id="a64bc9b73d031dd0905db52cce2f3681b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_copyState</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32_copyState)</td></tr>
<tr class="separator:a64bc9b73d031dd0905db52cce2f3681b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fff35646b2fa339a923eae10c3bec9"><td class="memItemLeft" align="right" valign="top"><a id="ab0fff35646b2fa339a923eae10c3bec9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_canonicalFromHash</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32_canonicalFromHash)</td></tr>
<tr class="separator:ab0fff35646b2fa339a923eae10c3bec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dddab5eaf34226202ea43e6b1456a33"><td class="memItemLeft" align="right" valign="top"><a id="a5dddab5eaf34226202ea43e6b1456a33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_hashFromCanonical</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH32_hashFromCanonical)</td></tr>
<tr class="separator:a5dddab5eaf34226202ea43e6b1456a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bbda7ffeccf4d25bc1b073de856957"><td class="memItemLeft" align="right" valign="top"><a id="ae5bbda7ffeccf4d25bc1b073de856957"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64)</td></tr>
<tr class="separator:ae5bbda7ffeccf4d25bc1b073de856957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79efe920b4f18004110a6e9bcc0385e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#ga79efe920b4f18004110a6e9bcc0385e0">XXH64_createState</a>(void)&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64_createState)</td></tr>
<tr class="memdesc:ga79efe920b4f18004110a6e9bcc0385e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a>.  <a href="group__XXH64__family.html#ga79efe920b4f18004110a6e9bcc0385e0">More...</a><br /></td></tr>
<tr class="separator:ga79efe920b4f18004110a6e9bcc0385e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3587a546e3425f24dc5a6fbb5fcee5"><td class="memItemLeft" align="right" valign="top"><a id="a1d3587a546e3425f24dc5a6fbb5fcee5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_freeState</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64_freeState)</td></tr>
<tr class="separator:a1d3587a546e3425f24dc5a6fbb5fcee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cf22aa6a887f5feb3d281d162b6e7f"><td class="memItemLeft" align="right" valign="top"><a id="aa6cf22aa6a887f5feb3d281d162b6e7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_reset</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64_reset)</td></tr>
<tr class="separator:aa6cf22aa6a887f5feb3d281d162b6e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21146350283cfa9c335218d5e4036a8"><td class="memItemLeft" align="right" valign="top"><a id="ad21146350283cfa9c335218d5e4036a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_update</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64_update)</td></tr>
<tr class="separator:ad21146350283cfa9c335218d5e4036a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa65b31716942379fd4e168d8e2efb4"><td class="memItemLeft" align="right" valign="top"><a id="a3fa65b31716942379fd4e168d8e2efb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_digest</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64_digest)</td></tr>
<tr class="separator:a3fa65b31716942379fd4e168d8e2efb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5301d981f5752fe663adf2d1ce115ff0"><td class="memItemLeft" align="right" valign="top"><a id="a5301d981f5752fe663adf2d1ce115ff0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_copyState</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64_copyState)</td></tr>
<tr class="separator:a5301d981f5752fe663adf2d1ce115ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde4f203198b02c1c1d0cb03779ce9d6"><td class="memItemLeft" align="right" valign="top"><a id="acde4f203198b02c1c1d0cb03779ce9d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_canonicalFromHash</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64_canonicalFromHash)</td></tr>
<tr class="separator:acde4f203198b02c1c1d0cb03779ce9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4fcda72ca92b04a48e08bdacc179eb"><td class="memItemLeft" align="right" valign="top"><a id="a1a4fcda72ca92b04a48e08bdacc179eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_hashFromCanonical</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH64_hashFromCanonical)</td></tr>
<tr class="separator:a1a4fcda72ca92b04a48e08bdacc179eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8a8a2f1875f7d46d9acbc7658d40f2"><td class="memItemLeft" align="right" valign="top"><a id="a3d8a8a2f1875f7d46d9acbc7658d40f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits)</td></tr>
<tr class="separator:a3d8a8a2f1875f7d46d9acbc7658d40f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333c8054af1ed5132f678c68e9638ea6"><td class="memItemLeft" align="right" valign="top"><a id="a333c8054af1ed5132f678c68e9638ea6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_withSecret</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecret)</td></tr>
<tr class="separator:a333c8054af1ed5132f678c68e9638ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ead856e9ad4bb032dc16fee90364a78"><td class="memItemLeft" align="right" valign="top"><a id="a3ead856e9ad4bb032dc16fee90364a78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_withSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSeed)</td></tr>
<tr class="separator:a3ead856e9ad4bb032dc16fee90364a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967e1a8e4177471cec11bfe4514a346"><td class="memItemLeft" align="right" valign="top"><a id="a1967e1a8e4177471cec11bfe4514a346"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_withSecretandSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecretandSeed)</td></tr>
<tr class="separator:a1967e1a8e4177471cec11bfe4514a346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879676bd1697bdcc1664e378706445df"><td class="memItemLeft" align="right" valign="top"><a id="a879676bd1697bdcc1664e378706445df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_createState</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_createState)</td></tr>
<tr class="separator:a879676bd1697bdcc1664e378706445df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad305a2314c4c5a8ea2411a0729628b73"><td class="memItemLeft" align="right" valign="top"><a id="ad305a2314c4c5a8ea2411a0729628b73"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_freeState</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_freeState)</td></tr>
<tr class="separator:ad305a2314c4c5a8ea2411a0729628b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4762084ff22c7b5888c0bd081a1ca27c"><td class="memItemLeft" align="right" valign="top"><a id="a4762084ff22c7b5888c0bd081a1ca27c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_copyState</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_copyState)</td></tr>
<tr class="separator:a4762084ff22c7b5888c0bd081a1ca27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c0282a031d6560cc5b75ea11a71c22"><td class="memItemLeft" align="right" valign="top"><a id="ae8c0282a031d6560cc5b75ea11a71c22"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_reset</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset)</td></tr>
<tr class="separator:ae8c0282a031d6560cc5b75ea11a71c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577c5e3543c8d071e704621744235a7c"><td class="memItemLeft" align="right" valign="top"><a id="a577c5e3543c8d071e704621744235a7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_reset_withSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSeed)</td></tr>
<tr class="separator:a577c5e3543c8d071e704621744235a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172de15dbf2e75322aa08b117ed01f85"><td class="memItemLeft" align="right" valign="top"><a id="a172de15dbf2e75322aa08b117ed01f85"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_reset_withSecret</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecret)</td></tr>
<tr class="separator:a172de15dbf2e75322aa08b117ed01f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60756be51f0af24319c04e18eca4d617"><td class="memItemLeft" align="right" valign="top"><a id="a60756be51f0af24319c04e18eca4d617"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_reset_withSecretandSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecretandSeed)</td></tr>
<tr class="separator:a60756be51f0af24319c04e18eca4d617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4106732199bf5cd678de9750bf40d0b3"><td class="memItemLeft" align="right" valign="top"><a id="a4106732199bf5cd678de9750bf40d0b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_update</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_update)</td></tr>
<tr class="separator:a4106732199bf5cd678de9750bf40d0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d6cbef16ef200d47bf1ee58be3dae5"><td class="memItemLeft" align="right" valign="top"><a id="a68d6cbef16ef200d47bf1ee58be3dae5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_64bits_digest</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)</td></tr>
<tr class="separator:a68d6cbef16ef200d47bf1ee58be3dae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b82e308d7d0a514d4c074d00ce3abb"><td class="memItemLeft" align="right" valign="top"><a id="a34b82e308d7d0a514d4c074d00ce3abb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_generateSecret</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret)</td></tr>
<tr class="separator:a34b82e308d7d0a514d4c074d00ce3abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30839ee12dd217d97736cfe18cae1de"><td class="memItemLeft" align="right" valign="top"><a id="aa30839ee12dd217d97736cfe18cae1de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_generateSecret_fromSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret_fromSeed)</td></tr>
<tr class="separator:aa30839ee12dd217d97736cfe18cae1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e52aaf890d8103bb1bb691e5a7c2e40"><td class="memItemLeft" align="right" valign="top"><a id="a9e52aaf890d8103bb1bb691e5a7c2e40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH128</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH128)</td></tr>
<tr class="separator:a9e52aaf890d8103bb1bb691e5a7c2e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd9fdebde0f76eda9bda4fdb4b52090"><td class="memItemLeft" align="right" valign="top"><a id="a7bd9fdebde0f76eda9bda4fdb4b52090"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits)</td></tr>
<tr class="separator:a7bd9fdebde0f76eda9bda4fdb4b52090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae480a314b11d9e8f082edda956c562b4"><td class="memItemLeft" align="right" valign="top"><a id="ae480a314b11d9e8f082edda956c562b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_withSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSeed)</td></tr>
<tr class="separator:ae480a314b11d9e8f082edda956c562b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b31b326e55a065d3c763194b3f59eb6"><td class="memItemLeft" align="right" valign="top"><a id="a9b31b326e55a065d3c763194b3f59eb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_withSecret</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecret)</td></tr>
<tr class="separator:a9b31b326e55a065d3c763194b3f59eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d416650a5db5b828f05c734a71ce4f"><td class="memItemLeft" align="right" valign="top"><a id="a79d416650a5db5b828f05c734a71ce4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_withSecretandSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecretandSeed)</td></tr>
<tr class="separator:a79d416650a5db5b828f05c734a71ce4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c2eaebb93b61276d33444fd3ffe863"><td class="memItemLeft" align="right" valign="top"><a id="a13c2eaebb93b61276d33444fd3ffe863"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_reset</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset)</td></tr>
<tr class="separator:a13c2eaebb93b61276d33444fd3ffe863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac5c04a9959a2958bf9a9e2551e6bda"><td class="memItemLeft" align="right" valign="top"><a id="a5ac5c04a9959a2958bf9a9e2551e6bda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_reset_withSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSeed)</td></tr>
<tr class="separator:a5ac5c04a9959a2958bf9a9e2551e6bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b95dd9fe3dbb087d4bdcfd5ef55282"><td class="memItemLeft" align="right" valign="top"><a id="af1b95dd9fe3dbb087d4bdcfd5ef55282"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_reset_withSecret</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecret)</td></tr>
<tr class="separator:af1b95dd9fe3dbb087d4bdcfd5ef55282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3279f200e7abc59992ff93cf2f936389"><td class="memItemLeft" align="right" valign="top"><a id="a3279f200e7abc59992ff93cf2f936389"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_reset_withSecretandSeed</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecretandSeed)</td></tr>
<tr class="separator:a3279f200e7abc59992ff93cf2f936389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42828eaeb38603c4d8ac63cb03f0c3f2"><td class="memItemLeft" align="right" valign="top"><a id="a42828eaeb38603c4d8ac63cb03f0c3f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_update</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_update)</td></tr>
<tr class="separator:a42828eaeb38603c4d8ac63cb03f0c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76633c43a4237f3526a80edd6e3b792"><td class="memItemLeft" align="right" valign="top"><a id="ad76633c43a4237f3526a80edd6e3b792"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_128bits_digest</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_digest)</td></tr>
<tr class="separator:ad76633c43a4237f3526a80edd6e3b792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3135381e6a483069d51a6f0dbc8b0159"><td class="memItemLeft" align="right" valign="top"><a id="a3135381e6a483069d51a6f0dbc8b0159"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH128_isEqual</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH128_isEqual)</td></tr>
<tr class="separator:a3135381e6a483069d51a6f0dbc8b0159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac41fa26c34cc9839bc60d466cae6ac"><td class="memItemLeft" align="right" valign="top"><a id="acac41fa26c34cc9839bc60d466cae6ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH128_cmp</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH128_cmp)</td></tr>
<tr class="separator:acac41fa26c34cc9839bc60d466cae6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f65e4032bd38658a8b9fcbb6c41092f"><td class="memItemLeft" align="right" valign="top"><a id="a2f65e4032bd38658a8b9fcbb6c41092f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH128_canonicalFromHash</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH128_canonicalFromHash)</td></tr>
<tr class="separator:a2f65e4032bd38658a8b9fcbb6c41092f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbdc69ae0a6c6a0e43dc1c28bed1af5"><td class="memItemLeft" align="right" valign="top"><a id="adfbdc69ae0a6c6a0e43dc1c28bed1af5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH128_hashFromCanonical</b>&#160;&#160;&#160;XXH_NAME2(XXH_NAMESPACE, XXH128_hashFromCanonical)</td></tr>
<tr class="separator:adfbdc69ae0a6c6a0e43dc1c28bed1af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7e321a2d619584344314285b0789e0"><td class="memItemLeft" align="right" valign="top"><a id="adb7e321a2d619584344314285b0789e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_CONSTF</b>&#160;&#160;&#160;/* disable */</td></tr>
<tr class="separator:adb7e321a2d619584344314285b0789e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b5b015d58d9778c3e37de38f174fe2"><td class="memItemLeft" align="right" valign="top"><a id="a42b5b015d58d9778c3e37de38f174fe2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_PUREF</b></td></tr>
<tr class="separator:a42b5b015d58d9778c3e37de38f174fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29ba2352de774253d35eef1cb9728ab"><td class="memItemLeft" align="right" valign="top"><a id="aa29ba2352de774253d35eef1cb9728ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_MALLOCF</b></td></tr>
<tr class="separator:aa29ba2352de774253d35eef1cb9728ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2b7aee9a2ac8bfad126165c4369fab"><td class="memItemLeft" align="right" valign="top"><a id="a8a2b7aee9a2ac8bfad126165c4369fab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_VERSION_MAJOR</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a8a2b7aee9a2ac8bfad126165c4369fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0087600ba3cbfdbb78b83e13d54a1849"><td class="memItemLeft" align="right" valign="top"><a id="a0087600ba3cbfdbb78b83e13d54a1849"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_VERSION_MINOR</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a0087600ba3cbfdbb78b83e13d54a1849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fe7f51710d15efa3aeeefbb446f434"><td class="memItemLeft" align="right" valign="top"><a id="a67fe7f51710d15efa3aeeefbb446f434"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_VERSION_RELEASE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a67fe7f51710d15efa3aeeefbb446f434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc66393fff091acefc0e2a00ec5462c4"><td class="memItemLeft" align="right" valign="top"><a id="acc66393fff091acefc0e2a00ec5462c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_VERSION_NUMBER</b>&#160;&#160;&#160;(XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)</td></tr>
<tr class="separator:acc66393fff091acefc0e2a00ec5462c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e93f70f759122768f60f336472f189"><td class="memItemLeft" align="right" valign="top"><a id="ad9e93f70f759122768f60f336472f189"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXHASH_H_STATIC_13879238742</b></td></tr>
<tr class="separator:ad9e93f70f759122768f60f336472f189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40be3a031b9a5bd9afc800b0959a0c9"><td class="memItemLeft" align="right" valign="top"><a id="aa40be3a031b9a5bd9afc800b0959a0c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_IMPLEMENTATION</b></td></tr>
<tr class="separator:aa40be3a031b9a5bd9afc800b0959a0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9a78c0903be58e10bc972e5aefd21e"><td class="memItemLeft" align="right" valign="top"><a id="a4b9a78c0903be58e10bc972e5aefd21e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_IMPLEM_13a8737387</b></td></tr>
<tr class="separator:a4b9a78c0903be58e10bc972e5aefd21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9850064fc149181cce7431f40a990a"><td class="memItemLeft" align="right" valign="top"><a id="a1e9850064fc149181cce7431f40a990a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_SIZE_OPT</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a1e9850064fc149181cce7431f40a990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee35763869a969d5576e70dac1c08b8d"><td class="memItemLeft" align="right" valign="top"><a id="aee35763869a969d5576e70dac1c08b8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_FORCE_ALIGN_CHECK</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aee35763869a969d5576e70dac1c08b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae980c41901d840d8909aa74d603ad4f1"><td class="memItemLeft" align="right" valign="top"><a id="ae980c41901d840d8909aa74d603ad4f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_NO_INLINE_HINTS</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ae980c41901d840d8909aa74d603ad4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d5f6ddf0a7d14b90a63cb6a9d34c26"><td class="memItemLeft" align="right" valign="top"><a id="aa6d5f6ddf0a7d14b90a63cb6a9d34c26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_INLINE_SECRET</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa6d5f6ddf0a7d14b90a63cb6a9d34c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5824529c4ad74d2d5cc05bf4868613a"><td class="memItemLeft" align="right" valign="top"><a id="ad5824529c4ad74d2d5cc05bf4868613a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_ENDJMP</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ad5824529c4ad74d2d5cc05bf4868613a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a8bb8696c17683cef1664f8da952f71"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_FORCE_INLINE</b>&#160;&#160;&#160;static</td></tr>
<tr class="separator:ga0a8bb8696c17683cef1664f8da952f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e774da04374ac3c5822e4da03e2b01"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_NO_INLINE</b>&#160;&#160;&#160;static</td></tr>
<tr class="separator:gae4e774da04374ac3c5822e4da03e2b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d35fde640dac7fa87754ba31a115399"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH3_WITH_SECRET_INLINE</b>&#160;&#160;&#160;XXH_FORCE_INLINE</td></tr>
<tr class="separator:ga0d35fde640dac7fa87754ba31a115399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574ceb8ab088243cb0dc833b28320eb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga574ceb8ab088243cb0dc833b28320eb5">XXH_DEBUGLEVEL</a>&#160;&#160;&#160;DEBUGLEVEL</td></tr>
<tr class="memdesc:ga574ceb8ab088243cb0dc833b28320eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debugging level.  <a href="group__tuning.html#ga574ceb8ab088243cb0dc833b28320eb5">More...</a><br /></td></tr>
<tr class="separator:ga574ceb8ab088243cb0dc833b28320eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a20151ce2dee0b963dd81f3f5bf42b"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_ASSERT</b>(c)&#160;&#160;&#160;XXH_ASSUME(c)</td></tr>
<tr class="separator:gad5a20151ce2dee0b963dd81f3f5bf42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ef6efddd1a03df01bd94642409a27d"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_STATIC_ASSERT_WITH_MESSAGE</b>(c,  m)&#160;&#160;&#160;do { struct xxh_sa { char x[(c) ? 1 : -1]; }; } while(0)</td></tr>
<tr class="separator:ga76ef6efddd1a03df01bd94642409a27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc33577f47cf99f8b35a52d87c642c4"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_STATIC_ASSERT</b>(c)&#160;&#160;&#160;XXH_STATIC_ASSERT_WITH_MESSAGE((c),#c)</td></tr>
<tr class="separator:ga3bc33577f47cf99f8b35a52d87c642c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6925393fb5122b81f1be774e5925658"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_COMPILER_GUARD</b>(var)&#160;&#160;&#160;((void)0)</td></tr>
<tr class="separator:gae6925393fb5122b81f1be774e5925658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87e473cf48d93cec7aa88dff1651e15"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_COMPILER_GUARD_CLANG_NEON</b>(var)&#160;&#160;&#160;((void)0)</td></tr>
<tr class="separator:gaf87e473cf48d93cec7aa88dff1651e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408fac02658eb4a81f7a1877f1ca3b3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tuning.html#ga408fac02658eb4a81f7a1877f1ca3b3f">XXH_CPU_LITTLE_ENDIAN</a>&#160;&#160;&#160;XXH_isLittleEndian()</td></tr>
<tr class="memdesc:ga408fac02658eb4a81f7a1877f1ca3b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the target is little endian.  <a href="group__tuning.html#ga408fac02658eb4a81f7a1877f1ca3b3f">More...</a><br /></td></tr>
<tr class="separator:ga408fac02658eb4a81f7a1877f1ca3b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65078327d35a1656a9850f490c95cb69"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_GCC_VERSION</b>&#160;&#160;&#160;(__GNUC__ * 100 + __GNUC_MINOR__)</td></tr>
<tr class="separator:ga65078327d35a1656a9850f490c95cb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82cd67d6de6f76518d2ecf9f64baa53f"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_HAS_BUILTIN</b>(x)&#160;&#160;&#160;__has_builtin(x)</td></tr>
<tr class="separator:ga82cd67d6de6f76518d2ecf9f64baa53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da95b9cd6b3cbe83149ec2602a2cbbe"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_UNREACHABLE</b>()</td></tr>
<tr class="separator:ga0da95b9cd6b3cbe83149ec2602a2cbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19febf6e29ba22bbdb86f5fe7d84d450"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_ASSUME</b>(c)&#160;&#160;&#160;if (!(c)) { XXH_UNREACHABLE(); }</td></tr>
<tr class="separator:ga19febf6e29ba22bbdb86f5fe7d84d450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a4b202f9523a2a811da16cde3f52eb"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_rotl32</b>(x,  r)&#160;&#160;&#160;(((x) &lt;&lt; (r)) | ((x) &gt;&gt; (32 - (r))))</td></tr>
<tr class="separator:ga70a4b202f9523a2a811da16cde3f52eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056473e50ab5e7acb43d00ca3d41632e"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_rotl64</b>(x,  r)&#160;&#160;&#160;(((x) &lt;&lt; (r)) | ((x) &gt;&gt; (64 - (r))))</td></tr>
<tr class="separator:ga056473e50ab5e7acb43d00ca3d41632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29fede2b86ee758448c55edf6171e11f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__impl.html#ga29fede2b86ee758448c55edf6171e11f">XXH_PRIME32_1</a>&#160;&#160;&#160;0x9E3779B1U</td></tr>
<tr class="separator:ga29fede2b86ee758448c55edf6171e11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d49e684c0551afaed8e4ff40940c79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__impl.html#ga23d49e684c0551afaed8e4ff40940c79">XXH_PRIME32_2</a>&#160;&#160;&#160;0x85EBCA77U</td></tr>
<tr class="separator:ga23d49e684c0551afaed8e4ff40940c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdda6ef95561d39cf2f9b7f2cd5c6693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__impl.html#gacdda6ef95561d39cf2f9b7f2cd5c6693">XXH_PRIME32_3</a>&#160;&#160;&#160;0xC2B2AE3DU</td></tr>
<tr class="separator:gacdda6ef95561d39cf2f9b7f2cd5c6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f43a7ed63cb15dfc49b1a42c250e511"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__impl.html#ga9f43a7ed63cb15dfc49b1a42c250e511">XXH_PRIME32_4</a>&#160;&#160;&#160;0x27D4EB2FU</td></tr>
<tr class="separator:ga9f43a7ed63cb15dfc49b1a42c250e511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ab6ba3eb0659356b8ed3b84c43e3e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__impl.html#gaa4ab6ba3eb0659356b8ed3b84c43e3e7">XXH_PRIME32_5</a>&#160;&#160;&#160;0x165667B1U</td></tr>
<tr class="separator:gaa4ab6ba3eb0659356b8ed3b84c43e3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada11171377462c53a42c6f5bf450de7b"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_get32bits</b>(p)&#160;&#160;&#160;XXH_readLE32_align(p, align)</td></tr>
<tr class="separator:gada11171377462c53a42c6f5bf450de7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d23c2d8237f77c0dead731a4dd9fed1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_PROCESS1</b></td></tr>
<tr class="separator:a0d23c2d8237f77c0dead731a4dd9fed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808ba6cd0cfc0911f8748996fd6d2bf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_PROCESS4</b></td></tr>
<tr class="separator:a808ba6cd0cfc0911f8748996fd6d2bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20651a9ad53cae6f0a4feb1393d5a716"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__impl.html#ga20651a9ad53cae6f0a4feb1393d5a716">XXH_PRIME64_1</a>&#160;&#160;&#160;0x9E3779B185EBCA87ULL</td></tr>
<tr class="separator:ga20651a9ad53cae6f0a4feb1393d5a716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a01ca165b68cef76da009a54e3ba54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__impl.html#ga33a01ca165b68cef76da009a54e3ba54">XXH_PRIME64_2</a>&#160;&#160;&#160;0xC2B2AE3D27D4EB4FULL</td></tr>
<tr class="separator:ga33a01ca165b68cef76da009a54e3ba54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18b925ab3b4ad25ae26eb4fb00ebcb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__impl.html#gad18b925ab3b4ad25ae26eb4fb00ebcb8">XXH_PRIME64_3</a>&#160;&#160;&#160;0x165667B19E3779F9ULL</td></tr>
<tr class="separator:gad18b925ab3b4ad25ae26eb4fb00ebcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6326d9c3883242a3b5602fae1507afc5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__impl.html#ga6326d9c3883242a3b5602fae1507afc5">XXH_PRIME64_4</a>&#160;&#160;&#160;0x85EBCA77C2B2AE63ULL</td></tr>
<tr class="separator:ga6326d9c3883242a3b5602fae1507afc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44b2a496b0a4184699e7d11ec2d70c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__impl.html#gae44b2a496b0a4184699e7d11ec2d70c6">XXH_PRIME64_5</a>&#160;&#160;&#160;0x27D4EB2F165667C5ULL</td></tr>
<tr class="separator:gae44b2a496b0a4184699e7d11ec2d70c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c5037e820ac15ae30f36c553d5b95e"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_get64bits</b>(p)&#160;&#160;&#160;XXH_readLE64_align(p, align)</td></tr>
<tr class="separator:gac5c5037e820ac15ae30f36c553d5b95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b0edeca5df0970ff6b049e60fe4bc9"><td class="memItemLeft" align="right" valign="top"><a id="a41b0edeca5df0970ff6b049e60fe4bc9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_TRACE_H</b></td></tr>
<tr class="separator:a41b0edeca5df0970ff6b049e60fe4bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23eb106a9a4af9f548437b777d595a44"><td class="memItemLeft" align="right" valign="top"><a id="a23eb106a9a4af9f548437b777d595a44"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HAVE_WEAK_SYMBOLS</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a23eb106a9a4af9f548437b777d595a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190fb944d1a2d9e5ffdf7294035f313d"><td class="memItemLeft" align="right" valign="top"><a id="a190fb944d1a2d9e5ffdf7294035f313d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WEAK_ATTR</b></td></tr>
<tr class="separator:a190fb944d1a2d9e5ffdf7294035f313d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3f1363cae8dbe0254134253984490c"><td class="memItemLeft" align="right" valign="top"><a id="adb3f1363cae8dbe0254134253984490c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_STATIC_ASSERT</b>(c)&#160;&#160;&#160;DEBUG_STATIC_ASSERT(c)</td></tr>
<tr class="separator:adb3f1363cae8dbe0254134253984490c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665e5ea865f07b1c036fb5e84fdd6b1e"><td class="memItemLeft" align="right" valign="top"><a id="a665e5ea865f07b1c036fb5e84fdd6b1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_isError</b>&#160;&#160;&#160;ERR_isError   /* for inlining */</td></tr>
<tr class="separator:a665e5ea865f07b1c036fb5e84fdd6b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab2ee8300d3fe2724cf97953dac66d0"><td class="memItemLeft" align="right" valign="top"><a id="a7ab2ee8300d3fe2724cf97953dac66d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_isError</b>&#160;&#160;&#160;ERR_isError</td></tr>
<tr class="separator:a7ab2ee8300d3fe2724cf97953dac66d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2de9e4837283ff6a5d5f4e2f43c6fed"><td class="memItemLeft" align="right" valign="top"><a id="ad2de9e4837283ff6a5d5f4e2f43c6fed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_isError</b>&#160;&#160;&#160;ERR_isError</td></tr>
<tr class="separator:ad2de9e4837283ff6a5d5f4e2f43c6fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acffbd305ee72dcd4593c0d8af64a4f"><td class="memItemLeft" align="right" valign="top"><a id="a3acffbd305ee72dcd4593c0d8af64a4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN</b>(a,  b)&#160;&#160;&#160;((a)&lt;(b) ? (a) : (b))</td></tr>
<tr class="separator:a3acffbd305ee72dcd4593c0d8af64a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memItemLeft" align="right" valign="top"><a id="afa99ec4acc4ecb2dc3c2d05da15d0e3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX</b>(a,  b)&#160;&#160;&#160;((a)&gt;(b) ? (a) : (b))</td></tr>
<tr class="separator:afa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58593e402a718fa727cfbbb85d07ff6"><td class="memItemLeft" align="right" valign="top"><a id="ac58593e402a718fa727cfbbb85d07ff6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOUNDED</b>(min,  val,  max)&#160;&#160;&#160;(MAX(min,MIN(val,max)))</td></tr>
<tr class="separator:ac58593e402a718fa727cfbbb85d07ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154df9c68162f6b05e66068f181bf1d7"><td class="memItemLeft" align="right" valign="top"><a id="a154df9c68162f6b05e66068f181bf1d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_OPT_NUM</b>&#160;&#160;&#160;(1&lt;&lt;12)</td></tr>
<tr class="separator:a154df9c68162f6b05e66068f181bf1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea22fafe4da68c23971fc7cb20f42d47"><td class="memItemLeft" align="right" valign="top"><a id="aea22fafe4da68c23971fc7cb20f42d47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_REP_NUM</b>&#160;&#160;&#160;3                 /* number of repcodes */</td></tr>
<tr class="separator:aea22fafe4da68c23971fc7cb20f42d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1841fd1a462d245d8c73dce55e2f45da"><td class="memItemLeft" align="right" valign="top"><a id="a1841fd1a462d245d8c73dce55e2f45da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KB</b>&#160;&#160;&#160;*(1 &lt;&lt;10)</td></tr>
<tr class="separator:a1841fd1a462d245d8c73dce55e2f45da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b38d492364d98453284934ed7caee9"><td class="memItemLeft" align="right" valign="top"><a id="aa6b38d492364d98453284934ed7caee9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MB</b>&#160;&#160;&#160;*(1 &lt;&lt;20)</td></tr>
<tr class="separator:aa6b38d492364d98453284934ed7caee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44172ac633c517cb4c9e278cef36b000"><td class="memItemLeft" align="right" valign="top"><a id="a44172ac633c517cb4c9e278cef36b000"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GB</b>&#160;&#160;&#160;*(1U&lt;&lt;30)</td></tr>
<tr class="separator:a44172ac633c517cb4c9e278cef36b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b8f3261ae9e2e1043380c192f7b5f0"><td class="memItemLeft" align="right" valign="top"><a id="aa6b8f3261ae9e2e1043380c192f7b5f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT7</b>&#160;&#160;&#160;128</td></tr>
<tr class="separator:aa6b8f3261ae9e2e1043380c192f7b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2d074401e2b6322ee8f03476c24677"><td class="memItemLeft" align="right" valign="top"><a id="acc2d074401e2b6322ee8f03476c24677"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT6</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:acc2d074401e2b6322ee8f03476c24677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae692bc3df48028ceb1ddc2534a993bb8"><td class="memItemLeft" align="right" valign="top"><a id="ae692bc3df48028ceb1ddc2534a993bb8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT5</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ae692bc3df48028ceb1ddc2534a993bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa731e0b6cf75f4e637ee88959315f5e4"><td class="memItemLeft" align="right" valign="top"><a id="aa731e0b6cf75f4e637ee88959315f5e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT4</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:aa731e0b6cf75f4e637ee88959315f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601923eba46784638244c1ebf2622a2a"><td class="memItemLeft" align="right" valign="top"><a id="a601923eba46784638244c1ebf2622a2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT1</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a601923eba46784638244c1ebf2622a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d43f8748b542bce39e18790f845ecc"><td class="memItemLeft" align="right" valign="top"><a id="ad4d43f8748b542bce39e18790f845ecc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT0</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ad4d43f8748b542bce39e18790f845ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504d416546fe6dfed90633018055f69d"><td class="memItemLeft" align="right" valign="top"><a id="a504d416546fe6dfed90633018055f69d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WINDOWLOG_ABSOLUTEMIN</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a504d416546fe6dfed90633018055f69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848b8bb509d81cc5dae17b3f0f695be7"><td class="memItemLeft" align="right" valign="top"><a id="a848b8bb509d81cc5dae17b3f0f695be7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FRAMEIDSIZE</b>&#160;&#160;&#160;4   /* magic number size */</td></tr>
<tr class="separator:a848b8bb509d81cc5dae17b3f0f695be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456a4a9b8a37496e42ad1f91bd4e4b91"><td class="memItemLeft" align="right" valign="top"><a id="a456a4a9b8a37496e42ad1f91bd4e4b91"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BLOCKHEADERSIZE</b>&#160;&#160;&#160;3   /* C standard doesn't allow `static const` variable to be init using another `static const` variable */</td></tr>
<tr class="separator:a456a4a9b8a37496e42ad1f91bd4e4b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af3c6a0663807cd44a519fbe25e9630"><td class="memItemLeft" align="right" valign="top"><a id="a0af3c6a0663807cd44a519fbe25e9630"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FRAMECHECKSUMSIZE</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a0af3c6a0663807cd44a519fbe25e9630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b641e99ede5ac8ea5d5543e56b28e4"><td class="memItemLeft" align="right" valign="top"><a id="a64b641e99ede5ac8ea5d5543e56b28e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN_SEQUENCES_SIZE</b>&#160;&#160;&#160;1 /* nbSeq==0 */</td></tr>
<tr class="separator:a64b641e99ede5ac8ea5d5543e56b28e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a173ad4492fd5a86d622dca70a1da3"><td class="memItemLeft" align="right" valign="top"><a id="ab9a173ad4492fd5a86d622dca70a1da3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN_CBLOCK_SIZE</b>&#160;&#160;&#160;(1 /*litCSize*/ + 1 /* RLE or RAW */)   /* for a non-null block */</td></tr>
<tr class="separator:ab9a173ad4492fd5a86d622dca70a1da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1e450b5aae1cfe92e75044afcce206"><td class="memItemLeft" align="right" valign="top"><a id="a8c1e450b5aae1cfe92e75044afcce206"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN_LITERALS_FOR_4_STREAMS</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a8c1e450b5aae1cfe92e75044afcce206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e43abcb0fb1bc3d2b8a461daa4de371"><td class="memItemLeft" align="right" valign="top"><a id="a9e43abcb0fb1bc3d2b8a461daa4de371"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LONGNBSEQ</b>&#160;&#160;&#160;0x7F00</td></tr>
<tr class="separator:a9e43abcb0fb1bc3d2b8a461daa4de371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d835b35b6582451a75dc6ff464a9e75"><td class="memItemLeft" align="right" valign="top"><a id="a2d835b35b6582451a75dc6ff464a9e75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MINMATCH</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a2d835b35b6582451a75dc6ff464a9e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac102bcc91a5308464fc6f5b0039ec886"><td class="memItemLeft" align="right" valign="top"><a id="ac102bcc91a5308464fc6f5b0039ec886"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Litbits</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ac102bcc91a5308464fc6f5b0039ec886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45ea383b029cc57c8c14c83ed2c1e12"><td class="memItemLeft" align="right" valign="top"><a id="aa45ea383b029cc57c8c14c83ed2c1e12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LitHufLog</b>&#160;&#160;&#160;11</td></tr>
<tr class="separator:aa45ea383b029cc57c8c14c83ed2c1e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0351e69d42178cb6fb2859a1a1d853d5"><td class="memItemLeft" align="right" valign="top"><a id="a0351e69d42178cb6fb2859a1a1d853d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MaxLit</b>&#160;&#160;&#160;((1&lt;&lt;Litbits) - 1)</td></tr>
<tr class="separator:a0351e69d42178cb6fb2859a1a1d853d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc62dd4928331efa2e34ed6cc3a8130"><td class="memItemLeft" align="right" valign="top"><a id="a4fc62dd4928331efa2e34ed6cc3a8130"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MaxML</b>&#160;&#160;&#160;52</td></tr>
<tr class="separator:a4fc62dd4928331efa2e34ed6cc3a8130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3791b3a0dfbaa61ee240d5d1c548a7b0"><td class="memItemLeft" align="right" valign="top"><a id="a3791b3a0dfbaa61ee240d5d1c548a7b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MaxLL</b>&#160;&#160;&#160;35</td></tr>
<tr class="separator:a3791b3a0dfbaa61ee240d5d1c548a7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a29668fac591869d620fcdb1abf305"><td class="memItemLeft" align="right" valign="top"><a id="ae8a29668fac591869d620fcdb1abf305"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultMaxOff</b>&#160;&#160;&#160;28</td></tr>
<tr class="separator:ae8a29668fac591869d620fcdb1abf305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01fb39c723245d01032f5a759ba2b0c"><td class="memItemLeft" align="right" valign="top"><a id="ab01fb39c723245d01032f5a759ba2b0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MaxOff</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:ab01fb39c723245d01032f5a759ba2b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a404dfe486525359937319436db121"><td class="memItemLeft" align="right" valign="top"><a id="aa4a404dfe486525359937319436db121"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MaxSeq</b>&#160;&#160;&#160;MAX(MaxLL, MaxML)   /* Assumption : MaxOff &lt; MaxLL,MaxML */</td></tr>
<tr class="separator:aa4a404dfe486525359937319436db121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714e57f17112763cbe7effbdd8cd0f17"><td class="memItemLeft" align="right" valign="top"><a id="a714e57f17112763cbe7effbdd8cd0f17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MLFSELog</b>&#160;&#160;&#160;9</td></tr>
<tr class="separator:a714e57f17112763cbe7effbdd8cd0f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fe41e24ab2ae3e7c1302dc3f9dc11c"><td class="memItemLeft" align="right" valign="top"><a id="ab9fe41e24ab2ae3e7c1302dc3f9dc11c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LLFSELog</b>&#160;&#160;&#160;9</td></tr>
<tr class="separator:ab9fe41e24ab2ae3e7c1302dc3f9dc11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4165c4763105841899baf3da34f3b43"><td class="memItemLeft" align="right" valign="top"><a id="af4165c4763105841899baf3da34f3b43"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OffFSELog</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:af4165c4763105841899baf3da34f3b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf3b376b2b1ef660735d7cb09abc949"><td class="memItemLeft" align="right" valign="top"><a id="a6bf3b376b2b1ef660735d7cb09abc949"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MaxFSELog</b>&#160;&#160;&#160;MAX(MAX(MLFSELog, LLFSELog), OffFSELog)</td></tr>
<tr class="separator:a6bf3b376b2b1ef660735d7cb09abc949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0d85e58349cbef4c1e94552461d9de"><td class="memItemLeft" align="right" valign="top"><a id="aba0d85e58349cbef4c1e94552461d9de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MaxMLBits</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:aba0d85e58349cbef4c1e94552461d9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17fcd05f8e860d354fb994bc459af20"><td class="memItemLeft" align="right" valign="top"><a id="af17fcd05f8e860d354fb994bc459af20"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MaxLLBits</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:af17fcd05f8e860d354fb994bc459af20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae2401d5bd153a96570873bc7f945f2"><td class="memItemLeft" align="right" valign="top"><a id="a2ae2401d5bd153a96570873bc7f945f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MAX_HUF_HEADER_SIZE</b>&#160;&#160;&#160;128 /* header + &lt;= 127 byte tree description */</td></tr>
<tr class="separator:a2ae2401d5bd153a96570873bc7f945f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21d7b4218a16884ba63087418d7cf42"><td class="memItemLeft" align="right" valign="top"><a id="ae21d7b4218a16884ba63087418d7cf42"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MAX_FSE_HEADERS_SIZE</b>&#160;&#160;&#160;(((MaxML + 1) * MLFSELog + (MaxLL + 1) * LLFSELog + (MaxOff + 1) * OffFSELog + 7) / 8)</td></tr>
<tr class="separator:ae21d7b4218a16884ba63087418d7cf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cf2a8505f0c0582562d5273046a784"><td class="memItemLeft" align="right" valign="top"><a id="ad4cf2a8505f0c0582562d5273046a784"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LL_DEFAULTNORMLOG</b>&#160;&#160;&#160;6  /* for static allocation */</td></tr>
<tr class="separator:ad4cf2a8505f0c0582562d5273046a784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ba3017d707e46c2994fbcae751eda"><td class="memItemLeft" align="right" valign="top"><a id="a863ba3017d707e46c2994fbcae751eda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ML_DEFAULTNORMLOG</b>&#160;&#160;&#160;6  /* for static allocation */</td></tr>
<tr class="separator:a863ba3017d707e46c2994fbcae751eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aa4b7d9192fdcd790747fb97584d55"><td class="memItemLeft" align="right" valign="top"><a id="a51aa4b7d9192fdcd790747fb97584d55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OF_DEFAULTNORMLOG</b>&#160;&#160;&#160;5  /* for static allocation */</td></tr>
<tr class="separator:a51aa4b7d9192fdcd790747fb97584d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3499b7464ed71e04b64ede8460bbe0"><td class="memItemLeft" align="right" valign="top"><a id="acb3499b7464ed71e04b64ede8460bbe0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COPY8</b>(d,  s)&#160;&#160;&#160;do { ZSTD_copy8(d,s); d+=8; s+=8; } while (0)</td></tr>
<tr class="separator:acb3499b7464ed71e04b64ede8460bbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff62c773a3f2ee9846cf4c6ed920a4e5"><td class="memItemLeft" align="right" valign="top"><a id="aff62c773a3f2ee9846cf4c6ed920a4e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COPY16</b>(d,  s)&#160;&#160;&#160;do { ZSTD_copy16(d,s); d+=16; s+=16; } while (0)</td></tr>
<tr class="separator:aff62c773a3f2ee9846cf4c6ed920a4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c25b8b5da6a100a9be35a3783cd28ac"><td class="memItemLeft" align="right" valign="top"><a id="a4c25b8b5da6a100a9be35a3783cd28ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WILDCOPY_OVERLENGTH</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a4c25b8b5da6a100a9be35a3783cd28ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5ee23cf0eb1af6b6deed83247d9fac"><td class="memItemLeft" align="right" valign="top"><a id="aea5ee23cf0eb1af6b6deed83247d9fac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WILDCOPY_VECLEN</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:aea5ee23cf0eb1af6b6deed83247d9fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b9e9fcd8cacf6f41787130a8f6a896"><td class="memItemLeft" align="right" valign="top"><a id="af4b9e9fcd8cacf6f41787130a8f6a896"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WORKSPACETOOLARGE_FACTOR</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:af4b9e9fcd8cacf6f41787130a8f6a896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e646ae346eb70172e09fea2d4bd9c"><td class="memItemLeft" align="right" valign="top"><a id="a187e646ae346eb70172e09fea2d4bd9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WORKSPACETOOLARGE_MAXDURATION</b>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a187e646ae346eb70172e09fea2d4bd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385e569a1e410f5b4b4d2ce28193841d"><td class="memItemLeft" align="right" valign="top"><a id="a385e569a1e410f5b4b4d2ce28193841d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HIST_WKSP_SIZE_U32</b>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a385e569a1e410f5b4b4d2ce28193841d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be31eeaea85d1f5eb9ea5d12d8c323c"><td class="memItemLeft" align="right" valign="top"><a id="a1be31eeaea85d1f5eb9ea5d12d8c323c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HIST_WKSP_SIZE</b>&#160;&#160;&#160;(HIST_WKSP_SIZE_U32 * sizeof(unsigned))</td></tr>
<tr class="separator:a1be31eeaea85d1f5eb9ea5d12d8c323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec470b07ea51d527cd012ee2d1e545b6"><td class="memItemLeft" align="right" valign="top"><a id="aec470b07ea51d527cd012ee2d1e545b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_NEED_MALLOC</b></td></tr>
<tr class="separator:aec470b07ea51d527cd012ee2d1e545b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30e0f5c0a2a6d94509053d1daa6e102"><td class="memItemLeft" align="right" valign="top"><a id="ac30e0f5c0a2a6d94509053d1daa6e102"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEPS_NEED_MATH64</b></td></tr>
<tr class="separator:ac30e0f5c0a2a6d94509053d1daa6e102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab2ee8300d3fe2724cf97953dac66d0"><td class="memItemLeft" align="right" valign="top"><a id="a7ab2ee8300d3fe2724cf97953dac66d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_isError</b>&#160;&#160;&#160;ERR_isError</td></tr>
<tr class="separator:a7ab2ee8300d3fe2724cf97953dac66d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ae58a682ca765a027b6dbf0e2c1d9a"><td class="memItemLeft" align="right" valign="top"><a id="a33ae58a682ca765a027b6dbf0e2c1d9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_CAT</b>(X,  Y)&#160;&#160;&#160;X##Y</td></tr>
<tr class="separator:a33ae58a682ca765a027b6dbf0e2c1d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51c73112dc4ec4987c33a7cd8481111"><td class="memItemLeft" align="right" valign="top"><a id="ac51c73112dc4ec4987c33a7cd8481111"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_FUNCTION_NAME</b>(X,  Y)&#160;&#160;&#160;FSE_CAT(X,Y)</td></tr>
<tr class="separator:ac51c73112dc4ec4987c33a7cd8481111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8ed897c89142452e54c9974bf32c8d"><td class="memItemLeft" align="right" valign="top"><a id="a9b8ed897c89142452e54c9974bf32c8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_TYPE_NAME</b>(X,  Y)&#160;&#160;&#160;FSE_CAT(X,Y)</td></tr>
<tr class="separator:a9b8ed897c89142452e54c9974bf32c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a612c5393a4158f92579f73ef9c80f6"><td class="memItemLeft" align="right" valign="top"><a id="a9a612c5393a4158f92579f73ef9c80f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_FLUSHBITS</b>(s)&#160;&#160;&#160;(fast ? <a class="el" href="zstd_8c.html#aeedf7cf3cceebe81e04d22fd42971bd3">BIT_flushBitsFast</a>(s) : <a class="el" href="zstd_8c.html#a4c839965cf6a86f64d859153451ccab6">BIT_flushBits</a>(s))</td></tr>
<tr class="separator:a9a612c5393a4158f92579f73ef9c80f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b>&#160;&#160;&#160;/* <a class="el" href="zstd_8c.html#a5b48bd698b011962206908be5c233e64">FSE_optimalTableLog_internal</a> */</td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2de9e4837283ff6a5d5f4e2f43c6fed"><td class="memItemLeft" align="right" valign="top"><a id="ad2de9e4837283ff6a5d5f4e2f43c6fed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_isError</b>&#160;&#160;&#160;ERR_isError</td></tr>
<tr class="separator:ad2de9e4837283ff6a5d5f4e2f43c6fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019f007718bb8712ce4870e02d624810"><td class="memItemLeft" align="right" valign="top"><a id="a019f007718bb8712ce4870e02d624810"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_STATIC_ASSERT</b>(c)&#160;&#160;&#160;DEBUG_STATIC_ASSERT(c)   /* use only *after* variable declarations */</td></tr>
<tr class="separator:a019f007718bb8712ce4870e02d624810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bfb4d49c8d35645358277609eae9de"><td class="memItemLeft" align="right" valign="top"><a id="ae3bfb4d49c8d35645358277609eae9de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_WORKSPACE_MAX_ALIGNMENT</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ae3bfb4d49c8d35645358277609eae9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40654b2c641df4dd503108051e9c490"><td class="memItemLeft" align="right" valign="top"><a id="ae40654b2c641df4dd503108051e9c490"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_FSE_TABLELOG_FOR_HUFF_HEADER</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ae40654b2c641df4dd503108051e9c490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2688ee036d4cfcd33e759d2bc2cea5f"><td class="memItemLeft" align="right" valign="top"><a id="ab2688ee036d4cfcd33e759d2bc2cea5f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RANK_POSITION_TABLE_SIZE</b>&#160;&#160;&#160;192</td></tr>
<tr class="separator:ab2688ee036d4cfcd33e759d2bc2cea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dff097777c4750c3d5d4a2cd5f1524"><td class="memItemLeft" align="right" valign="top"><a id="a18dff097777c4750c3d5d4a2cd5f1524"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RANK_POSITION_MAX_COUNT_LOG</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a18dff097777c4750c3d5d4a2cd5f1524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd964be3c68df3436a1b6377f2ae1a"><td class="memItemLeft" align="right" valign="top"><a id="a91bd964be3c68df3436a1b6377f2ae1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RANK_POSITION_LOG_BUCKETS_BEGIN</b>&#160;&#160;&#160;((RANK_POSITION_TABLE_SIZE - 1) - RANK_POSITION_MAX_COUNT_LOG - 1 /* == 158 */)</td></tr>
<tr class="separator:a91bd964be3c68df3436a1b6377f2ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c138627480b54167b2ff481e7050f45"><td class="memItemLeft" align="right" valign="top"><a id="a2c138627480b54167b2ff481e7050f45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RANK_POSITION_DISTINCT_COUNT_CUTOFF</b>&#160;&#160;&#160;(RANK_POSITION_LOG_BUCKETS_BEGIN + ZSTD_highbit32(RANK_POSITION_LOG_BUCKETS_BEGIN) /* == 166 */)</td></tr>
<tr class="separator:a2c138627480b54167b2ff481e7050f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427eb005b5e84abd606bccd3e6c0352e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a427eb005b5e84abd606bccd3e6c0352e">STARTNODE</a>&#160;&#160;&#160;(HUF_SYMBOLVALUE_MAX+1)</td></tr>
<tr class="separator:a427eb005b5e84abd606bccd3e6c0352e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c1df14592ff8c16117056ae21c9e10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a10c1df14592ff8c16117056ae21c9e10">HUF_BITS_IN_CONTAINER</a>&#160;&#160;&#160;(sizeof(size_t) * 8)</td></tr>
<tr class="separator:a10c1df14592ff8c16117056ae21c9e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7de039d207bb434e09b205308d265d"><td class="memItemLeft" align="right" valign="top"><a id="a0b7de039d207bb434e09b205308d265d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE</b>&#160;&#160;&#160;4096</td></tr>
<tr class="separator:a0b7de039d207bb434e09b205308d265d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129c3e27813405ff47f9097e6e5579d2"><td class="memItemLeft" align="right" valign="top"><a id="a129c3e27813405ff47f9097e6e5579d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO</b>&#160;&#160;&#160;10  /* Must be &gt;= 2 */</td></tr>
<tr class="separator:a129c3e27813405ff47f9097e6e5579d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278da361eddab974ca628c17ca92dd79"><td class="memItemLeft" align="right" valign="top"><a id="a278da361eddab974ca628c17ca92dd79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESS_LITERALS_H</b></td></tr>
<tr class="separator:a278da361eddab974ca628c17ca92dd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6479f6c4c9cd4106b5b48e96c31470ac"><td class="memItemLeft" align="right" valign="top"><a id="a6479f6c4c9cd4106b5b48e96c31470ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESS_H</b></td></tr>
<tr class="separator:a6479f6c4c9cd4106b5b48e96c31470ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a5a845a10692ec1595841d0aeb1dd2"><td class="memItemLeft" align="right" valign="top"><a id="a92a5a845a10692ec1595841d0aeb1dd2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CWKSP_H</b></td></tr>
<tr class="separator:a92a5a845a10692ec1595841d0aeb1dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d1ef486ccfdd687e5202f84a2afe4c"><td class="memItemLeft" align="right" valign="top"><a id="ad5d1ef486ccfdd687e5202f84a2afe4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CWKSP_ASAN_REDZONE_SIZE</b>&#160;&#160;&#160;128</td></tr>
<tr class="separator:ad5d1ef486ccfdd687e5202f84a2afe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae9834e8994fcbe9a69a26ad1274982"><td class="memItemLeft" align="right" valign="top"><a id="a3ae9834e8994fcbe9a69a26ad1274982"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CWKSP_ALIGNMENT_BYTES</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a3ae9834e8994fcbe9a69a26ad1274982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52c5cfe457ca9433499ed6677a6967b"><td class="memItemLeft" align="right" valign="top"><a id="ae52c5cfe457ca9433499ed6677a6967b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_COMPRESS_H</b></td></tr>
<tr class="separator:ae52c5cfe457ca9433499ed6677a6967b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memItemLeft" align="right" valign="top"><a id="ad88034c8350c3d479ce0db09fd8ee0c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_STATIC_LINKING_ONLY</b>&#160;&#160;&#160;/* <a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a> */</td></tr>
<tr class="separator:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb964b940e15f616ee51c8be7580af5e"><td class="memItemLeft" align="right" valign="top"><a id="acb964b940e15f616ee51c8be7580af5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_NBWORKERS_MAX</b>&#160;&#160;&#160;((sizeof(void*)==4) /*32-bit*/ ? 64 : 256)</td></tr>
<tr class="separator:acb964b940e15f616ee51c8be7580af5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37af7fecd05e763718e0e3088871e68c"><td class="memItemLeft" align="right" valign="top"><a id="a37af7fecd05e763718e0e3088871e68c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_JOBSIZE_MIN</b>&#160;&#160;&#160;(512 KB)</td></tr>
<tr class="separator:a37af7fecd05e763718e0e3088871e68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b95d412674fc28c09614a65dd5d235"><td class="memItemLeft" align="right" valign="top"><a id="a73b95d412674fc28c09614a65dd5d235"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_JOBLOG_MAX</b>&#160;&#160;&#160;(MEM_32bits() ? 29 : 30)</td></tr>
<tr class="separator:a73b95d412674fc28c09614a65dd5d235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0921c36729f41f35f3d5418dfcb7f813"><td class="memItemLeft" align="right" valign="top"><a id="a0921c36729f41f35f3d5418dfcb7f813"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_JOBSIZE_MAX</b>&#160;&#160;&#160;(MEM_32bits() ? (512 MB) : (1024 MB))</td></tr>
<tr class="separator:a0921c36729f41f35f3d5418dfcb7f813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839f88995b2f4b9fa6fc2669e38ead68"><td class="memItemLeft" align="right" valign="top"><a id="a839f88995b2f4b9fa6fc2669e38ead68"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_PRESPLIT_H</b></td></tr>
<tr class="separator:a839f88995b2f4b9fa6fc2669e38ead68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86842851cb24c21b7a58fce3df36aad"><td class="memItemLeft" align="right" valign="top"><a id="ae86842851cb24c21b7a58fce3df36aad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SLIPBLOCK_WORKSPACESIZE</b>&#160;&#160;&#160;8208</td></tr>
<tr class="separator:ae86842851cb24c21b7a58fce3df36aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b38d7dfed96fdfb8dce21baddeb248"><td class="memItemLeft" align="right" valign="top"><a id="a64b38d7dfed96fdfb8dce21baddeb248"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>kSearchStrength</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a64b38d7dfed96fdfb8dce21baddeb248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53f6f24af0167255cf4cef22724d5a8"><td class="memItemLeft" align="right" valign="top"><a id="ae53f6f24af0167255cf4cef22724d5a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASH_READ_SIZE</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ae53f6f24af0167255cf4cef22724d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f0e4ee71ec1dedd11082fa2b54e462"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DUBT_UNSORTED_MARK</b></td></tr>
<tr class="separator:ad1f0e4ee71ec1dedd11082fa2b54e462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b86f54d80936c0bf6b5d116e0b22a7"><td class="memItemLeft" align="right" valign="top"><a id="a28b86f54d80936c0bf6b5d116e0b22a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_OPT_SIZE</b>&#160;&#160;&#160;(ZSTD_OPT_NUM+3)</td></tr>
<tr class="separator:a28b86f54d80936c0bf6b5d116e0b22a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845d5eda4027dc9125108782f6bfeed4"><td class="memItemLeft" align="right" valign="top"><a id="a845d5eda4027dc9125108782f6bfeed4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WINDOW_START_INDEX</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a845d5eda4027dc9125108782f6bfeed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd015e3f177f3da9a4accc625ab3d716"><td class="memItemLeft" align="right" valign="top"><a id="afd015e3f177f3da9a4accc625ab3d716"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ROW_HASH_CACHE_SIZE</b>&#160;&#160;&#160;8       /* Size of prefetching hash cache for row-based matchfinder */</td></tr>
<tr class="separator:afd015e3f177f3da9a4accc625ab3d716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab55f2ab5c2bb6af458b8af83ec12666"><td class="memItemLeft" align="right" valign="top"><a id="aab55f2ab5c2bb6af458b8af83ec12666"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LDM_BATCH_SIZE</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:aab55f2ab5c2bb6af458b8af83ec12666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1027bced42d2f607615b98ae9cf8552"><td class="memItemLeft" align="right" valign="top"><a id="ae1027bced42d2f607615b98ae9cf8552"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMPRESS_SEQUENCES_WORKSPACE_SIZE</b>&#160;&#160;&#160;(sizeof(unsigned) * (MaxSeq + 2))</td></tr>
<tr class="separator:ae1027bced42d2f607615b98ae9cf8552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed2b04e2ed3ee6b58c0908d510f06b"><td class="memItemLeft" align="right" valign="top"><a id="a84ed2b04e2ed3ee6b58c0908d510f06b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ENTROPY_WORKSPACE_SIZE</b>&#160;&#160;&#160;(HUF_WORKSPACE_SIZE + COMPRESS_SEQUENCES_WORKSPACE_SIZE)</td></tr>
<tr class="separator:a84ed2b04e2ed3ee6b58c0908d510f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366729f7aae88c445b1f486f8c15ee2d"><td class="memItemLeft" align="right" valign="top"><a id="a366729f7aae88c445b1f486f8c15ee2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TMP_WORKSPACE_SIZE</b>&#160;&#160;&#160;(MAX(ENTROPY_WORKSPACE_SIZE, ZSTD_SLIPBLOCK_WORKSPACESIZE))</td></tr>
<tr class="separator:a366729f7aae88c445b1f486f8c15ee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819c3efc2a4005aadfec6f0ef9859744"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a819c3efc2a4005aadfec6f0ef9859744">ZSTD_MAX_NB_BLOCK_SPLITS</a>&#160;&#160;&#160;196</td></tr>
<tr class="separator:a819c3efc2a4005aadfec6f0ef9859744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa457d39f66f5d13919e6325548d6ff1f"><td class="memItemLeft" align="right" valign="top"><a id="aa457d39f66f5d13919e6325548d6ff1f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPCODE1_TO_OFFBASE</b>&#160;&#160;&#160;REPCODE_TO_OFFBASE(1)</td></tr>
<tr class="separator:aa457d39f66f5d13919e6325548d6ff1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725e2514159c0c758182d0a22e094ad0"><td class="memItemLeft" align="right" valign="top"><a id="a725e2514159c0c758182d0a22e094ad0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPCODE2_TO_OFFBASE</b>&#160;&#160;&#160;REPCODE_TO_OFFBASE(2)</td></tr>
<tr class="separator:a725e2514159c0c758182d0a22e094ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b4825350e3d3025772e380e9b6e414"><td class="memItemLeft" align="right" valign="top"><a id="a22b4825350e3d3025772e380e9b6e414"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPCODE3_TO_OFFBASE</b>&#160;&#160;&#160;REPCODE_TO_OFFBASE(3)</td></tr>
<tr class="separator:a22b4825350e3d3025772e380e9b6e414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba22e05467ce71ca8edba28aca9feb4e"><td class="memItemLeft" align="right" valign="top"><a id="aba22e05467ce71ca8edba28aca9feb4e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPCODE_TO_OFFBASE</b>(r)&#160;&#160;&#160;(assert((r)&gt;=1), assert((r)&lt;=ZSTD_REP_NUM), (r)) /* accepts IDs 1,2,3 */</td></tr>
<tr class="separator:aba22e05467ce71ca8edba28aca9feb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63831dd5dc14a80908be894815c94009"><td class="memItemLeft" align="right" valign="top"><a id="a63831dd5dc14a80908be894815c94009"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OFFSET_TO_OFFBASE</b>(o)&#160;&#160;&#160;(assert((o)&gt;0), o + ZSTD_REP_NUM)</td></tr>
<tr class="separator:a63831dd5dc14a80908be894815c94009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaef588f343b5ef63d14723d1bf0a775"><td class="memItemLeft" align="right" valign="top"><a id="abaef588f343b5ef63d14723d1bf0a775"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OFFBASE_IS_OFFSET</b>(o)&#160;&#160;&#160;((o) &gt; ZSTD_REP_NUM)</td></tr>
<tr class="separator:abaef588f343b5ef63d14723d1bf0a775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5160ddf88915e4ef4e466be43fdcc4"><td class="memItemLeft" align="right" valign="top"><a id="a3e5160ddf88915e4ef4e466be43fdcc4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OFFBASE_IS_REPCODE</b>(o)&#160;&#160;&#160;( 1 &lt;= (o) &amp;&amp; (o) &lt;= ZSTD_REP_NUM)</td></tr>
<tr class="separator:a3e5160ddf88915e4ef4e466be43fdcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363a119257d7526f60e0fd410504dd52"><td class="memItemLeft" align="right" valign="top"><a id="a363a119257d7526f60e0fd410504dd52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OFFBASE_TO_OFFSET</b>(o)&#160;&#160;&#160;(assert(OFFBASE_IS_OFFSET(o)), (o) - ZSTD_REP_NUM)</td></tr>
<tr class="separator:a363a119257d7526f60e0fd410504dd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cdfadc518e7910e100bf16da612db1"><td class="memItemLeft" align="right" valign="top"><a id="ad1cdfadc518e7910e100bf16da612db1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OFFBASE_TO_REPCODE</b>(o)&#160;&#160;&#160;(assert(OFFBASE_IS_REPCODE(o)), (o))  /* returns ID 1,2,3 */</td></tr>
<tr class="separator:ad1cdfadc518e7910e100bf16da612db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8ff930378de767bac5a59d003f78f1"><td class="memItemLeft" align="right" valign="top"><a id="aee8ff930378de767bac5a59d003f78f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ROLL_HASH_CHAR_OFFSET</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:aee8ff930378de767bac5a59d003f78f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3ff795e86cb80085a7c7205b7dea5f"><td class="memItemLeft" align="right" valign="top"><a id="a0a3ff795e86cb80085a7c7205b7dea5f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CURRENT_MAX</b>&#160;&#160;&#160;(MEM_64bits() ? 3500U MB : 2000U MB)</td></tr>
<tr class="separator:a0a3ff795e86cb80085a7c7205b7dea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63096599b11d583c749f6202e6c38f99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CHUNKSIZE_MAX</b></td></tr>
<tr class="separator:a63096599b11d583c749f6202e6c38f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e7f7dbc50ee65ecbf7363f3118e9f7"><td class="memItemLeft" align="right" valign="top"><a id="aa6e7f7dbc50ee65ecbf7363f3118e9f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aa6e7f7dbc50ee65ecbf7363f3118e9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c310487ed361a5921c952343eb20062"><td class="memItemLeft" align="right" valign="top"><a id="a2c310487ed361a5921c952343eb20062"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SHORT_CACHE_TAG_BITS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a2c310487ed361a5921c952343eb20062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6412fe96ac1596305760ab9adcc25ea1"><td class="memItemLeft" align="right" valign="top"><a id="a6412fe96ac1596305760ab9adcc25ea1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SHORT_CACHE_TAG_MASK</b>&#160;&#160;&#160;((1u &lt;&lt; ZSTD_SHORT_CACHE_TAG_BITS) - 1)</td></tr>
<tr class="separator:a6412fe96ac1596305760ab9adcc25ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce86e993255ed399237b85173c3326d"><td class="memItemLeft" align="right" valign="top"><a id="abce86e993255ed399237b85173c3326d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESS_SEQUENCES_H</b></td></tr>
<tr class="separator:abce86e993255ed399237b85173c3326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c204d1780bf066fd17d9318ffc12d7"><td class="memItemLeft" align="right" valign="top"><a id="a81c204d1780bf066fd17d9318ffc12d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESS_ADVANCED_H</b></td></tr>
<tr class="separator:a81c204d1780bf066fd17d9318ffc12d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55243a62934a725989c1a8fa8c84c2c5"><td class="memItemLeft" align="right" valign="top"><a id="a55243a62934a725989c1a8fa8c84c2c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BYTESCALE</b>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a55243a62934a725989c1a8fa8c84c2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7df0e57c63cf36d2b9fd782ccd862d"><td class="memItemLeft" align="right" valign="top"><a id="abc7df0e57c63cf36d2b9fd782ccd862d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BLOCKSIZE_MIN</b>&#160;&#160;&#160;3500</td></tr>
<tr class="separator:abc7df0e57c63cf36d2b9fd782ccd862d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db67e660e4c1975b646f211ae692221"><td class="memItemLeft" align="right" valign="top"><a id="a9db67e660e4c1975b646f211ae692221"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>THRESHOLD_PENALTY_RATE</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a9db67e660e4c1975b646f211ae692221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f9931a142de0d3618b4bacf68e09db"><td class="memItemLeft" align="right" valign="top"><a id="ad9f9931a142de0d3618b4bacf68e09db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>THRESHOLD_BASE</b>&#160;&#160;&#160;(THRESHOLD_PENALTY_RATE - 2)</td></tr>
<tr class="separator:ad9f9931a142de0d3618b4bacf68e09db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608d732d5e67cdeeeadd05c008353f0"><td class="memItemLeft" align="right" valign="top"><a id="ae608d732d5e67cdeeeadd05c008353f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>THRESHOLD_PENALTY</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ae608d732d5e67cdeeeadd05c008353f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663a695f0855a54eae517d4b68e704a0"><td class="memItemLeft" align="right" valign="top"><a id="a663a695f0855a54eae517d4b68e704a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASHLENGTH</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a663a695f0855a54eae517d4b68e704a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5427a5e09348ba2b43629e5664c841e"><td class="memItemLeft" align="right" valign="top"><a id="af5427a5e09348ba2b43629e5664c841e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASHLOG_MAX</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:af5427a5e09348ba2b43629e5664c841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f3391502e32c9a48898f47f6473011"><td class="memItemLeft" align="right" valign="top"><a id="a89f3391502e32c9a48898f47f6473011"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASHTABLESIZE</b>&#160;&#160;&#160;(1 &lt;&lt; HASHLOG_MAX)</td></tr>
<tr class="separator:a89f3391502e32c9a48898f47f6473011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8acc7f1ecf38dccbb9b46d41b67339"><td class="memItemLeft" align="right" valign="top"><a id="afa8acc7f1ecf38dccbb9b46d41b67339"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASHMASK</b>&#160;&#160;&#160;(HASHTABLESIZE - 1)</td></tr>
<tr class="separator:afa8acc7f1ecf38dccbb9b46d41b67339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8122096e8a99e85d381b85a5126805de"><td class="memItemLeft" align="right" valign="top"><a id="a8122096e8a99e85d381b85a5126805de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KNUTH</b>&#160;&#160;&#160;0x9e3779b9</td></tr>
<tr class="separator:a8122096e8a99e85d381b85a5126805de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2bec104f4ff8b32e5378b4f3840a45"><td class="memItemLeft" align="right" valign="top"><a id="a8d2bec104f4ff8b32e5378b4f3840a45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FP_RECORD</b>(_rate)&#160;&#160;&#160;ZSTD_recordFingerprint_##_rate</td></tr>
<tr class="separator:a8d2bec104f4ff8b32e5378b4f3840a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430683fe90300dfdda39b13c44c7f98d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_GEN_RECORD_FINGERPRINT</b>(_rate,  _hSize)</td></tr>
<tr class="separator:a430683fe90300dfdda39b13c44c7f98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239bebe1697b474e6f84945e9fb9faee"><td class="memItemLeft" align="right" valign="top"><a id="a239bebe1697b474e6f84945e9fb9faee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHUNKSIZE</b>&#160;&#160;&#160;(8 &lt;&lt; 10)</td></tr>
<tr class="separator:a239bebe1697b474e6f84945e9fb9faee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe07a3c3fe2056125230c357f85b870"><td class="memItemLeft" align="right" valign="top"><a id="acbe07a3c3fe2056125230c357f85b870"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGMENT_SIZE</b>&#160;&#160;&#160;512</td></tr>
<tr class="separator:acbe07a3c3fe2056125230c357f85b870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b>&#160;&#160;&#160;/* FSE_encodeSymbol */</td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f589ef0c557786cbab2eaeec9463608"><td class="memItemLeft" align="right" valign="top"><a id="a8f589ef0c557786cbab2eaeec9463608"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FAST_H</b></td></tr>
<tr class="separator:a8f589ef0c557786cbab2eaeec9463608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1332a04ec76427adeb3e25f71eb8aa"><td class="memItemLeft" align="right" valign="top"><a id="a0e1332a04ec76427adeb3e25f71eb8aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DOUBLE_FAST_H</b></td></tr>
<tr class="separator:a0e1332a04ec76427adeb3e25f71eb8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c83680c3dac0aa12dfe9f73930be2a7"><td class="memItemLeft" align="right" valign="top"><a id="a6c83680c3dac0aa12dfe9f73930be2a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_DOUBLEFAST</b>&#160;&#160;&#160;ZSTD_compressBlock_doubleFast</td></tr>
<tr class="separator:a6c83680c3dac0aa12dfe9f73930be2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a48cf7061b569c745331d8168659e0"><td class="memItemLeft" align="right" valign="top"><a id="a22a48cf7061b569c745331d8168659e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_DOUBLEFAST_DICTMATCHSTATE</b>&#160;&#160;&#160;ZSTD_compressBlock_doubleFast_dictMatchState</td></tr>
<tr class="separator:a22a48cf7061b569c745331d8168659e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6769bbbbb5071df02e120f098b2ef223"><td class="memItemLeft" align="right" valign="top"><a id="a6769bbbbb5071df02e120f098b2ef223"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_DOUBLEFAST_EXTDICT</b>&#160;&#160;&#160;ZSTD_compressBlock_doubleFast_extDict</td></tr>
<tr class="separator:a6769bbbbb5071df02e120f098b2ef223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a950c9d975ad4e113f5a917ce6a947"><td class="memItemLeft" align="right" valign="top"><a id="a29a950c9d975ad4e113f5a917ce6a947"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LAZY_H</b></td></tr>
<tr class="separator:a29a950c9d975ad4e113f5a917ce6a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e1c827583b0133b085b8cfc1cdb236"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac3e1c827583b0133b085b8cfc1cdb236">ZSTD_LAZY_DDSS_BUCKET_LOG</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac3e1c827583b0133b085b8cfc1cdb236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5f7a60914473cfceeda3a3f715af7a"><td class="memItemLeft" align="right" valign="top"><a id="a4d5f7a60914473cfceeda3a3f715af7a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ROW_HASH_TAG_BITS</b>&#160;&#160;&#160;8        /* nb bits to use for the tag */</td></tr>
<tr class="separator:a4d5f7a60914473cfceeda3a3f715af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54edb68d4d023bf307effd7cb514070"><td class="memItemLeft" align="right" valign="top"><a id="ae54edb68d4d023bf307effd7cb514070"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_GREEDY</b>&#160;&#160;&#160;<a class="el" href="zstd_8c.html#a5f1c3b7591d8f246da5805d86947daea">ZSTD_compressBlock_greedy</a></td></tr>
<tr class="separator:ae54edb68d4d023bf307effd7cb514070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaab766be3ababef12cb778dbf819f5a"><td class="memItemLeft" align="right" valign="top"><a id="abaab766be3ababef12cb778dbf819f5a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_GREEDY_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_greedy_row</td></tr>
<tr class="separator:abaab766be3ababef12cb778dbf819f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8987277d4141ed5477249829fc5a4f79"><td class="memItemLeft" align="right" valign="top"><a id="a8987277d4141ed5477249829fc5a4f79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_GREEDY_DICTMATCHSTATE</b>&#160;&#160;&#160;ZSTD_compressBlock_greedy_dictMatchState</td></tr>
<tr class="separator:a8987277d4141ed5477249829fc5a4f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5038ed13a682089afc70c36b56d9a32e"><td class="memItemLeft" align="right" valign="top"><a id="a5038ed13a682089afc70c36b56d9a32e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_GREEDY_DICTMATCHSTATE_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_greedy_dictMatchState_row</td></tr>
<tr class="separator:a5038ed13a682089afc70c36b56d9a32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e873c360e7be1d7cebbd80ee398a87"><td class="memItemLeft" align="right" valign="top"><a id="af9e873c360e7be1d7cebbd80ee398a87"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_GREEDY_DEDICATEDDICTSEARCH</b>&#160;&#160;&#160;ZSTD_compressBlock_greedy_dedicatedDictSearch</td></tr>
<tr class="separator:af9e873c360e7be1d7cebbd80ee398a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00659e14283ced5735acd4f0660ecb2"><td class="memItemLeft" align="right" valign="top"><a id="ad00659e14283ced5735acd4f0660ecb2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_GREEDY_DEDICATEDDICTSEARCH_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_greedy_dedicatedDictSearch_row</td></tr>
<tr class="separator:ad00659e14283ced5735acd4f0660ecb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35c7ff1df87e169390f072a778555e5"><td class="memItemLeft" align="right" valign="top"><a id="ad35c7ff1df87e169390f072a778555e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_GREEDY_EXTDICT</b>&#160;&#160;&#160;ZSTD_compressBlock_greedy_extDict</td></tr>
<tr class="separator:ad35c7ff1df87e169390f072a778555e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f131c813715183392cddc1d41bd4d9f"><td class="memItemLeft" align="right" valign="top"><a id="a2f131c813715183392cddc1d41bd4d9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_GREEDY_EXTDICT_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_greedy_extDict_row</td></tr>
<tr class="separator:a2f131c813715183392cddc1d41bd4d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d60ee12913491d294c1fe037d240bd"><td class="memItemLeft" align="right" valign="top"><a id="a95d60ee12913491d294c1fe037d240bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy</td></tr>
<tr class="separator:a95d60ee12913491d294c1fe037d240bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb2e3b0aeecb53d461d9f28dc469233"><td class="memItemLeft" align="right" valign="top"><a id="a2fb2e3b0aeecb53d461d9f28dc469233"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy_row</td></tr>
<tr class="separator:a2fb2e3b0aeecb53d461d9f28dc469233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9136c0f865aac80b51b5e2ebfdda2de"><td class="memItemLeft" align="right" valign="top"><a id="ab9136c0f865aac80b51b5e2ebfdda2de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY_DICTMATCHSTATE</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy_dictMatchState</td></tr>
<tr class="separator:ab9136c0f865aac80b51b5e2ebfdda2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1198a5328e752ba65c6b510cafcd3"><td class="memItemLeft" align="right" valign="top"><a id="a27b1198a5328e752ba65c6b510cafcd3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY_DICTMATCHSTATE_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy_dictMatchState_row</td></tr>
<tr class="separator:a27b1198a5328e752ba65c6b510cafcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c08785fecc163c13255176d6f8038b"><td class="memItemLeft" align="right" valign="top"><a id="a39c08785fecc163c13255176d6f8038b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY_DEDICATEDDICTSEARCH</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy_dedicatedDictSearch</td></tr>
<tr class="separator:a39c08785fecc163c13255176d6f8038b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2c75d28568e03250f9eb82167157ca"><td class="memItemLeft" align="right" valign="top"><a id="a4e2c75d28568e03250f9eb82167157ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY_DEDICATEDDICTSEARCH_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy_dedicatedDictSearch_row</td></tr>
<tr class="separator:a4e2c75d28568e03250f9eb82167157ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4af547367cac80be510c47758da5df"><td class="memItemLeft" align="right" valign="top"><a id="a8d4af547367cac80be510c47758da5df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY_EXTDICT</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy_extDict</td></tr>
<tr class="separator:a8d4af547367cac80be510c47758da5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f8c7ca1dc8b7ef01abecccbae0ebc5"><td class="memItemLeft" align="right" valign="top"><a id="a49f8c7ca1dc8b7ef01abecccbae0ebc5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY_EXTDICT_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy_extDict_row</td></tr>
<tr class="separator:a49f8c7ca1dc8b7ef01abecccbae0ebc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5d3a77dba08bd3f62e4d5cb7a79f44"><td class="memItemLeft" align="right" valign="top"><a id="a7b5d3a77dba08bd3f62e4d5cb7a79f44"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY2</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy2</td></tr>
<tr class="separator:a7b5d3a77dba08bd3f62e4d5cb7a79f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d41a1bbdcef68268c2f1bd86e0a184"><td class="memItemLeft" align="right" valign="top"><a id="a50d41a1bbdcef68268c2f1bd86e0a184"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY2_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy2_row</td></tr>
<tr class="separator:a50d41a1bbdcef68268c2f1bd86e0a184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c617d378a71f809f06b472fda96964"><td class="memItemLeft" align="right" valign="top"><a id="a51c617d378a71f809f06b472fda96964"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY2_DICTMATCHSTATE</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy2_dictMatchState</td></tr>
<tr class="separator:a51c617d378a71f809f06b472fda96964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1479665b95f09a8df8b0a082d7be431"><td class="memItemLeft" align="right" valign="top"><a id="af1479665b95f09a8df8b0a082d7be431"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY2_DICTMATCHSTATE_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy2_dictMatchState_row</td></tr>
<tr class="separator:af1479665b95f09a8df8b0a082d7be431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d20fe4f4031c74e7226c926e7c3ec7"><td class="memItemLeft" align="right" valign="top"><a id="a33d20fe4f4031c74e7226c926e7c3ec7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY2_DEDICATEDDICTSEARCH</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy2_dedicatedDictSearch</td></tr>
<tr class="separator:a33d20fe4f4031c74e7226c926e7c3ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08838a59debeb1333b7c9856a6aaff14"><td class="memItemLeft" align="right" valign="top"><a id="a08838a59debeb1333b7c9856a6aaff14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY2_DEDICATEDDICTSEARCH_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy2_dedicatedDictSearch_row</td></tr>
<tr class="separator:a08838a59debeb1333b7c9856a6aaff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee39222cd7d5aa4c7a2c3b9e963005"><td class="memItemLeft" align="right" valign="top"><a id="a43ee39222cd7d5aa4c7a2c3b9e963005"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY2_EXTDICT</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy2_extDict</td></tr>
<tr class="separator:a43ee39222cd7d5aa4c7a2c3b9e963005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7437988e709e3a63c25937b0947c7d7"><td class="memItemLeft" align="right" valign="top"><a id="ab7437988e709e3a63c25937b0947c7d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_LAZY2_EXTDICT_ROW</b>&#160;&#160;&#160;ZSTD_compressBlock_lazy2_extDict_row</td></tr>
<tr class="separator:ab7437988e709e3a63c25937b0947c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394ffd73a3caca3a7ab714081f13b735"><td class="memItemLeft" align="right" valign="top"><a id="a394ffd73a3caca3a7ab714081f13b735"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTLAZY2</b>&#160;&#160;&#160;ZSTD_compressBlock_btlazy2</td></tr>
<tr class="separator:a394ffd73a3caca3a7ab714081f13b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dc2fd149055e73893a93b576efbc96"><td class="memItemLeft" align="right" valign="top"><a id="ae7dc2fd149055e73893a93b576efbc96"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTLAZY2_DICTMATCHSTATE</b>&#160;&#160;&#160;ZSTD_compressBlock_btlazy2_dictMatchState</td></tr>
<tr class="separator:ae7dc2fd149055e73893a93b576efbc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b4cdd0bd531788d37ee09017913e0e"><td class="memItemLeft" align="right" valign="top"><a id="ab3b4cdd0bd531788d37ee09017913e0e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTLAZY2_EXTDICT</b>&#160;&#160;&#160;ZSTD_compressBlock_btlazy2_extDict</td></tr>
<tr class="separator:ab3b4cdd0bd531788d37ee09017913e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8469b84cfd264789462197d155f211"><td class="memItemLeft" align="right" valign="top"><a id="abe8469b84cfd264789462197d155f211"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_OPT_H</b></td></tr>
<tr class="separator:abe8469b84cfd264789462197d155f211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95d7838cb411b4aa7cd2ccb58e24725"><td class="memItemLeft" align="right" valign="top"><a id="ad95d7838cb411b4aa7cd2ccb58e24725"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTOPT</b>&#160;&#160;&#160;ZSTD_compressBlock_btopt</td></tr>
<tr class="separator:ad95d7838cb411b4aa7cd2ccb58e24725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bc47dc0c5d326b2085a7712d005282"><td class="memItemLeft" align="right" valign="top"><a id="aa7bc47dc0c5d326b2085a7712d005282"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTOPT_DICTMATCHSTATE</b>&#160;&#160;&#160;ZSTD_compressBlock_btopt_dictMatchState</td></tr>
<tr class="separator:aa7bc47dc0c5d326b2085a7712d005282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d18a9505988aee2c03a24b754e65373"><td class="memItemLeft" align="right" valign="top"><a id="a8d18a9505988aee2c03a24b754e65373"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTOPT_EXTDICT</b>&#160;&#160;&#160;ZSTD_compressBlock_btopt_extDict</td></tr>
<tr class="separator:a8d18a9505988aee2c03a24b754e65373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e84b07f2a124ef7460d5e680702468"><td class="memItemLeft" align="right" valign="top"><a id="a18e84b07f2a124ef7460d5e680702468"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTULTRA</b>&#160;&#160;&#160;ZSTD_compressBlock_btultra</td></tr>
<tr class="separator:a18e84b07f2a124ef7460d5e680702468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc914345bf266e897b70986cc0ed4bd9"><td class="memItemLeft" align="right" valign="top"><a id="acc914345bf266e897b70986cc0ed4bd9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTULTRA_DICTMATCHSTATE</b>&#160;&#160;&#160;ZSTD_compressBlock_btultra_dictMatchState</td></tr>
<tr class="separator:acc914345bf266e897b70986cc0ed4bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259255813fb1447b62c1408a42e383b7"><td class="memItemLeft" align="right" valign="top"><a id="a259255813fb1447b62c1408a42e383b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTULTRA_EXTDICT</b>&#160;&#160;&#160;ZSTD_compressBlock_btultra_extDict</td></tr>
<tr class="separator:a259255813fb1447b62c1408a42e383b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab221f847ca1057695edf93f1c38f15ef"><td class="memItemLeft" align="right" valign="top"><a id="ab221f847ca1057695edf93f1c38f15ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_COMPRESSBLOCK_BTULTRA2</b>&#160;&#160;&#160;ZSTD_compressBlock_btultra2</td></tr>
<tr class="separator:ab221f847ca1057695edf93f1c38f15ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f7adcc2c3aa66121851f1882abaf0"><td class="memItemLeft" align="right" valign="top"><a id="abc4f7adcc2c3aa66121851f1882abaf0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_H</b></td></tr>
<tr class="separator:abc4f7adcc2c3aa66121851f1882abaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e14e7cd31f562f7cf700956cd2b9a2d"><td class="memItemLeft" align="right" valign="top"><a id="a1e14e7cd31f562f7cf700956cd2b9a2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_DEFAULT_WINDOW_LOG</b>&#160;&#160;&#160;ZSTD_WINDOWLOG_LIMIT_DEFAULT</td></tr>
<tr class="separator:a1e14e7cd31f562f7cf700956cd2b9a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4196a5b70b307fc9336bd11a3ff68d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac4196a5b70b307fc9336bd11a3ff68d2">ZSTD_COMPRESS_HEAPMODE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ac4196a5b70b307fc9336bd11a3ff68d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac570c350773632077c2d6b045b7f0be4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac570c350773632077c2d6b045b7f0be4">ZSTD_HASHLOG3_MAX</a>&#160;&#160;&#160;17</td></tr>
<tr class="separator:ac570c350773632077c2d6b045b7f0be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a687e16f4dd3fa68cadeba5231170c5"><td class="memItemLeft" align="right" valign="top"><a id="a8a687e16f4dd3fa68cadeba5231170c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_NO_CLEVEL</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a8a687e16f4dd3fa68cadeba5231170c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75e8172629eccb14017b40ee1591de8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOUNDCHECK</b>(cParam,  val)</td></tr>
<tr class="separator:ae75e8172629eccb14017b40ee1591de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f63459ca3ad3b8e45155fc272d19c3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CLAMP_TYPE</b>(cParam,  val,  type)</td></tr>
<tr class="separator:a3f63459ca3ad3b8e45155fc272d19c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6fc57bae5e399f3bff96a008219867"><td class="memItemLeft" align="right" valign="top"><a id="adb6fc57bae5e399f3bff96a008219867"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CLAMP</b>(cParam,  val)&#160;&#160;&#160;CLAMP_TYPE(cParam, val, unsigned)</td></tr>
<tr class="separator:adb6fc57bae5e399f3bff96a008219867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb715fa772e8a2deeb2c5722e5f942ba"><td class="memItemLeft" align="right" valign="top"><a id="acb715fa772e8a2deeb2c5722e5f942ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_INDEXOVERFLOW_MARGIN</b>&#160;&#160;&#160;(16 MB)</td></tr>
<tr class="separator:acb715fa772e8a2deeb2c5722e5f942ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d9b8948772c1315fc8399fa4ec3b03"><td class="memItemLeft" align="right" valign="top"><a id="a53d9b8948772c1315fc8399fa4ec3b03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ROWSIZE</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a53d9b8948772c1315fc8399fa4ec3b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfcb20e114d94965a0ca05a8a80293d"><td class="memItemLeft" align="right" valign="top"><a id="a2cfcb20e114d94965a0ca05a8a80293d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO</b>&#160;&#160;&#160;20</td></tr>
<tr class="separator:a2cfcb20e114d94965a0ca05a8a80293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82395c4e1c949398f444e4aa5f70f99c"><td class="memItemLeft" align="right" valign="top"><a id="a82395c4e1c949398f444e4aa5f70f99c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMPRESS_LITERALS_SIZE_MIN</b>&#160;&#160;&#160;63  /* heuristic */</td></tr>
<tr class="separator:a82395c4e1c949398f444e4aa5f70f99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171117f24f99edbe196f2c6697da11ee"><td class="memItemLeft" align="right" valign="top"><a id="a171117f24f99edbe196f2c6697da11ee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN_SEQUENCES_BLOCK_SPLITTING</b>&#160;&#160;&#160;300</td></tr>
<tr class="separator:a171117f24f99edbe196f2c6697da11ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed14d2ff5e24cf9501fd3c4cf7151f1"><td class="memItemLeft" align="right" valign="top"><a id="aaed14d2ff5e24cf9501fd3c4cf7151f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF</b>&#160;&#160;&#160;(128 KB)</td></tr>
<tr class="separator:aaed14d2ff5e24cf9501fd3c4cf7151f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb6520f1d8dec54a4f9b4a2acd1f3a"><td class="memItemLeft" align="right" valign="top"><a id="a05cb6520f1d8dec54a4f9b4a2acd1f3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER</b>&#160;&#160;&#160;(6ULL)</td></tr>
<tr class="separator:a05cb6520f1d8dec54a4f9b4a2acd1f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54631858d3e0346cea7df48bc6ac5917"><td class="memItemLeft" align="right" valign="top"><a id="a54631858d3e0346cea7df48bc6ac5917"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CLEVELS_H</b></td></tr>
<tr class="separator:a54631858d3e0346cea7df48bc6ac5917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memItemLeft" align="right" valign="top"><a id="ad88034c8350c3d479ce0db09fd8ee0c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_STATIC_LINKING_ONLY</b>&#160;&#160;&#160;/* <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>  */</td></tr>
<tr class="separator:ad88034c8350c3d479ce0db09fd8ee0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d662436ce5bfae1ca45c78728fd522"><td class="memItemLeft" align="right" valign="top"><a id="a38d662436ce5bfae1ca45c78728fd522"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MAX_CLEVEL</b>&#160;&#160;&#160;22</td></tr>
<tr class="separator:a38d662436ce5bfae1ca45c78728fd522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad447810dcf165b6087b42c4aa4f1ee5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_GEN_DFAST_FN</b>(dictMode,  mls)</td></tr>
<tr class="separator:ad447810dcf165b6087b42c4aa4f1ee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f6014178292642a6cecfac6903fb9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_GEN_FAST_FN</b>(dictMode,  mml,  cmov)</td></tr>
<tr class="separator:a70f6014178292642a6cecfac6903fb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd1c59098b058d73302a8f60bb97dba"><td class="memItemLeft" align="right" valign="top"><a id="a7fd1c59098b058d73302a8f60bb97dba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>kLazySkippingStep</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a7fd1c59098b058d73302a8f60bb97dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbac759cfc9e41069485919721137640"><td class="memItemLeft" align="right" valign="top"><a id="acbac759cfc9e41069485919721137640"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NEXT_IN_CHAIN</b>(d,  mask)&#160;&#160;&#160;chainTable[(d) &amp; (mask)]</td></tr>
<tr class="separator:acbac759cfc9e41069485919721137640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9d2dc3164e1bf126d5cd7a94d2b594"><td class="memItemLeft" align="right" valign="top"><a id="aea9d2dc3164e1bf126d5cd7a94d2b594"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ROW_HASH_TAG_MASK</b>&#160;&#160;&#160;((1u &lt;&lt; ZSTD_ROW_HASH_TAG_BITS) - 1)</td></tr>
<tr class="separator:aea9d2dc3164e1bf126d5cd7a94d2b594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1ce7a0598f15adb0132941a454a0bb"><td class="memItemLeft" align="right" valign="top"><a id="a1f1ce7a0598f15adb0132941a454a0bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ROW_HASH_MAX_ENTRIES</b>&#160;&#160;&#160;64    /* absolute maximum number of entries per row, for all configurations */</td></tr>
<tr class="separator:a1f1ce7a0598f15adb0132941a454a0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd411a0d55f42efc638359d6cf74f6b"><td class="memItemLeft" align="right" valign="top"><a id="a8dd411a0d55f42efc638359d6cf74f6b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ROW_HASH_CACHE_MASK</b>&#160;&#160;&#160;(ZSTD_ROW_HASH_CACHE_SIZE - 1)</td></tr>
<tr class="separator:a8dd411a0d55f42efc638359d6cf74f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9888c297ee0ceeddd300eed6430b69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abc9888c297ee0ceeddd300eed6430b69">ZSTD_BT_SEARCH_FN</a>(dictMode,  mls)&#160;&#160;&#160;ZSTD_BtFindBestMatch_##dictMode##_##mls</td></tr>
<tr class="separator:abc9888c297ee0ceeddd300eed6430b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e046dc232a699e085b78f6f69925269"><td class="memItemLeft" align="right" valign="top"><a id="a9e046dc232a699e085b78f6f69925269"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HC_SEARCH_FN</b>(dictMode,  mls)&#160;&#160;&#160;ZSTD_HcFindBestMatch_##dictMode##_##mls</td></tr>
<tr class="separator:a9e046dc232a699e085b78f6f69925269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9475feeab9e6453945ce763b8086490a"><td class="memItemLeft" align="right" valign="top"><a id="a9475feeab9e6453945ce763b8086490a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ROW_SEARCH_FN</b>(dictMode,  mls,  rowLog)&#160;&#160;&#160;ZSTD_RowFindBestMatch_##dictMode##_##mls##_##rowLog</td></tr>
<tr class="separator:a9475feeab9e6453945ce763b8086490a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bf8f0df708bc8d9c466a90da2b9019"><td class="memItemLeft" align="right" valign="top"><a id="a98bf8f0df708bc8d9c466a90da2b9019"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SEARCH_FN_ATTRS</b>&#160;&#160;&#160;FORCE_NOINLINE</td></tr>
<tr class="separator:a98bf8f0df708bc8d9c466a90da2b9019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd76372f399f4a6603fe707ed1921be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_ZSTD_BT_SEARCH_FN</b>(dictMode,  mls)</td></tr>
<tr class="separator:aacd76372f399f4a6603fe707ed1921be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c25f76269d2654d626342e04c833b26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_ZSTD_HC_SEARCH_FN</b>(dictMode,  mls)</td></tr>
<tr class="separator:a4c25f76269d2654d626342e04c833b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a6a0e7f4b947848c6c66fb93665204"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_ZSTD_ROW_SEARCH_FN</b>(dictMode,  mls,  rowLog)</td></tr>
<tr class="separator:ae3a6a0e7f4b947848c6c66fb93665204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5728fbd0a5968e6f6ad1204e2928c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FOR_EACH_ROWLOG</b>(X,  dictMode,  mls)</td></tr>
<tr class="separator:a0a5728fbd0a5968e6f6ad1204e2928c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5d710e0606341946558473e725e738"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FOR_EACH_MLS_ROWLOG</b>(X,  dictMode)</td></tr>
<tr class="separator:a2c5d710e0606341946558473e725e738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356b4fbe5c2600b1098938ebe26fc993"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FOR_EACH_MLS</b>(X,  dictMode)</td></tr>
<tr class="separator:a356b4fbe5c2600b1098938ebe26fc993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6b371e82f95fae4124317352d69e0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FOR_EACH_DICT_MODE</b>(X, ...)</td></tr>
<tr class="separator:a5f6b371e82f95fae4124317352d69e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8578ad4a4640571697ce81565f288b5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_ZSTD_CALL_BT_SEARCH_FN</b>(dictMode,  mls)</td></tr>
<tr class="separator:a8578ad4a4640571697ce81565f288b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1fae60a5508aa31711503852639ae6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_ZSTD_CALL_HC_SEARCH_FN</b>(dictMode,  mls)</td></tr>
<tr class="separator:a3e1fae60a5508aa31711503852639ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ca772638f5266abbaadeaa52cdf14e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_ZSTD_CALL_ROW_SEARCH_FN</b>(dictMode,  mls,  rowLog)</td></tr>
<tr class="separator:a87ca772638f5266abbaadeaa52cdf14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ee65bfaa76923eb488b3c9744e32c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SWITCH_MLS</b>(X,  dictMode)</td></tr>
<tr class="separator:a88ee65bfaa76923eb488b3c9744e32c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabf5fcc28053ac45e9f1655e1248a2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SWITCH_ROWLOG</b>(dictMode,  mls)</td></tr>
<tr class="separator:acabf5fcc28053ac45e9f1655e1248a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588737348fea750852bb6911c5209091"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SWITCH_SEARCH_METHOD</b>(dictMode)</td></tr>
<tr class="separator:a588737348fea750852bb6911c5209091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd7a180139a0f29354f8fdb3698c811"><td class="memItemLeft" align="right" valign="top"><a id="a1bd7a180139a0f29354f8fdb3698c811"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LDM_GEARTAB_H</b></td></tr>
<tr class="separator:a1bd7a180139a0f29354f8fdb3698c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1e6de5198e3c74589cfe5ef73e412a"><td class="memItemLeft" align="right" valign="top"><a id="a5e1e6de5198e3c74589cfe5ef73e412a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LDM_BUCKET_SIZE_LOG</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a5e1e6de5198e3c74589cfe5ef73e412a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc36f7a4b744b69414889a987578ed68"><td class="memItemLeft" align="right" valign="top"><a id="abc36f7a4b744b69414889a987578ed68"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LDM_MIN_MATCH_LENGTH</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:abc36f7a4b744b69414889a987578ed68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8388eda1ab573f49cf3c50293ba7366a"><td class="memItemLeft" align="right" valign="top"><a id="a8388eda1ab573f49cf3c50293ba7366a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LDM_HASH_RLOG</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a8388eda1ab573f49cf3c50293ba7366a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56509bc2b926bcbb48d979a907650957"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEAR_ITER_ONCE</b>()</td></tr>
<tr class="separator:a56509bc2b926bcbb48d979a907650957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56509bc2b926bcbb48d979a907650957"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEAR_ITER_ONCE</b>()</td></tr>
<tr class="separator:a56509bc2b926bcbb48d979a907650957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b641c682489a410e2e2db93c47980f"><td class="memItemLeft" align="right" valign="top"><a id="a42b641c682489a410e2e2db93c47980f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LITFREQ_ADD</b>&#160;&#160;&#160;2   /* scaling factor for litFreq, so that frequencies adapt faster to new stats */</td></tr>
<tr class="separator:a42b641c682489a410e2e2db93c47980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd7ee5ba4ae5b1782f13ca0dfe19dfb"><td class="memItemLeft" align="right" valign="top"><a id="acfd7ee5ba4ae5b1782f13ca0dfe19dfb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MAX_PRICE</b>&#160;&#160;&#160;(1&lt;&lt;30)</td></tr>
<tr class="separator:acfd7ee5ba4ae5b1782f13ca0dfe19dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefbc197126ba373b76907b9e2ad8838"><td class="memItemLeft" align="right" valign="top"><a id="afefbc197126ba373b76907b9e2ad8838"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_PREDEF_THRESHOLD</b>&#160;&#160;&#160;8   /* if srcSize &lt; ZSTD_PREDEF_THRESHOLD, symbols' cost is assumed static, directly determined by pre-defined distributions */</td></tr>
<tr class="separator:afefbc197126ba373b76907b9e2ad8838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04df4b86229a37d12c1f846c79363e7e"><td class="memItemLeft" align="right" valign="top"><a id="a04df4b86229a37d12c1f846c79363e7e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BITCOST_ACCURACY</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a04df4b86229a37d12c1f846c79363e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e91cb7ab586aff076a953abee3137b"><td class="memItemLeft" align="right" valign="top"><a id="a76e91cb7ab586aff076a953abee3137b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BITCOST_MULTIPLIER</b>&#160;&#160;&#160;(1 &lt;&lt; BITCOST_ACCURACY)</td></tr>
<tr class="separator:a76e91cb7ab586aff076a953abee3137b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2321e6c7d439930bcd1c963f6bc50acf"><td class="memItemLeft" align="right" valign="top"><a id="a2321e6c7d439930bcd1c963f6bc50acf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WEIGHT</b>(stat,  opt)&#160;&#160;&#160;((opt) ? ZSTD_fracWeight(stat) : ZSTD_bitWeight(stat))</td></tr>
<tr class="separator:a2321e6c7d439930bcd1c963f6bc50acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4830f1252cfb7cd4bb62270bc5509c2d"><td class="memItemLeft" align="right" valign="top"><a id="a4830f1252cfb7cd4bb62270bc5509c2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BT_GET_ALL_MATCHES_FN</b>(dictMode,  mls)&#160;&#160;&#160;ZSTD_btGetAllMatches_##dictMode##_##mls</td></tr>
<tr class="separator:a4830f1252cfb7cd4bb62270bc5509c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc439e25ecfa944daf03ede7de7625b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_ZSTD_BT_GET_ALL_MATCHES_</b>(dictMode,  mls)</td></tr>
<tr class="separator:afc439e25ecfa944daf03ede7de7625b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd07beaddf4da6a68495d676a653d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GEN_ZSTD_BT_GET_ALL_MATCHES</b>(dictMode)</td></tr>
<tr class="separator:a64dd07beaddf4da6a68495d676a653d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada15a7370caf4a213b66c33b685f33f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BT_GET_ALL_MATCHES_ARRAY</b>(dictMode)</td></tr>
<tr class="separator:aada15a7370caf4a213b66c33b685f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0980053af401fe1d9877f571159a3583"><td class="memItemLeft" align="right" valign="top"><a id="a0980053af401fe1d9877f571159a3583"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LIT_PRICE</b>(_p)&#160;&#160;&#160;(int)ZSTD_rawLiteralsCost(_p, 1, optStatePtr, optLevel)</td></tr>
<tr class="separator:a0980053af401fe1d9877f571159a3583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22393f44cf3dad7054a9f1f27d9fb4a6"><td class="memItemLeft" align="right" valign="top"><a id="a22393f44cf3dad7054a9f1f27d9fb4a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LL_PRICE</b>(_l)&#160;&#160;&#160;(int)ZSTD_litLengthPrice(_l, optStatePtr, optLevel)</td></tr>
<tr class="separator:a22393f44cf3dad7054a9f1f27d9fb4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96dc8ad194e274c463ec11607f4035"><td class="memItemLeft" align="right" valign="top"><a id="a4e96dc8ad194e274c463ec11607f4035"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LL_INCPRICE</b>(_l)&#160;&#160;&#160;(LL_PRICE(_l) - LL_PRICE(_l-1))</td></tr>
<tr class="separator:a4e96dc8ad194e274c463ec11607f4035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f090a8f6e5fe4a707a4b12b270ed70"><td class="memItemLeft" align="right" valign="top"><a id="a80f090a8f6e5fe4a707a4b12b270ed70"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_RESIZE_SEQPOOL</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a80f090a8f6e5fe4a707a4b12b270ed70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ededaeedbd332d69d237752f75d5b0"><td class="memItemLeft" align="right" valign="top"><a id="a58ededaeedbd332d69d237752f75d5b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_PTHREAD_MUTEX_LOCK</b>(m)&#160;&#160;&#160;ZSTD_pthread_mutex_lock(m)</td></tr>
<tr class="separator:a58ededaeedbd332d69d237752f75d5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c7e97b01ab5c0123dc60dc2eeb0316"><td class="memItemLeft" align="right" valign="top"><a id="a91c7e97b01ab5c0123dc60dc2eeb0316"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEBUG_PRINTHEX</b>(l,  p,  n)&#160;&#160;&#160;do { } while (0)</td></tr>
<tr class="separator:a91c7e97b01ab5c0123dc60dc2eeb0316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de9b25f8ea4e67338cf81663e302042"><td class="memItemLeft" align="right" valign="top"><a id="a6de9b25f8ea4e67338cf81663e302042"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUF_POOL_MAX_NB_BUFFERS</b>(nbWorkers)&#160;&#160;&#160;(2*(nbWorkers) + 3)</td></tr>
<tr class="separator:a6de9b25f8ea4e67338cf81663e302042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1062dc7e3c67eab12ae49cd71a2047f"><td class="memItemLeft" align="right" valign="top"><a id="aa1062dc7e3c67eab12ae49cd71a2047f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEQ_POOL_MAX_NB_BUFFERS</b>(nbWorkers)&#160;&#160;&#160;(nbWorkers)</td></tr>
<tr class="separator:aa1062dc7e3c67eab12ae49cd71a2047f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c4c67a29e924ad5c996621dddd866e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>JOB_ERROR</b>(e)</td></tr>
<tr class="separator:ab2c4c67a29e924ad5c996621dddd866e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc39d3e291540ea7569e1e4f2428894c"><td class="memItemLeft" align="right" valign="top"><a id="afc39d3e291540ea7569e1e4f2428894c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RSYNC_LENGTH</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:afc39d3e291540ea7569e1e4f2428894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d96d3c4abf30210f7c1df966ebf51c"><td class="memItemLeft" align="right" valign="top"><a id="a89d96d3c4abf30210f7c1df966ebf51c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RSYNC_MIN_BLOCK_LOG</b>&#160;&#160;&#160;ZSTD_BLOCKSIZELOG_MAX</td></tr>
<tr class="separator:a89d96d3c4abf30210f7c1df966ebf51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7798a96dd0680479429668cff73e5abb"><td class="memItemLeft" align="right" valign="top"><a id="a7798a96dd0680479429668cff73e5abb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RSYNC_MIN_BLOCK_SIZE</b>&#160;&#160;&#160;(1&lt;&lt;RSYNC_MIN_BLOCK_LOG)</td></tr>
<tr class="separator:a7798a96dd0680479429668cff73e5abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e322667dffa0414fffe4a1b227367b"><td class="memItemLeft" align="right" valign="top"><a id="a27e322667dffa0414fffe4a1b227367b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DECODER_FAST_TABLELOG</b>&#160;&#160;&#160;11</td></tr>
<tr class="separator:a27e322667dffa0414fffe4a1b227367b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825a0223296e79e41d16f912dc027585"><td class="memItemLeft" align="right" valign="top"><a id="a825a0223296e79e41d16f912dc027585"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_ENABLE_FAST_DECODE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a825a0223296e79e41d16f912dc027585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa82c6ad5cf51adcd7b81ad0170b773a"><td class="memItemLeft" align="right" valign="top"><a id="afa82c6ad5cf51adcd7b81ad0170b773a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_FAST_BMI2_ATTRS</b></td></tr>
<tr class="separator:afa82c6ad5cf51adcd7b81ad0170b773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d68f15af410ff927277970996858d5"><td class="memItemLeft" align="right" valign="top"><a id="a60d68f15af410ff927277970996858d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_EXTERN_C</b></td></tr>
<tr class="separator:a60d68f15af410ff927277970996858d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fd764dc5a3dad6b363066c7f868117"><td class="memItemLeft" align="right" valign="top"><a id="ad7fd764dc5a3dad6b363066c7f868117"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_ASM_DECL</b>&#160;&#160;&#160;HUF_EXTERN_C</td></tr>
<tr class="separator:ad7fd764dc5a3dad6b363066c7f868117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a54467c05c5a4f1fdb26d5a5443c38d"><td class="memItemLeft" align="right" valign="top"><a id="a8a54467c05c5a4f1fdb26d5a5443c38d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_NEED_BMI2_FUNCTION</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a8a54467c05c5a4f1fdb26d5a5443c38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2de9e4837283ff6a5d5f4e2f43c6fed"><td class="memItemLeft" align="right" valign="top"><a id="ad2de9e4837283ff6a5d5f4e2f43c6fed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_isError</b>&#160;&#160;&#160;ERR_isError</td></tr>
<tr class="separator:ad2de9e4837283ff6a5d5f4e2f43c6fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb71de463c33862db9de1d10381f0cee"><td class="memItemLeft" align="right" valign="top"><a id="abb71de463c33862db9de1d10381f0cee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_ALIGN</b>(x,  a)&#160;&#160;&#160;HUF_ALIGN_MASK((x), (a) - 1)</td></tr>
<tr class="separator:abb71de463c33862db9de1d10381f0cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f9de1b222183b948bc9d7b3f2ef5ee"><td class="memItemLeft" align="right" valign="top"><a id="ae9f9de1b222183b948bc9d7b3f2ef5ee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_ALIGN_MASK</b>(x,  mask)&#160;&#160;&#160;(((x) + (mask)) &amp; ~(mask))</td></tr>
<tr class="separator:ae9f9de1b222183b948bc9d7b3f2ef5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd87bf8b42c4c3019dc2f7a791413324"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DGEN</b>(fn)</td></tr>
<tr class="separator:afd87bf8b42c4c3019dc2f7a791413324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ab687170c52a99e46c97eb4146716e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_4X_FOR_EACH_STREAM</b>(X)</td></tr>
<tr class="separator:af6ab687170c52a99e46c97eb4146716e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14031e18cb0e5db79b926c5496ea3e54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_4X_FOR_EACH_STREAM_WITH_VAR</b>(X,  var)</td></tr>
<tr class="separator:a14031e18cb0e5db79b926c5496ea3e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ce7a6c8455788c3a85811b74ff872b"><td class="memItemLeft" align="right" valign="top"><a id="ab3ce7a6c8455788c3a85811b74ff872b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DECODE_SYMBOLX1_0</b>(ptr,  DStreamPtr)&#160;&#160;&#160;    do { *ptr++ = HUF_decodeSymbolX1(DStreamPtr, dt, dtLog); } while (0)</td></tr>
<tr class="separator:ab3ce7a6c8455788c3a85811b74ff872b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a54d650c2e417f7a6749b7d7d74bad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DECODE_SYMBOLX1_1</b>(ptr,  DStreamPtr)</td></tr>
<tr class="separator:ab3a54d650c2e417f7a6749b7d7d74bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e793a95f36aa83bb79ce55a8af38e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DECODE_SYMBOLX1_2</b>(ptr,  DStreamPtr)</td></tr>
<tr class="separator:aa4e793a95f36aa83bb79ce55a8af38e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fc7098e3af2259340c4b3aba021311"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_4X1_DECODE_SYMBOL</b>(_stream,  _symbol)</td></tr>
<tr class="separator:ac3fc7098e3af2259340c4b3aba021311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e23f0dcb7ee25c87df681de6cf77fbb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_4X1_RELOAD_STREAM</b>(_stream)</td></tr>
<tr class="separator:a7e23f0dcb7ee25c87df681de6cf77fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ec4b1a99585daebab7622e6e0e4c2a"><td class="memItemLeft" align="right" valign="top"><a id="ab6ec4b1a99585daebab7622e6e0e4c2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DECODE_SYMBOLX2_0</b>(ptr,  DStreamPtr)&#160;&#160;&#160;    do { ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog); } while (0)</td></tr>
<tr class="separator:ab6ec4b1a99585daebab7622e6e0e4c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15066482875cf0319e2e6bb3a40b8068"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DECODE_SYMBOLX2_1</b>(ptr,  DStreamPtr)</td></tr>
<tr class="separator:a15066482875cf0319e2e6bb3a40b8068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea95c215cac5c21be278fc548db6943"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DECODE_SYMBOLX2_2</b>(ptr,  DStreamPtr)</td></tr>
<tr class="separator:acea95c215cac5c21be278fc548db6943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b29630c73a36ed0e5dea387e52ae1b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_4X2_DECODE_SYMBOL</b>(_stream,  _decode3)</td></tr>
<tr class="separator:a6b29630c73a36ed0e5dea387e52ae1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6ea1f358be924204b8467b5fbc9548"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_4X2_RELOAD_STREAM</b>(_stream)</td></tr>
<tr class="separator:afd6ea1f358be924204b8467b5fbc9548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbf30f343554353438eb952ef468706"><td class="memItemLeft" align="right" valign="top"><a id="a5cbf30f343554353438eb952ef468706"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DECOMPRESS_INTERNAL_H</b></td></tr>
<tr class="separator:a5cbf30f343554353438eb952ef468706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4c72cea91ffb3648e05a4ae67c531c"><td class="memItemLeft" align="right" valign="top"><a id="a2d4c72cea91ffb3648e05a4ae67c531c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEQSYMBOL_TABLE_SIZE</b>(log)&#160;&#160;&#160;(1 + (1 &lt;&lt; (log)))</td></tr>
<tr class="separator:a2d4c72cea91ffb3648e05a4ae67c531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86dfaa9c16f86b6815fc5429a379f79"><td class="memItemLeft" align="right" valign="top"><a id="aa86dfaa9c16f86b6815fc5429a379f79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BUILD_FSE_TABLE_WKSP_SIZE</b>&#160;&#160;&#160;(sizeof(S16) * (MaxSeq + 1) + (1u &lt;&lt; MaxFSELog) + sizeof(U64))</td></tr>
<tr class="separator:aa86dfaa9c16f86b6815fc5429a379f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c34c031f2abf643a762cff77dc6fad2"><td class="memItemLeft" align="right" valign="top"><a id="a1c34c031f2abf643a762cff77dc6fad2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BUILD_FSE_TABLE_WKSP_SIZE_U32</b>&#160;&#160;&#160;((ZSTD_BUILD_FSE_TABLE_WKSP_SIZE + sizeof(U32) - 1) / sizeof(U32))</td></tr>
<tr class="separator:a1c34c031f2abf643a762cff77dc6fad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da40c4a05b6930c12b6aa3e392687a7"><td class="memItemLeft" align="right" valign="top"><a id="a7da40c4a05b6930c12b6aa3e392687a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HUFFDTABLE_CAPACITY_LOG</b>&#160;&#160;&#160;12</td></tr>
<tr class="separator:a7da40c4a05b6930c12b6aa3e392687a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0916fdabc60f59797f1c51682b2a477e"><td class="memItemLeft" align="right" valign="top"><a id="a0916fdabc60f59797f1c51682b2a477e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DECODER_INTERNAL_BUFFER</b>&#160;&#160;&#160;(1 &lt;&lt; 16)</td></tr>
<tr class="separator:a0916fdabc60f59797f1c51682b2a477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fbf1b473960c134c80105ec08fdb58"><td class="memItemLeft" align="right" valign="top"><a id="a15fbf1b473960c134c80105ec08fdb58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LBMIN</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a15fbf1b473960c134c80105ec08fdb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad390158aacafdd70acdcfd145b74ece9"><td class="memItemLeft" align="right" valign="top"><a id="ad390158aacafdd70acdcfd145b74ece9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LBMAX</b>&#160;&#160;&#160;(128 &lt;&lt; 10)</td></tr>
<tr class="separator:ad390158aacafdd70acdcfd145b74ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f3a1c2bca503fda043ce9f2a82a8bf"><td class="memItemLeft" align="right" valign="top"><a id="a47f3a1c2bca503fda043ce9f2a82a8bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LITBUFFEREXTRASIZE</b>&#160;&#160;&#160;BOUNDED(ZSTD_LBMIN, ZSTD_DECODER_INTERNAL_BUFFER, ZSTD_LBMAX)</td></tr>
<tr class="separator:a47f3a1c2bca503fda043ce9f2a82a8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0f703d761f4580906dbca3062ae03e"><td class="memItemLeft" align="right" valign="top"><a id="a8d0f703d761f4580906dbca3062ae03e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DDICT_H</b></td></tr>
<tr class="separator:a8d0f703d761f4580906dbca3062ae03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace94e70b03794a8b0f63343d98eb6aed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ace94e70b03794a8b0f63343d98eb6aed">ZSTD_HEAPMODE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ace94e70b03794a8b0f63343d98eb6aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe07180770b02bc7cc991a73aabe0275"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#afe07180770b02bc7cc991a73aabe0275">ZSTD_MAXWINDOWSIZE_DEFAULT</a>&#160;&#160;&#160;(((U32)1 &lt;&lt; ZSTD_WINDOWLOG_LIMIT_DEFAULT) + 1)</td></tr>
<tr class="separator:afe07180770b02bc7cc991a73aabe0275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ca6fc4844082acd5e6d4b14608f519"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae5ca6fc4844082acd5e6d4b14608f519">ZSTD_NO_FORWARD_PROGRESS_MAX</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ae5ca6fc4844082acd5e6d4b14608f519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6df3eb584290dd291bac9cebfce7740"><td class="memItemLeft" align="right" valign="top"><a id="af6df3eb584290dd291bac9cebfce7740"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DEC_BLOCK_H</b></td></tr>
<tr class="separator:af6df3eb584290dd291bac9cebfce7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a98e898833db8f8bfaa1e2afb41fad8"><td class="memItemLeft" align="right" valign="top"><a id="a6a98e898833db8f8bfaa1e2afb41fad8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DDICT_HASHSET_MAX_LOAD_FACTOR_COUNT_MULT</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a6a98e898833db8f8bfaa1e2afb41fad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2fba659546f9d0a7e51d2ca3370904"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT</b></td></tr>
<tr class="separator:aea2fba659546f9d0a7e51d2ca3370904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747447c342a705e9d92778d15d0644eb"><td class="memItemLeft" align="right" valign="top"><a id="a747447c342a705e9d92778d15d0644eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DDICT_HASHSET_TABLE_BASE_SIZE</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a747447c342a705e9d92778d15d0644eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7a315a0de9ec17303c075d3f3d4df5"><td class="memItemLeft" align="right" valign="top"><a id="abe7a315a0de9ec17303c075d3f3d4df5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DDICT_HASHSET_RESIZE_FACTOR</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:abe7a315a0de9ec17303c075d3f3d4df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa81cb2c87554acff0e8913b29598f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHECK_DBOUNDS</b>(p,  v)</td></tr>
<tr class="separator:a1fa81cb2c87554acff0e8913b29598f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a6fcfd814db079898717019641487"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a6fcfd814db079898717019641487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a0d2a6fcfd814db079898717019641487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f15eba9f3c2667ddc4b2a5ce7782e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>LONG_OFFSETS_MAX_EXTRA_BITS_32</b></td></tr>
<tr class="separator:ac9f15eba9f3c2667ddc4b2a5ce7782e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adca1c8d0ffbbd88b65ed72a88acebe"><td class="memItemLeft" align="right" valign="top"><a id="a7adca1c8d0ffbbd88b65ed72a88acebe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORED_SEQS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a7adca1c8d0ffbbd88b65ed72a88acebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c3ee3188e54918d3ac93a6e2cf30c0"><td class="memItemLeft" align="right" valign="top"><a id="aa6c3ee3188e54918d3ac93a6e2cf30c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORED_SEQS_MASK</b>&#160;&#160;&#160;(STORED_SEQS-1)</td></tr>
<tr class="separator:aa6c3ee3188e54918d3ac93a6e2cf30c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2247dbdc787036f531e8eaebb773f99a"><td class="memItemLeft" align="right" valign="top"><a id="a2247dbdc787036f531e8eaebb773f99a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADVANCED_SEQS</b>&#160;&#160;&#160;STORED_SEQS</td></tr>
<tr class="separator:a2247dbdc787036f531e8eaebb773f99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a104b2e349617222c6419b36bfd3260"><td class="memItemLeft" align="right" valign="top"><a id="a7a104b2e349617222c6419b36bfd3260"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__STDC_WANT_LIB_EXT1__</b>&#160;&#160;&#160;1 /* request C11 Annex K, which includes qsort_s() */</td></tr>
<tr class="separator:a7a104b2e349617222c6419b36bfd3260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a585a357b2e71e8ece2ee1ee510b7f"><td class="memItemLeft" align="right" valign="top"><a id="a67a585a357b2e71e8ece2ee1ee510b7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_STATIC_LINKING_ONLY</b></td></tr>
<tr class="separator:a67a585a357b2e71e8ece2ee1ee510b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46ddf11060e8cec0537902c85ccab82"><td class="memItemLeft" align="right" valign="top"><a id="ad46ddf11060e8cec0537902c85ccab82"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ZDICT_H</b></td></tr>
<tr class="separator:ad46ddf11060e8cec0537902c85ccab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cda98a2851cd45c68f8dbb01bca817"><td class="memItemLeft" align="right" valign="top"><a id="a56cda98a2851cd45c68f8dbb01bca817"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICTLIB_VISIBLE</b></td></tr>
<tr class="separator:a56cda98a2851cd45c68f8dbb01bca817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19d4b077083b4678abac66064c61bfe"><td class="memItemLeft" align="right" valign="top"><a id="ae19d4b077083b4678abac66064c61bfe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICTLIB_HIDDEN</b></td></tr>
<tr class="separator:ae19d4b077083b4678abac66064c61bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d66f6fa869d547a12ef20ecc247d11"><td class="memItemLeft" align="right" valign="top"><a id="a31d66f6fa869d547a12ef20ecc247d11"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICTLIB_API</b>&#160;&#160;&#160;ZDICTLIB_VISIBLE</td></tr>
<tr class="separator:a31d66f6fa869d547a12ef20ecc247d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d7b252ed5bb8380f32aaba2775405"><td class="memItemLeft" align="right" valign="top"><a id="a1f8d7b252ed5bb8380f32aaba2775405"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ZDICT_H_STATIC</b></td></tr>
<tr class="separator:a1f8d7b252ed5bb8380f32aaba2775405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2770f8db1e12181d9837f22fbe4df356"><td class="memItemLeft" align="right" valign="top"><a id="a2770f8db1e12181d9837f22fbe4df356"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICTLIB_STATIC_API</b>&#160;&#160;&#160;ZDICTLIB_VISIBLE</td></tr>
<tr class="separator:a2770f8db1e12181d9837f22fbe4df356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45effdab9162ff505f8e7f2172150539"><td class="memItemLeft" align="right" valign="top"><a id="a45effdab9162ff505f8e7f2172150539"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_DICTSIZE_MIN</b>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a45effdab9162ff505f8e7f2172150539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7059f11782f76ff2e041a6f601241759"><td class="memItemLeft" align="right" valign="top"><a id="a7059f11782f76ff2e041a6f601241759"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_CONTENTSIZE_MIN</b>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a7059f11782f76ff2e041a6f601241759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e98cb14ceb3bb607a2fab672c31885a"><td class="memItemLeft" align="right" valign="top"><a id="a9e98cb14ceb3bb607a2fab672c31885a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_GCC_VERSION</b>&#160;&#160;&#160;(__GNUC__ * 100 + __GNUC_MINOR__)</td></tr>
<tr class="separator:a9e98cb14ceb3bb607a2fab672c31885a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cc4a0bb5e3aff924dfc69351aca8a9"><td class="memItemLeft" align="right" valign="top"><a id="a15cc4a0bb5e3aff924dfc69351aca8a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_DEPRECATED</b>(message)</td></tr>
<tr class="separator:a15cc4a0bb5e3aff924dfc69351aca8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ef013382bb52ccf53195231c5f5383"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa8ef013382bb52ccf53195231c5f5383">COVER_MAX_SAMPLES_SIZE</a>&#160;&#160;&#160;(sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 GB))</td></tr>
<tr class="separator:aa8ef013382bb52ccf53195231c5f5383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a9ef609526949b48beb4cc55b84d1f"><td class="memItemLeft" align="right" valign="top"><a id="a18a9ef609526949b48beb4cc55b84d1f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COVER_DEFAULT_SPLITPOINT</b>&#160;&#160;&#160;1.0</td></tr>
<tr class="separator:a18a9ef609526949b48beb4cc55b84d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edce797c3674d73fd0f9e7735c9ff4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3edce797c3674d73fd0f9e7735c9ff4a">ZDICT_QSORT_MIN</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a3edce797c3674d73fd0f9e7735c9ff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81379fe6c23e87e25beb5060a7589ce"><td class="memItemLeft" align="right" valign="top"><a id="af81379fe6c23e87e25beb5060a7589ce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_QSORT_C90</b>&#160;&#160;&#160;<a class="el" href="zstd_8c.html#a3edce797c3674d73fd0f9e7735c9ff4a">ZDICT_QSORT_MIN</a></td></tr>
<tr class="separator:af81379fe6c23e87e25beb5060a7589ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a038ae6d1bf8910faaadeac335b011"><td class="memItemLeft" align="right" valign="top"><a id="ac3a038ae6d1bf8910faaadeac335b011"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_QSORT_GNU</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ac3a038ae6d1bf8910faaadeac335b011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fe93089757c120f1126c0bc454a746"><td class="memItemLeft" align="right" valign="top"><a id="a22fe93089757c120f1126c0bc454a746"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_QSORT_APPLE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a22fe93089757c120f1126c0bc454a746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f15936c338ce9c4d929bf7cef9a742"><td class="memItemLeft" align="right" valign="top"><a id="a98f15936c338ce9c4d929bf7cef9a742"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_QSORT_MSVC</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a98f15936c338ce9c4d929bf7cef9a742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d886df22e9470ba6c7349dd49cdd9d6"><td class="memItemLeft" align="right" valign="top"><a id="a1d886df22e9470ba6c7349dd49cdd9d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_QSORT_C11</b>&#160;&#160;&#160;ZDICT_QSORT_MAX</td></tr>
<tr class="separator:a1d886df22e9470ba6c7349dd49cdd9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9c02982fb51fa87f358c0aa206387"><td class="memItemLeft" align="right" valign="top"><a id="ae5c9c02982fb51fa87f358c0aa206387"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_QSORT_MAX</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ae5c9c02982fb51fa87f358c0aa206387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c0e415678e4d60c96463632b3a88a0"><td class="memItemLeft" align="right" valign="top"><a id="a31c0e415678e4d60c96463632b3a88a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_QSORT</b>&#160;&#160;&#160;ZDICT_QSORT_C90 /* uses standard qsort() which is not re-entrant (requires global variable) */</td></tr>
<tr class="separator:a31c0e415678e4d60c96463632b3a88a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5fbd7a78051c2134b21324e5c74bdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAY</b>(...)</td></tr>
<tr class="separator:a5a5fbd7a78051c2134b21324e5c74bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9200da68a37a9ae33332f82599d00e67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAYLEVEL</b>(l, ...)</td></tr>
<tr class="separator:a9200da68a37a9ae33332f82599d00e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0582ae4feec24e372a1a42811e4bfd97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAYUPDATE</b>(lastUpdateTime,  l, ...)</td></tr>
<tr class="separator:a0582ae4feec24e372a1a42811e4bfd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b4996591f7bb7fd5977a1d05397246"><td class="memItemLeft" align="right" valign="top"><a id="a77b4996591f7bb7fd5977a1d05397246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_EMPTY_VALUE</b>&#160;&#160;&#160;((U32)-1)</td></tr>
<tr class="separator:a77b4996591f7bb7fd5977a1d05397246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ca69d7c9700c58815b631e252574d"><td class="memItemLeft" align="right" valign="top"><a id="ab35ca69d7c9700c58815b631e252574d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_DIVSUFSORT_H</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ab35ca69d7c9700c58815b631e252574d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb6f9e0395b47b8d5e3eeae4fe0c116"><td class="memItemLeft" align="right" valign="top"><a id="a2eb6f9e0395b47b8d5e3eeae4fe0c116"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INLINE</b>&#160;&#160;&#160;__inline</td></tr>
<tr class="separator:a2eb6f9e0395b47b8d5e3eeae4fe0c116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6572f1706059832f94025fa12c6c45ed"><td class="memItemLeft" align="right" valign="top"><a id="a6572f1706059832f94025fa12c6c45ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ALPHABET_SIZE</b>&#160;&#160;&#160;(256)</td></tr>
<tr class="separator:a6572f1706059832f94025fa12c6c45ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1b403a53af4084a579cbae01e7f34c"><td class="memItemLeft" align="right" valign="top"><a id="a5f1b403a53af4084a579cbae01e7f34c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUCKET_A_SIZE</b>&#160;&#160;&#160;(ALPHABET_SIZE)</td></tr>
<tr class="separator:a5f1b403a53af4084a579cbae01e7f34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c54022c6abbad80d3a5decad9a5f6d"><td class="memItemLeft" align="right" valign="top"><a id="a65c54022c6abbad80d3a5decad9a5f6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUCKET_B_SIZE</b>&#160;&#160;&#160;(ALPHABET_SIZE * ALPHABET_SIZE)</td></tr>
<tr class="separator:a65c54022c6abbad80d3a5decad9a5f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a858f398400eb7a9ac22713f3553feb"><td class="memItemLeft" align="right" valign="top"><a id="a5a858f398400eb7a9ac22713f3553feb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SS_INSERTIONSORT_THRESHOLD</b>&#160;&#160;&#160;(8)</td></tr>
<tr class="separator:a5a858f398400eb7a9ac22713f3553feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cd223b2c9a4cbf647274d46a45a733"><td class="memItemLeft" align="right" valign="top"><a id="a08cd223b2c9a4cbf647274d46a45a733"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SS_BLOCKSIZE</b>&#160;&#160;&#160;(1024)</td></tr>
<tr class="separator:a08cd223b2c9a4cbf647274d46a45a733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ff4283b0f558f524273900e3eaac08"><td class="memItemLeft" align="right" valign="top"><a id="a81ff4283b0f558f524273900e3eaac08"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SS_MISORT_STACKSIZE</b>&#160;&#160;&#160;(16)</td></tr>
<tr class="separator:a81ff4283b0f558f524273900e3eaac08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738e9cfc278fe48fb08c8657e3afd878"><td class="memItemLeft" align="right" valign="top"><a id="a738e9cfc278fe48fb08c8657e3afd878"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SS_SMERGE_STACKSIZE</b>&#160;&#160;&#160;(32)</td></tr>
<tr class="separator:a738e9cfc278fe48fb08c8657e3afd878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e941a787219c4a650618035b4dc61f"><td class="memItemLeft" align="right" valign="top"><a id="a17e941a787219c4a650618035b4dc61f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_INSERTIONSORT_THRESHOLD</b>&#160;&#160;&#160;(8)</td></tr>
<tr class="separator:a17e941a787219c4a650618035b4dc61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1364e4e63b8ed23692eb50321e597138"><td class="memItemLeft" align="right" valign="top"><a id="a1364e4e63b8ed23692eb50321e597138"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_STACKSIZE</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="separator:a1364e4e63b8ed23692eb50321e597138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5107c7781c3e326264fa507ddde22d47"><td class="memItemLeft" align="right" valign="top"><a id="a5107c7781c3e326264fa507ddde22d47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SWAP</b>(_a,  _b)&#160;&#160;&#160;do { t = (_a); (_a) = (_b); (_b) = t; } while(0)</td></tr>
<tr class="separator:a5107c7781c3e326264fa507ddde22d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74e4c4355110af960d47f5f8fc180c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>STACK_PUSH</b>(_a,  _b,  _c,  _d)</td></tr>
<tr class="separator:ad74e4c4355110af960d47f5f8fc180c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c46c22837b2f21a9b4781f81a88bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>STACK_PUSH5</b>(_a,  _b,  _c,  _d,  _e)</td></tr>
<tr class="separator:a0f8c46c22837b2f21a9b4781f81a88bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f1ff1ac325c41f23cc15bef5422485"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>STACK_POP</b>(_a,  _b,  _c,  _d)</td></tr>
<tr class="separator:a88f1ff1ac325c41f23cc15bef5422485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087bacc2e0ad4bbb8fe7dca57662fb5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>STACK_POP5</b>(_a,  _b,  _c,  _d,  _e)</td></tr>
<tr class="separator:a087bacc2e0ad4bbb8fe7dca57662fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab513d045e5a285866ec209fe4183dc3"><td class="memItemLeft" align="right" valign="top"><a id="aab513d045e5a285866ec209fe4183dc3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUCKET_A</b>(_c0)&#160;&#160;&#160;bucket_A[(_c0)]</td></tr>
<tr class="separator:aab513d045e5a285866ec209fe4183dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab709a1f5c6d1c1426ef834b13004987a"><td class="memItemLeft" align="right" valign="top"><a id="ab709a1f5c6d1c1426ef834b13004987a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUCKET_B</b>(_c0,  _c1)&#160;&#160;&#160;(bucket_B[((_c1) &lt;&lt; 8) | (_c0)])</td></tr>
<tr class="separator:ab709a1f5c6d1c1426ef834b13004987a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43519a7093bc1c0d5a77870a7c23fba5"><td class="memItemLeft" align="right" valign="top"><a id="a43519a7093bc1c0d5a77870a7c23fba5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUCKET_BSTAR</b>(_c0,  _c1)&#160;&#160;&#160;(bucket_B[((_c0) &lt;&lt; 8) | (_c1)])</td></tr>
<tr class="separator:a43519a7093bc1c0d5a77870a7c23fba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6423a880df59733d2d9b509c7718d3a9"><td class="memItemLeft" align="right" valign="top"><a id="a6423a880df59733d2d9b509c7718d3a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STACK_SIZE</b>&#160;&#160;&#160;SS_MISORT_STACKSIZE</td></tr>
<tr class="separator:a6423a880df59733d2d9b509c7718d3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6423a880df59733d2d9b509c7718d3a9"><td class="memItemLeft" align="right" valign="top"><a id="a6423a880df59733d2d9b509c7718d3a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STACK_SIZE</b>&#160;&#160;&#160;SS_SMERGE_STACKSIZE</td></tr>
<tr class="separator:a6423a880df59733d2d9b509c7718d3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243fd08bbc201429305086ac33f2c625"><td class="memItemLeft" align="right" valign="top"><a id="a243fd08bbc201429305086ac33f2c625"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GETIDX</b>(a)&#160;&#160;&#160;((0 &lt;= (a)) ? (a) : (~(a)))</td></tr>
<tr class="separator:a243fd08bbc201429305086ac33f2c625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafe38fb4cdd5d62b74e339bff6ea266"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>MERGE_CHECK</b>(a,  b,  c)</td></tr>
<tr class="separator:aeafe38fb4cdd5d62b74e339bff6ea266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6423a880df59733d2d9b509c7718d3a9"><td class="memItemLeft" align="right" valign="top"><a id="a6423a880df59733d2d9b509c7718d3a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STACK_SIZE</b>&#160;&#160;&#160;TR_STACKSIZE</td></tr>
<tr class="separator:a6423a880df59733d2d9b509c7718d3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9636f8b85954a677e9e429f9ba90f21a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9636f8b85954a677e9e429f9ba90f21a">FASTCOVER_MAX_SAMPLES_SIZE</a>&#160;&#160;&#160;(sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 GB))</td></tr>
<tr class="separator:a9636f8b85954a677e9e429f9ba90f21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2b44127de1a3a52d1c2a420545171a"><td class="memItemLeft" align="right" valign="top"><a id="ace2b44127de1a3a52d1c2a420545171a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FASTCOVER_MAX_F</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:ace2b44127de1a3a52d1c2a420545171a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5496cd8d3d52c13994a31cca42448b"><td class="memItemLeft" align="right" valign="top"><a id="a4a5496cd8d3d52c13994a31cca42448b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FASTCOVER_MAX_ACCEL</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a4a5496cd8d3d52c13994a31cca42448b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc222894aee57f62982d14db1da1defb"><td class="memItemLeft" align="right" valign="top"><a id="afc222894aee57f62982d14db1da1defb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FASTCOVER_DEFAULT_SPLITPOINT</b>&#160;&#160;&#160;0.75</td></tr>
<tr class="separator:afc222894aee57f62982d14db1da1defb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c43093c9826a0e35dafc1ce2e17da29"><td class="memItemLeft" align="right" valign="top"><a id="a5c43093c9826a0e35dafc1ce2e17da29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_F</b>&#160;&#160;&#160;20</td></tr>
<tr class="separator:a5c43093c9826a0e35dafc1ce2e17da29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bbba669e2c198ae9348cdd388335b9"><td class="memItemLeft" align="right" valign="top"><a id="a34bbba669e2c198ae9348cdd388335b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_ACCEL</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a34bbba669e2c198ae9348cdd388335b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5fbd7a78051c2134b21324e5c74bdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAY</b>(...)</td></tr>
<tr class="separator:a5a5fbd7a78051c2134b21324e5c74bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9200da68a37a9ae33332f82599d00e67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAYLEVEL</b>(l, ...)</td></tr>
<tr class="separator:a9200da68a37a9ae33332f82599d00e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0582ae4feec24e372a1a42811e4bfd97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAYUPDATE</b>(lastUpdateTime,  l, ...)</td></tr>
<tr class="separator:a0582ae4feec24e372a1a42811e4bfd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57133343d156b44dae36faf1c45cc3e"><td class="memItemLeft" align="right" valign="top"><a id="ac57133343d156b44dae36faf1c45cc3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MINRATIO</b>&#160;&#160;&#160;4   /* minimum nb of apparition to be selected in dictionary */</td></tr>
<tr class="separator:ac57133343d156b44dae36faf1c45cc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee2f9f4f9cae25be0d2d3978745ca18"><td class="memItemLeft" align="right" valign="top"><a id="a0ee2f9f4f9cae25be0d2d3978745ca18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_MAX_SAMPLES_SIZE</b>&#160;&#160;&#160;(2000U &lt;&lt; 20)</td></tr>
<tr class="separator:a0ee2f9f4f9cae25be0d2d3978745ca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78bb502af0545c63e8669ee1bc7bc33"><td class="memItemLeft" align="right" valign="top"><a id="af78bb502af0545c63e8669ee1bc7bc33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_MIN_SAMPLES_SIZE</b>&#160;&#160;&#160;(ZDICT_CONTENTSIZE_MIN * MINRATIO)</td></tr>
<tr class="separator:af78bb502af0545c63e8669ee1bc7bc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d01ba0a136b8e27ad362f5a823d14e"><td class="memItemLeft" align="right" valign="top"><a id="a44d01ba0a136b8e27ad362f5a823d14e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_FILE_OFFSET_BITS</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a44d01ba0a136b8e27ad362f5a823d14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6d20c5075b52b0f0bc4858d51c8591"><td class="memItemLeft" align="right" valign="top"><a id="a0e6d20c5075b52b0f0bc4858d51c8591"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_LARGEFILE64_SOURCE</b></td></tr>
<tr class="separator:a0e6d20c5075b52b0f0bc4858d51c8591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1841fd1a462d245d8c73dce55e2f45da"><td class="memItemLeft" align="right" valign="top"><a id="a1841fd1a462d245d8c73dce55e2f45da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KB</b>&#160;&#160;&#160;*(1 &lt;&lt;10)</td></tr>
<tr class="separator:a1841fd1a462d245d8c73dce55e2f45da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b38d492364d98453284934ed7caee9"><td class="memItemLeft" align="right" valign="top"><a id="aa6b38d492364d98453284934ed7caee9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MB</b>&#160;&#160;&#160;*(1 &lt;&lt;20)</td></tr>
<tr class="separator:aa6b38d492364d98453284934ed7caee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44172ac633c517cb4c9e278cef36b000"><td class="memItemLeft" align="right" valign="top"><a id="a44172ac633c517cb4c9e278cef36b000"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GB</b>&#160;&#160;&#160;*(1U&lt;&lt;30)</td></tr>
<tr class="separator:a44172ac633c517cb4c9e278cef36b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5b414fec54a38ce919b10c98f271df"><td class="memItemLeft" align="right" valign="top"><a id="afe5b414fec54a38ce919b10c98f271df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DICTLISTSIZE_DEFAULT</b>&#160;&#160;&#160;10000</td></tr>
<tr class="separator:afe5b414fec54a38ce919b10c98f271df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9233bbf304cd8b4c4aa31e1670a45a2f"><td class="memItemLeft" align="right" valign="top"><a id="a9233bbf304cd8b4c4aa31e1670a45a2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NOISELENGTH</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a9233bbf304cd8b4c4aa31e1670a45a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5fbd7a78051c2134b21324e5c74bdc"><td class="memItemLeft" align="right" valign="top"><a id="a5a5fbd7a78051c2134b21324e5c74bdc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAY</b>(...)&#160;&#160;&#160;do { fprintf(stderr, __VA_ARGS__); fflush( stderr ); } while (0)</td></tr>
<tr class="separator:a5a5fbd7a78051c2134b21324e5c74bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9200da68a37a9ae33332f82599d00e67"><td class="memItemLeft" align="right" valign="top"><a id="a9200da68a37a9ae33332f82599d00e67"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAYLEVEL</b>(l, ...)&#160;&#160;&#160;do { if (notificationLevel&gt;=l) { DISPLAY(__VA_ARGS__); } } while (0)    /* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */</td></tr>
<tr class="separator:a9200da68a37a9ae33332f82599d00e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7894d78df8da46cb23d8441c0dc9d9b2"><td class="memItemLeft" align="right" valign="top"><a id="a7894d78df8da46cb23d8441c0dc9d9b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LLIMIT</b>&#160;&#160;&#160;64          /* heuristic determined experimentally */</td></tr>
<tr class="separator:a7894d78df8da46cb23d8441c0dc9d9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f48ae94792012c8ed0256af7d97e7d1"><td class="memItemLeft" align="right" valign="top"><a id="a5f48ae94792012c8ed0256af7d97e7d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MINMATCHLENGTH</b>&#160;&#160;&#160;7   /* heuristic determined experimentally */</td></tr>
<tr class="separator:a5f48ae94792012c8ed0256af7d97e7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fa793cc466bb4f03748de2352e8e8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DISPLAYUPDATE</b>(l, ...)</td></tr>
<tr class="separator:a40fa793cc466bb4f03748de2352e8e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad217948110f3e7f60d04020c9b75f7af"><td class="memItemLeft" align="right" valign="top"><a id="ad217948110f3e7f60d04020c9b75f7af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAXREPOFFSET</b>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:ad217948110f3e7f60d04020c9b75f7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0edf695ddbbbd6be7040665d30f8b26"><td class="memItemLeft" align="right" valign="top"><a id="ac0edf695ddbbbd6be7040665d30f8b26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OFFCODE_MAX</b>&#160;&#160;&#160;30  /* only applicable to first block */</td></tr>
<tr class="separator:ac0edf695ddbbbd6be7040665d30f8b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a40caa7e3e936ab9ce49b927556d28"><td class="memItemLeft" align="right" valign="top"><a id="a08a40caa7e3e936ab9ce49b927556d28"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HBUFFSIZE</b>&#160;&#160;&#160;256   /* should prove large enough for all entropy headers */</td></tr>
<tr class="separator:a08a40caa7e3e936ab9ce49b927556d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4ae1dab0fb4b072a66584546209e7d58"><td class="memItemLeft" align="right" valign="top"><a id="a4ae1dab0fb4b072a66584546209e7d58"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>BYTE</b></td></tr>
<tr class="separator:a4ae1dab0fb4b072a66584546209e7d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb25ca6f51f003950f9625ff05536fc"><td class="memItemLeft" align="right" valign="top"><a id="a3cb25ca6f51f003950f9625ff05536fc"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>U8</b></td></tr>
<tr class="separator:a3cb25ca6f51f003950f9625ff05536fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73359529e867901fff0eabb94f7c3fcf"><td class="memItemLeft" align="right" valign="top"><a id="a73359529e867901fff0eabb94f7c3fcf"></a>
typedef signed char&#160;</td><td class="memItemRight" valign="bottom"><b>S8</b></td></tr>
<tr class="separator:a73359529e867901fff0eabb94f7c3fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf928e51a60dba0df29d615401cc55a8"><td class="memItemLeft" align="right" valign="top"><a id="adf928e51a60dba0df29d615401cc55a8"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>U16</b></td></tr>
<tr class="separator:adf928e51a60dba0df29d615401cc55a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08f9a6ee81e70f713a74a5860062841"><td class="memItemLeft" align="right" valign="top"><a id="ae08f9a6ee81e70f713a74a5860062841"></a>
typedef signed short&#160;</td><td class="memItemRight" valign="bottom"><b>S16</b></td></tr>
<tr class="separator:ae08f9a6ee81e70f713a74a5860062841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3df7cf3c8cb172a588adec881447d68"><td class="memItemLeft" align="right" valign="top"><a id="ac3df7cf3c8cb172a588adec881447d68"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>U32</b></td></tr>
<tr class="separator:ac3df7cf3c8cb172a588adec881447d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a2244776e01ad620c556de58eb7880"><td class="memItemLeft" align="right" valign="top"><a id="a57a2244776e01ad620c556de58eb7880"></a>
typedef signed int&#160;</td><td class="memItemRight" valign="bottom"><b>S32</b></td></tr>
<tr class="separator:a57a2244776e01ad620c556de58eb7880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c386d3758eba951eb7532fdbb45804"><td class="memItemLeft" align="right" valign="top"><a id="a24c386d3758eba951eb7532fdbb45804"></a>
typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>U64</b></td></tr>
<tr class="separator:a24c386d3758eba951eb7532fdbb45804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200f9ca6402de77fd1a6f87db081f0b"><td class="memItemLeft" align="right" valign="top"><a id="a5200f9ca6402de77fd1a6f87db081f0b"></a>
typedef signed long long&#160;</td><td class="memItemRight" valign="bottom"><b>S64</b></td></tr>
<tr class="separator:a5200f9ca6402de77fd1a6f87db081f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcc8966a27ff4b7622fd88006e75b9b"><td class="memItemLeft" align="right" valign="top"><a id="a1fcc8966a27ff4b7622fd88006e75b9b"></a>
typedef ZSTD_ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><b>ERR_enum</b></td></tr>
<tr class="separator:a1fcc8966a27ff4b7622fd88006e75b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dd08a75764e9f6058b47735da04eea"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a></td></tr>
<tr class="separator:a54dd08a75764e9f6058b47735da04eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae791b5272655c08c187054dde72b8aa4"><td class="memItemLeft" align="right" valign="top"><a id="ae791b5272655c08c187054dde72b8aa4"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_DTable</b></td></tr>
<tr class="separator:ae791b5272655c08c187054dde72b8aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf2e5b92eaab796a5d56ecdff6fa59"><td class="memItemLeft" align="right" valign="top"><a id="affdf2e5b92eaab796a5d56ecdff6fa59"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>BitContainerType</b></td></tr>
<tr class="separator:affdf2e5b92eaab796a5d56ecdff6fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8338bf1fc3387a96d7ea076685521582"><td class="memItemLeft" align="right" valign="top"><a id="a8338bf1fc3387a96d7ea076685521582"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_CElt</b></td></tr>
<tr class="separator:a8338bf1fc3387a96d7ea076685521582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5d68d8323833e058b79759ea3a2f99"><td class="memItemLeft" align="right" valign="top"><a id="abf5d68d8323833e058b79759ea3a2f99"></a>
typedef U32&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DTable</b></td></tr>
<tr class="separator:abf5d68d8323833e058b79759ea3a2f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc575a7e1f1afd01e76c0fa98d957d"><td class="memItemLeft" align="right" valign="top"><a id="a9ccc575a7e1f1afd01e76c0fa98d957d"></a>
typedef struct <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CCtx</b></td></tr>
<tr class="separator:a9ccc575a7e1f1afd01e76c0fa98d957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce4435ca683f0e7cb2b90ca9eb1fce4"><td class="memItemLeft" align="right" valign="top"><a id="a9ce4435ca683f0e7cb2b90ca9eb1fce4"></a>
typedef struct <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DCtx</b></td></tr>
<tr class="separator:a9ce4435ca683f0e7cb2b90ca9eb1fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5398613e678b0373333df2c455cc4d"><td class="memItemLeft" align="right" valign="top"><a id="a1c5398613e678b0373333df2c455cc4d"></a>
typedef struct <a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_inBuffer</b></td></tr>
<tr class="separator:a1c5398613e678b0373333df2c455cc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ef076a7b8c7ce6256040a1a033e657"><td class="memItemLeft" align="right" valign="top"><a id="a88ef076a7b8c7ce6256040a1a033e657"></a>
typedef struct <a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_outBuffer</b></td></tr>
<tr class="separator:a88ef076a7b8c7ce6256040a1a033e657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7591551effb218c2750f0f57ba62809a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a></td></tr>
<tr class="separator:a7591551effb218c2750f0f57ba62809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6473440df4dc8a7ce82443825c47df"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a></td></tr>
<tr class="separator:abc6473440df4dc8a7ce82443825c47df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0f8ee84f4ef0190e41b73fd863d8d2"><td class="memItemLeft" align="right" valign="top"><a id="a8f0f8ee84f4ef0190e41b73fd863d8d2"></a>
typedef struct <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CDict</b></td></tr>
<tr class="separator:a8f0f8ee84f4ef0190e41b73fd863d8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34d948830a0684f90121d51d663f9aa"><td class="memItemLeft" align="right" valign="top"><a id="af34d948830a0684f90121d51d663f9aa"></a>
typedef struct <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DDict</b></td></tr>
<tr class="separator:af34d948830a0684f90121d51d663f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b7b9ee91e260a2af7cefce56cc87c1"><td class="memItemLeft" align="right" valign="top"><a id="ae5b7b9ee91e260a2af7cefce56cc87c1"></a>
typedef struct <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CCtx_params</b></td></tr>
<tr class="separator:ae5b7b9ee91e260a2af7cefce56cc87c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb6139b5162a3a74f0d3ae0d7395268"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#adbb6139b5162a3a74f0d3ae0d7395268">ZSTD_allocFunction</a>) (void *opaque, size_t size)</td></tr>
<tr class="separator:adbb6139b5162a3a74f0d3ae0d7395268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb1254efa02eb3c9687035a908c30e1"><td class="memItemLeft" align="right" valign="top"><a id="a4cb1254efa02eb3c9687035a908c30e1"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_freeFunction</b>) (void *opaque, void *address)</td></tr>
<tr class="separator:a4cb1254efa02eb3c9687035a908c30e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa979b4b649aec2c11af1876dcae1590a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structPOOL__ctx__s.html">POOL_ctx_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa979b4b649aec2c11af1876dcae1590a">ZSTD_threadPool</a></td></tr>
<tr class="separator:aa979b4b649aec2c11af1876dcae1590a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e50b1671302ddd36a6b7d4d2e54579"><td class="memItemLeft" align="right" valign="top"><a id="aa6e50b1671302ddd36a6b7d4d2e54579"></a>
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_sequenceProducer_F</b>) (void *sequenceProducerState, <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *outSeqs, size_t outSeqsCapacity, const void *src, size_t srcSize, const void *dict, size_t dictSize, int compressionLevel, size_t windowSize)</td></tr>
<tr class="separator:aa6e50b1671302ddd36a6b7d4d2e54579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace842ea9500966baa959147860dc24f2"><td class="memItemLeft" align="right" valign="top"><a id="ace842ea9500966baa959147860dc24f2"></a>
typedef struct <a class="el" href="structPOOL__ctx__s.html">POOL_ctx_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>POOL_ctx</b></td></tr>
<tr class="separator:ace842ea9500966baa959147860dc24f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f7753ec82fce04c212f38d9c58e61"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a657f7753ec82fce04c212f38d9c58e61">POOL_function</a>) (void *)</td></tr>
<tr class="separator:a657f7753ec82fce04c212f38d9c58e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868cc70e4adeb1c157cbc40f6e44a584"><td class="memItemLeft" align="right" valign="top"><a id="a868cc70e4adeb1c157cbc40f6e44a584"></a>
typedef struct <a class="el" href="structPOOL__job__s.html">POOL_job_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>POOL_job</b></td></tr>
<tr class="separator:a868cc70e4adeb1c157cbc40f6e44a584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0048f07d4a3051c20598464f007aa6c5"><td class="memItemLeft" align="right" valign="top">
typedef struct <a class="el" href="structXXH32__state__s.html">XXH32_state_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_state_t</b></td></tr>
<tr class="separator:ga0048f07d4a3051c20598464f007aa6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0702bdbc80b0cf9e94f2379f7d839b8c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structXXH64__state__s.html">XXH64_state_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a></td></tr>
<tr class="memdesc:ga0702bdbc80b0cf9e94f2379f7d839b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opaque state struct for the XXH64 streaming API.  <a href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">More...</a><br /></td></tr>
<tr class="separator:ga0702bdbc80b0cf9e94f2379f7d839b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123c2a5e40e80541988c2277799f922d"><td class="memItemLeft" align="right" valign="top">
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>xxh_u8</b></td></tr>
<tr class="separator:ga123c2a5e40e80541988c2277799f922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c32ec5f4e0a062ea510d53ed009beb9"><td class="memItemLeft" align="right" valign="top">
typedef XXH32_hash_t&#160;</td><td class="memItemRight" valign="bottom"><b>xxh_u32</b></td></tr>
<tr class="separator:ga0c32ec5f4e0a062ea510d53ed009beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939b0b98d55ebe9223751c696292a22f"><td class="memItemLeft" align="right" valign="top"><a id="a939b0b98d55ebe9223751c696292a22f"></a>
typedef struct <a class="el" href="structnodeElt__s.html">nodeElt_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nodeElt</b></td></tr>
<tr class="separator:a939b0b98d55ebe9223751c696292a22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb221ba9349cc13133eb7257e867c50"><td class="memItemLeft" align="right" valign="top"><a id="a3cb221ba9349cc13133eb7257e867c50"></a>
typedef <a class="el" href="structnodeElt__s.html">nodeElt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>huffNodeTable</b>[2 *(HUF_SYMBOLVALUE_MAX+1)]</td></tr>
<tr class="separator:a3cb221ba9349cc13133eb7257e867c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619f9290ef97378708f798836ee7399e"><td class="memItemLeft" align="right" valign="top"><a id="a619f9290ef97378708f798836ee7399e"></a>
typedef struct <a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_CCtx</b></td></tr>
<tr class="separator:a619f9290ef97378708f798836ee7399e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6799417e35f9017d0d32a6f01cc22"><td class="memItemLeft" align="right" valign="top"><a id="a93f6799417e35f9017d0d32a6f01cc22"></a>
typedef struct <a class="el" href="structZSTD__prefixDict__s.html">ZSTD_prefixDict_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_prefixDict</b></td></tr>
<tr class="separator:a93f6799417e35f9017d0d32a6f01cc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540e7b22dc8bf41b79669965aa30850d"><td class="memItemLeft" align="right" valign="top"><a id="a540e7b22dc8bf41b79669965aa30850d"></a>
typedef struct <a class="el" href="structSeqDef__s.html">SeqDef_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SeqDef</b></td></tr>
<tr class="separator:a540e7b22dc8bf41b79669965aa30850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9514f24c4db4ecfb9fc534c342a40d"><td class="memItemLeft" align="right" valign="top"><a id="aae9514f24c4db4ecfb9fc534c342a40d"></a>
typedef struct <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MatchState_t</b></td></tr>
<tr class="separator:aae9514f24c4db4ecfb9fc534c342a40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0276a5bc77dd02707c223620bc15e9"><td class="memItemLeft" align="right" valign="top"><a id="a0c0276a5bc77dd02707c223620bc15e9"></a>
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BlockCompressor_f</b>) (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *bs, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a0c0276a5bc77dd02707c223620bc15e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a37ae4d3ed9379caa918cede5588dc"><td class="memItemLeft" align="right" valign="top"><a id="aa5a37ae4d3ed9379caa918cede5588dc"></a>
typedef struct <a class="el" href="structrepcodes__s.html">repcodes_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Repcodes_t</b></td></tr>
<tr class="separator:aa5a37ae4d3ed9379caa918cede5588dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c43ef27402df89fbc09947860a4497"><td class="memItemLeft" align="right" valign="top"><a id="a87c43ef27402df89fbc09947860a4497"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>RecordEvents_f</b>) (<a class="el" href="structFingerprint.html">Fingerprint</a> *fp, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a87c43ef27402df89fbc09947860a4497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3f92b8d33e714bf544bfe2f0e539f"><td class="memItemLeft" align="right" valign="top"><a id="ae9b3f92b8d33e714bf544bfe2f0e539f"></a>
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SequenceCopier_f</b>) (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, <a class="el" href="structZSTD__SequencePosition.html">ZSTD_SequencePosition</a> *seqPos, const <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *const inSeqs, size_t inSeqsSize, const void *src, size_t blockSize, ZSTD_ParamSwitch_e externalRepSearch)</td></tr>
<tr class="separator:ae9b3f92b8d33e714bf544bfe2f0e539f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a8cb4b2d35d6c27a584bf609afa2e9"><td class="memItemLeft" align="right" valign="top"><a id="a59a8cb4b2d35d6c27a584bf609afa2e9"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_match4Found</b>) (const BYTE *currentPtr, const BYTE *matchAddress, U32 matchIdx, U32 idxLowLimit)</td></tr>
<tr class="separator:a59a8cb4b2d35d6c27a584bf609afa2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d3007694ceb0a36f2bba647c42f95e"><td class="memItemLeft" align="right" valign="top"><a id="ad1d3007694ceb0a36f2bba647c42f95e"></a>
typedef U64&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_VecMask</b></td></tr>
<tr class="separator:ad1d3007694ceb0a36f2bba647c42f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1f94b7b332a680e3e27d9e7cd4be62"><td class="memItemLeft" align="right" valign="top"><a id="abe1f94b7b332a680e3e27d9e7cd4be62"></a>
typedef U32(*&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_getAllMatchesFn</b>) (<a class="el" href="structZSTD__match__t.html">ZSTD_match_t</a> *, <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *, U32 *, const BYTE *, const BYTE *, const U32 rep[ZSTD_REP_NUM], U32 const ll0, U32 const lengthToBeat)</td></tr>
<tr class="separator:abe1f94b7b332a680e3e27d9e7cd4be62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a2a8a226ea624717ad1682fa9f72c4"><td class="memItemLeft" align="right" valign="top"><a id="ae1a2a8a226ea624717ad1682fa9f72c4"></a>
typedef struct <a class="el" href="structbuffer__s.html">buffer_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Buffer</b></td></tr>
<tr class="separator:ae1a2a8a226ea624717ad1682fa9f72c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a063e5c10aefde823f355df2940cb7"><td class="memItemLeft" align="right" valign="top"><a id="a68a063e5c10aefde823f355df2940cb7"></a>
typedef struct <a class="el" href="structZSTDMT__bufferPool__s.html">ZSTDMT_bufferPool_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_bufferPool</b></td></tr>
<tr class="separator:a68a063e5c10aefde823f355df2940cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af20bbd5b854f64c02af0fae4ce230a"><td class="memItemLeft" align="right" valign="top"><a id="a2af20bbd5b854f64c02af0fae4ce230a"></a>
typedef <a class="el" href="structZSTDMT__bufferPool__s.html">ZSTDMT_bufferPool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_seqPool</b></td></tr>
<tr class="separator:a2af20bbd5b854f64c02af0fae4ce230a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574062bf434e01be2bde00833bf5dee"><td class="memItemLeft" align="right" valign="top"><a id="a8574062bf434e01be2bde00833bf5dee"></a>
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DecompressUsingDTableFn</b>) (void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, const HUF_DTable *DTable)</td></tr>
<tr class="separator:a8574062bf434e01be2bde00833bf5dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4f2044b7bdd37ed4c961b2101b4c69"><td class="memItemLeft" align="right" valign="top"><a id="a0e4f2044b7bdd37ed4c961b2101b4c69"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_DecompressFastLoopFn</b>) (<a class="el" href="structHUF__DecompressFastArgs.html">HUF_DecompressFastArgs</a> *)</td></tr>
<tr class="separator:a0e4f2044b7bdd37ed4c961b2101b4c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9d4a694df6eb9c48d5cc008f382319"><td class="memItemLeft" align="right" valign="top"><a id="a0e9d4a694df6eb9c48d5cc008f382319"></a>
typedef U32&#160;</td><td class="memItemRight" valign="bottom"><b>rankValCol_t</b>[HUF_TABLELOG_MAX+1]</td></tr>
<tr class="separator:a0e9d4a694df6eb9c48d5cc008f382319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af0107643c3b600babd257b804b1ac5"><td class="memItemLeft" align="right" valign="top"><a id="a2af0107643c3b600babd257b804b1ac5"></a>
typedef rankValCol_t&#160;</td><td class="memItemRight" valign="bottom"><b>rankVal_t</b>[HUF_TABLELOG_MAX]</td></tr>
<tr class="separator:a2af0107643c3b600babd257b804b1ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2609966f31111ad988e3c226013dc2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCOVER__best__s.html">COVER_best_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a></td></tr>
<tr class="separator:aaf2609966f31111ad988e3c226013dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3668acc1d146e3367f7f17ea2fb9b10c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCOVER__dictSelection.html">COVER_dictSelection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a></td></tr>
<tr class="separator:a3668acc1d146e3367f7f17ea2fb9b10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5683d2dff3f41cc717c7fdd679def965"><td class="memItemLeft" align="right" valign="top"><a id="a5683d2dff3f41cc717c7fdd679def965"></a>
typedef struct <a class="el" href="structCOVER__map__pair__t__s.html">COVER_map_pair_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COVER_map_pair_t</b></td></tr>
<tr class="separator:a5683d2dff3f41cc717c7fdd679def965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdcb02eaf422a09ffa37243637357f1"><td class="memItemLeft" align="right" valign="top"><a id="a6fdcb02eaf422a09ffa37243637357f1"></a>
typedef struct <a class="el" href="structCOVER__map__s.html">COVER_map_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COVER_map_t</b></td></tr>
<tr class="separator:a6fdcb02eaf422a09ffa37243637357f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcadb99c1e3d4210367ddf706e2c10e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCOVER__tryParameters__data__s.html">COVER_tryParameters_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0bcadb99c1e3d4210367ddf706e2c10e">COVER_tryParameters_data_t</a></td></tr>
<tr class="separator:a0bcadb99c1e3d4210367ddf706e2c10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06fbb2fbee0a4c4f28f07c7b2977d5a"><td class="memItemLeft" align="right" valign="top"><a id="ad06fbb2fbee0a4c4f28f07c7b2977d5a"></a>
typedef struct <a class="el" href="struct__trbudget__t.html">_trbudget_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>trbudget_t</b></td></tr>
<tr class="separator:ad06fbb2fbee0a4c4f28f07c7b2977d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7509ace266912c8ba8e10d3f7fc479bb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structFASTCOVER__tryParameters__data__s.html">FASTCOVER_tryParameters_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7509ace266912c8ba8e10d3f7fc479bb">FASTCOVER_tryParameters_data_t</a></td></tr>
<tr class="separator:a7509ace266912c8ba8e10d3f7fc479bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga3d2b19e87ac87eb107372946fce59b26"><td class="memItemLeft" align="right" valign="top">
typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_hash_t</b></td></tr>
<tr class="separator:ga3d2b19e87ac87eb107372946fce59b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5d61076079b98dcc1fcbe06775e81b37"><td class="memItemLeft" align="right" valign="top"><a id="a5d61076079b98dcc1fcbe06775e81b37"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ErrorCode</b> { <br />
&#160;&#160;<b>ZSTD_error_no_error</b> = 0
, <b>ZSTD_error_GENERIC</b> = 1
, <b>ZSTD_error_prefix_unknown</b> = 10
, <b>ZSTD_error_version_unsupported</b> = 12
, <br />
&#160;&#160;<b>ZSTD_error_frameParameter_unsupported</b> = 14
, <b>ZSTD_error_frameParameter_windowTooLarge</b> = 16
, <b>ZSTD_error_corruption_detected</b> = 20
, <b>ZSTD_error_checksum_wrong</b> = 22
, <br />
&#160;&#160;<b>ZSTD_error_literals_headerWrong</b> = 24
, <b>ZSTD_error_dictionary_corrupted</b> = 30
, <b>ZSTD_error_dictionary_wrong</b> = 32
, <b>ZSTD_error_dictionaryCreation_failed</b> = 34
, <br />
&#160;&#160;<b>ZSTD_error_parameter_unsupported</b> = 40
, <b>ZSTD_error_parameter_combination_unsupported</b> = 41
, <b>ZSTD_error_parameter_outOfBound</b> = 42
, <b>ZSTD_error_tableLog_tooLarge</b> = 44
, <br />
&#160;&#160;<b>ZSTD_error_maxSymbolValue_tooLarge</b> = 46
, <b>ZSTD_error_maxSymbolValue_tooSmall</b> = 48
, <b>ZSTD_error_cannotProduce_uncompressedBlock</b> = 49
, <b>ZSTD_error_stabilityCondition_notRespected</b> = 50
, <br />
&#160;&#160;<b>ZSTD_error_stage_wrong</b> = 60
, <b>ZSTD_error_init_missing</b> = 62
, <b>ZSTD_error_memory_allocation</b> = 64
, <b>ZSTD_error_workSpace_tooSmall</b> = 66
, <br />
&#160;&#160;<b>ZSTD_error_dstSize_tooSmall</b> = 70
, <b>ZSTD_error_srcSize_wrong</b> = 72
, <b>ZSTD_error_dstBuffer_null</b> = 74
, <b>ZSTD_error_noForwardProgress_destFull</b> = 80
, <br />
&#160;&#160;<b>ZSTD_error_noForwardProgress_inputEmpty</b> = 82
, <b>ZSTD_error_frameIndex_tooLarge</b> = 100
, <b>ZSTD_error_seekableIO</b> = 102
, <b>ZSTD_error_dstBuffer_wrong</b> = 104
, <br />
&#160;&#160;<b>ZSTD_error_srcBuffer_wrong</b> = 105
, <b>ZSTD_error_sequenceProducer_failed</b> = 106
, <b>ZSTD_error_externalSequences_invalid</b> = 107
, <b>ZSTD_error_maxCode</b> = 120
, <br />
&#160;&#160;<b>ZSTD_error_no_error</b> = 0
, <b>ZSTD_error_GENERIC</b> = 1
, <b>ZSTD_error_prefix_unknown</b> = 10
, <b>ZSTD_error_version_unsupported</b> = 12
, <br />
&#160;&#160;<b>ZSTD_error_frameParameter_unsupported</b> = 14
, <b>ZSTD_error_frameParameter_windowTooLarge</b> = 16
, <b>ZSTD_error_corruption_detected</b> = 20
, <b>ZSTD_error_checksum_wrong</b> = 22
, <br />
&#160;&#160;<b>ZSTD_error_literals_headerWrong</b> = 24
, <b>ZSTD_error_dictionary_corrupted</b> = 30
, <b>ZSTD_error_dictionary_wrong</b> = 32
, <b>ZSTD_error_dictionaryCreation_failed</b> = 34
, <br />
&#160;&#160;<b>ZSTD_error_parameter_unsupported</b> = 40
, <b>ZSTD_error_parameter_combination_unsupported</b> = 41
, <b>ZSTD_error_parameter_outOfBound</b> = 42
, <b>ZSTD_error_tableLog_tooLarge</b> = 44
, <br />
&#160;&#160;<b>ZSTD_error_maxSymbolValue_tooLarge</b> = 46
, <b>ZSTD_error_maxSymbolValue_tooSmall</b> = 48
, <b>ZSTD_error_cannotProduce_uncompressedBlock</b> = 49
, <b>ZSTD_error_stabilityCondition_notRespected</b> = 50
, <br />
&#160;&#160;<b>ZSTD_error_stage_wrong</b> = 60
, <b>ZSTD_error_init_missing</b> = 62
, <b>ZSTD_error_memory_allocation</b> = 64
, <b>ZSTD_error_workSpace_tooSmall</b> = 66
, <br />
&#160;&#160;<b>ZSTD_error_dstSize_tooSmall</b> = 70
, <b>ZSTD_error_srcSize_wrong</b> = 72
, <b>ZSTD_error_dstBuffer_null</b> = 74
, <b>ZSTD_error_noForwardProgress_destFull</b> = 80
, <br />
&#160;&#160;<b>ZSTD_error_noForwardProgress_inputEmpty</b> = 82
, <b>ZSTD_error_frameIndex_tooLarge</b> = 100
, <b>ZSTD_error_seekableIO</b> = 102
, <b>ZSTD_error_dstBuffer_wrong</b> = 104
, <br />
&#160;&#160;<b>ZSTD_error_srcBuffer_wrong</b> = 105
, <b>ZSTD_error_sequenceProducer_failed</b> = 106
, <b>ZSTD_error_externalSequences_invalid</b> = 107
, <b>ZSTD_error_maxCode</b> = 120
<br />
 }</td></tr>
<tr class="separator:a5d61076079b98dcc1fcbe06775e81b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf8aaa2b95a3ddaf5d7d6b4cd99ce6a"><td class="memItemLeft" align="right" valign="top"><a id="a5bf8aaa2b95a3ddaf5d7d6b4cd99ce6a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BIT_DStream_status</b> { <b>BIT_DStream_unfinished</b> = 0
, <b>BIT_DStream_endOfBuffer</b> = 1
, <b>BIT_DStream_completed</b> = 2
, <b>BIT_DStream_overflow</b> = 3
 }</td></tr>
<tr class="separator:a5bf8aaa2b95a3ddaf5d7d6b4cd99ce6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebeae519ed239e8ec29b2926630400b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aebeae519ed239e8ec29b2926630400b2">FSE_repeat</a> { <a class="el" href="zstd_8c.html#aebeae519ed239e8ec29b2926630400b2afbea521e4056e2437aae0b0bda7cedc8">FSE_repeat_none</a>
, <a class="el" href="zstd_8c.html#aebeae519ed239e8ec29b2926630400b2a08d1028515df85f72b8d6c2c1ef66c8d">FSE_repeat_check</a>
, <a class="el" href="zstd_8c.html#aebeae519ed239e8ec29b2926630400b2a0d596aacfa5c69c0da1bd28bb77b1a6a">FSE_repeat_valid</a>
 }</td></tr>
<tr class="separator:aebeae519ed239e8ec29b2926630400b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bcfd05176fe8cc555106dcdd65769b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a57bcfd05176fe8cc555106dcdd65769b">HUF_flags_e</a> { <br />
&#160;&#160;<a class="el" href="zstd_8c.html#a57bcfd05176fe8cc555106dcdd65769ba34c7ca7f4fde007b74478d5fcf510c90">HUF_flags_bmi2</a> = (1 &lt;&lt; 0)
, <a class="el" href="zstd_8c.html#a57bcfd05176fe8cc555106dcdd65769ba9336eacc6d681229b6e580dfcd587e6b">HUF_flags_optimalDepth</a> = (1 &lt;&lt; 1)
, <a class="el" href="zstd_8c.html#a57bcfd05176fe8cc555106dcdd65769babb08f80995f3570dd45e23f293071691">HUF_flags_preferRepeat</a> = (1 &lt;&lt; 2)
, <a class="el" href="zstd_8c.html#a57bcfd05176fe8cc555106dcdd65769ba35997496a2eee7d1f5eb856e75f5ed7a">HUF_flags_suspectUncompressible</a> = (1 &lt;&lt; 3)
, <br />
&#160;&#160;<a class="el" href="zstd_8c.html#a57bcfd05176fe8cc555106dcdd65769ba959109ca82c8504569a136690a8d2428">HUF_flags_disableAsm</a> = (1 &lt;&lt; 4)
, <a class="el" href="zstd_8c.html#a57bcfd05176fe8cc555106dcdd65769ba605f0a6c3c944cd219214a8ab01d6a0b">HUF_flags_disableFast</a> = (1 &lt;&lt; 5)
<br />
 }</td></tr>
<tr class="separator:a57bcfd05176fe8cc555106dcdd65769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea428e39b157d5f4d9bc03d030708c29"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29">HUF_repeat</a> { <a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29a8812ea6611ba5166fe7e392482d0414d">HUF_repeat_none</a>
, <a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29afc9ac956fe9e6db0fde5e5b20b9901ae">HUF_repeat_check</a>
, <a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29a3f6a33341880fd95bee8e05b671cc17a">HUF_repeat_valid</a>
 }</td></tr>
<tr class="separator:aea428e39b157d5f4d9bc03d030708c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852a7e43e763f198f70b9c93121717a3"><td class="memItemLeft" align="right" valign="top"><a id="a852a7e43e763f198f70b9c93121717a3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_strategy</b> { <br />
&#160;&#160;<b>ZSTD_fast</b> =1
, <b>ZSTD_dfast</b> =2
, <b>ZSTD_greedy</b> =3
, <b>ZSTD_lazy</b> =4
, <br />
&#160;&#160;<b>ZSTD_lazy2</b> =5
, <b>ZSTD_btlazy2</b> =6
, <b>ZSTD_btopt</b> =7
, <b>ZSTD_btultra</b> =8
, <br />
&#160;&#160;<b>ZSTD_btultra2</b> =9
, <b>ZSTD_fast</b> =1
, <b>ZSTD_dfast</b> =2
, <b>ZSTD_greedy</b> =3
, <br />
&#160;&#160;<b>ZSTD_lazy</b> =4
, <b>ZSTD_lazy2</b> =5
, <b>ZSTD_btlazy2</b> =6
, <b>ZSTD_btopt</b> =7
, <br />
&#160;&#160;<b>ZSTD_btultra</b> =8
, <b>ZSTD_btultra2</b> =9
<br />
 }</td></tr>
<tr class="separator:a852a7e43e763f198f70b9c93121717a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389f93318588a427c34282644ed5a322"><td class="memItemLeft" align="right" valign="top"><a id="a389f93318588a427c34282644ed5a322"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cParameter</b> { <br />
&#160;&#160;<b>ZSTD_c_compressionLevel</b> =100
, <b>ZSTD_c_windowLog</b> =101
, <b>ZSTD_c_hashLog</b> =102
, <b>ZSTD_c_chainLog</b> =103
, <br />
&#160;&#160;<b>ZSTD_c_searchLog</b> =104
, <b>ZSTD_c_minMatch</b> =105
, <b>ZSTD_c_targetLength</b> =106
, <b>ZSTD_c_strategy</b> =107
, <br />
&#160;&#160;<b>ZSTD_c_targetCBlockSize</b> =130
, <b>ZSTD_c_enableLongDistanceMatching</b> =160
, <b>ZSTD_c_ldmHashLog</b> =161
, <b>ZSTD_c_ldmMinMatch</b> =162
, <br />
&#160;&#160;<b>ZSTD_c_ldmBucketSizeLog</b> =163
, <b>ZSTD_c_ldmHashRateLog</b> =164
, <b>ZSTD_c_contentSizeFlag</b> =200
, <b>ZSTD_c_checksumFlag</b> =201
, <br />
&#160;&#160;<b>ZSTD_c_dictIDFlag</b> =202
, <b>ZSTD_c_nbWorkers</b> =400
, <b>ZSTD_c_jobSize</b> =401
, <b>ZSTD_c_overlapLog</b> =402
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam1</b> =500
, <b>ZSTD_c_experimentalParam2</b> =10
, <b>ZSTD_c_experimentalParam3</b> =1000
, <b>ZSTD_c_experimentalParam4</b> =1001
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam5</b> =1002
, <b>ZSTD_c_experimentalParam7</b> =1004
, <b>ZSTD_c_experimentalParam8</b> =1005
, <b>ZSTD_c_experimentalParam9</b> =1006
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam10</b> =1007
, <b>ZSTD_c_experimentalParam11</b> =1008
, <b>ZSTD_c_experimentalParam12</b> =1009
, <b>ZSTD_c_experimentalParam13</b> =1010
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam14</b> =1011
, <b>ZSTD_c_experimentalParam15</b> =1012
, <b>ZSTD_c_experimentalParam16</b> =1013
, <b>ZSTD_c_experimentalParam17</b> =1014
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam18</b> =1015
, <b>ZSTD_c_experimentalParam19</b> =1016
, <b>ZSTD_c_experimentalParam20</b> =1017
, <b>ZSTD_c_compressionLevel</b> =100
, <br />
&#160;&#160;<b>ZSTD_c_windowLog</b> =101
, <b>ZSTD_c_hashLog</b> =102
, <b>ZSTD_c_chainLog</b> =103
, <b>ZSTD_c_searchLog</b> =104
, <br />
&#160;&#160;<b>ZSTD_c_minMatch</b> =105
, <b>ZSTD_c_targetLength</b> =106
, <b>ZSTD_c_strategy</b> =107
, <b>ZSTD_c_targetCBlockSize</b> =130
, <br />
&#160;&#160;<b>ZSTD_c_enableLongDistanceMatching</b> =160
, <b>ZSTD_c_ldmHashLog</b> =161
, <b>ZSTD_c_ldmMinMatch</b> =162
, <b>ZSTD_c_ldmBucketSizeLog</b> =163
, <br />
&#160;&#160;<b>ZSTD_c_ldmHashRateLog</b> =164
, <b>ZSTD_c_contentSizeFlag</b> =200
, <b>ZSTD_c_checksumFlag</b> =201
, <b>ZSTD_c_dictIDFlag</b> =202
, <br />
&#160;&#160;<b>ZSTD_c_nbWorkers</b> =400
, <b>ZSTD_c_jobSize</b> =401
, <b>ZSTD_c_overlapLog</b> =402
, <b>ZSTD_c_experimentalParam1</b> =500
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam2</b> =10
, <b>ZSTD_c_experimentalParam3</b> =1000
, <b>ZSTD_c_experimentalParam4</b> =1001
, <b>ZSTD_c_experimentalParam5</b> =1002
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam7</b> =1004
, <b>ZSTD_c_experimentalParam8</b> =1005
, <b>ZSTD_c_experimentalParam9</b> =1006
, <b>ZSTD_c_experimentalParam10</b> =1007
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam11</b> =1008
, <b>ZSTD_c_experimentalParam12</b> =1009
, <b>ZSTD_c_experimentalParam13</b> =1010
, <b>ZSTD_c_experimentalParam14</b> =1011
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam15</b> =1012
, <b>ZSTD_c_experimentalParam16</b> =1013
, <b>ZSTD_c_experimentalParam17</b> =1014
, <b>ZSTD_c_experimentalParam18</b> =1015
, <br />
&#160;&#160;<b>ZSTD_c_experimentalParam19</b> =1016
, <b>ZSTD_c_experimentalParam20</b> =1017
<br />
 }</td></tr>
<tr class="separator:a389f93318588a427c34282644ed5a322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26df49de5e5c276705494acc9e7f2f1"><td class="memItemLeft" align="right" valign="top"><a id="ad26df49de5e5c276705494acc9e7f2f1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ResetDirective</b> { <br />
&#160;&#160;<b>ZSTD_reset_session_only</b> = 1
, <b>ZSTD_reset_parameters</b> = 2
, <b>ZSTD_reset_session_and_parameters</b> = 3
, <b>ZSTD_reset_session_only</b> = 1
, <br />
&#160;&#160;<b>ZSTD_reset_parameters</b> = 2
, <b>ZSTD_reset_session_and_parameters</b> = 3
<br />
 }</td></tr>
<tr class="separator:ad26df49de5e5c276705494acc9e7f2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7923c5fd2e06d47ffb467a2fa1dac6c7"><td class="memItemLeft" align="right" valign="top"><a id="a7923c5fd2e06d47ffb467a2fa1dac6c7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dParameter</b> { <br />
&#160;&#160;<b>ZSTD_d_windowLogMax</b> =100
, <b>ZSTD_d_experimentalParam1</b> =1000
, <b>ZSTD_d_experimentalParam2</b> =1001
, <b>ZSTD_d_experimentalParam3</b> =1002
, <br />
&#160;&#160;<b>ZSTD_d_experimentalParam4</b> =1003
, <b>ZSTD_d_experimentalParam5</b> =1004
, <b>ZSTD_d_experimentalParam6</b> =1005
, <b>ZSTD_d_windowLogMax</b> =100
, <br />
&#160;&#160;<b>ZSTD_d_experimentalParam1</b> =1000
, <b>ZSTD_d_experimentalParam2</b> =1001
, <b>ZSTD_d_experimentalParam3</b> =1002
, <b>ZSTD_d_experimentalParam4</b> =1003
, <br />
&#160;&#160;<b>ZSTD_d_experimentalParam5</b> =1004
, <b>ZSTD_d_experimentalParam6</b> =1005
<br />
 }</td></tr>
<tr class="separator:a7923c5fd2e06d47ffb467a2fa1dac6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800deb274e46fda42839b5a7bbe261aa"><td class="memItemLeft" align="right" valign="top"><a id="a800deb274e46fda42839b5a7bbe261aa"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_EndDirective</b> { <br />
&#160;&#160;<b>ZSTD_e_continue</b> =0
, <b>ZSTD_e_flush</b> =1
, <b>ZSTD_e_end</b> =2
, <b>ZSTD_e_continue</b> =0
, <br />
&#160;&#160;<b>ZSTD_e_flush</b> =1
, <b>ZSTD_e_end</b> =2
<br />
 }</td></tr>
<tr class="separator:a800deb274e46fda42839b5a7bbe261aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd4ef698ef13fde4b0018780bd44cc9"><td class="memItemLeft" align="right" valign="top"><a id="a5cd4ef698ef13fde4b0018780bd44cc9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dictContentType_e</b> { <b>ZSTD_dct_auto</b> = 0
, <b>ZSTD_dct_rawContent</b> = 1
, <b>ZSTD_dct_fullDict</b> = 2
 }</td></tr>
<tr class="separator:a5cd4ef698ef13fde4b0018780bd44cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b07eb9d181ba9a9085f75d52b3d839"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> { <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839a59cd77cf86c004e68373a7db14539aaf">ZSTD_dlm_byCopy</a> = 0
, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839a9acc996c7124ebfde521233208203b76">ZSTD_dlm_byRef</a> = 1
 }</td></tr>
<tr class="separator:af9b07eb9d181ba9a9085f75d52b3d839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f044a95915602102611fc228a901946"><td class="memItemLeft" align="right" valign="top"><a id="a0f044a95915602102611fc228a901946"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_format_e</b> { <b>ZSTD_f_zstd1</b> = 0
, <b>ZSTD_f_zstd1_magicless</b> = 1
 }</td></tr>
<tr class="separator:a0f044a95915602102611fc228a901946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15b416de1a11e6f56ca9dc98f87958e"><td class="memItemLeft" align="right" valign="top"><a id="ad15b416de1a11e6f56ca9dc98f87958e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_forceIgnoreChecksum_e</b> { <b>ZSTD_d_validateChecksum</b> = 0
, <b>ZSTD_d_ignoreChecksum</b> = 1
 }</td></tr>
<tr class="separator:ad15b416de1a11e6f56ca9dc98f87958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5029c4df8acdcfdbbc34a4ae5a871fa"><td class="memItemLeft" align="right" valign="top"><a id="af5029c4df8acdcfdbbc34a4ae5a871fa"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_refMultipleDDicts_e</b> { <b>ZSTD_rmd_refSingleDDict</b> = 0
, <b>ZSTD_rmd_refMultipleDDicts</b> = 1
 }</td></tr>
<tr class="separator:af5029c4df8acdcfdbbc34a4ae5a871fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91522eddf9470637b03e99ae9c859b4c"><td class="memItemLeft" align="right" valign="top"><a id="a91522eddf9470637b03e99ae9c859b4c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dictAttachPref_e</b> { <b>ZSTD_dictDefaultAttach</b> = 0
, <b>ZSTD_dictForceAttach</b> = 1
, <b>ZSTD_dictForceCopy</b> = 2
, <b>ZSTD_dictForceLoad</b> = 3
 }</td></tr>
<tr class="separator:a91522eddf9470637b03e99ae9c859b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3e172ab79a1213e7b60a8732c2d4c4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5c3e172ab79a1213e7b60a8732c2d4c4">ZSTD_literalCompressionMode_e</a> { <a class="el" href="zstd_8c.html#a5c3e172ab79a1213e7b60a8732c2d4c4a720c11b570fcbdf1be29e85fd061ec06">ZSTD_lcm_auto</a> = 0
, <a class="el" href="zstd_8c.html#a5c3e172ab79a1213e7b60a8732c2d4c4a4404a781197abd21f07f1471a0951471">ZSTD_lcm_huffman</a> = 1
, <a class="el" href="zstd_8c.html#a5c3e172ab79a1213e7b60a8732c2d4c4a6f9a8f0cc22507401cbb4a79f5ed5567">ZSTD_lcm_uncompressed</a> = 2
 }</td></tr>
<tr class="separator:a5c3e172ab79a1213e7b60a8732c2d4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42952e0dd88f8e65be3725920daa5292"><td class="memItemLeft" align="right" valign="top"><a id="a42952e0dd88f8e65be3725920daa5292"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ParamSwitch_e</b> { <b>ZSTD_ps_auto</b> = 0
, <b>ZSTD_ps_enable</b> = 1
, <b>ZSTD_ps_disable</b> = 2
 }</td></tr>
<tr class="separator:a42952e0dd88f8e65be3725920daa5292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4aa819fb66f904e97920567b0d6e65"><td class="memItemLeft" align="right" valign="top"><a id="a4c4aa819fb66f904e97920567b0d6e65"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_FrameType_e</b> { <b>ZSTD_frame</b>
, <b>ZSTD_skippableFrame</b>
 }</td></tr>
<tr class="separator:a4c4aa819fb66f904e97920567b0d6e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18386502c69546675c5439ed11c0d64"><td class="memItemLeft" align="right" valign="top"><a id="ac18386502c69546675c5439ed11c0d64"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_SequenceFormat_e</b> { <b>ZSTD_sf_noBlockDelimiters</b> = 0
, <b>ZSTD_sf_explicitBlockDelimiters</b> = 1
 }</td></tr>
<tr class="separator:ac18386502c69546675c5439ed11c0d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e11d31a09f889db11563a1f5e50cc"><td class="memItemLeft" align="right" valign="top"><a id="af76e11d31a09f889db11563a1f5e50cc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_nextInputType_e</b> { <br />
&#160;&#160;<b>ZSTDnit_frameHeader</b>
, <b>ZSTDnit_blockHeader</b>
, <b>ZSTDnit_block</b>
, <b>ZSTDnit_lastBlock</b>
, <br />
&#160;&#160;<b>ZSTDnit_checksum</b>
, <b>ZSTDnit_skippableFrame</b>
<br />
 }</td></tr>
<tr class="separator:af76e11d31a09f889db11563a1f5e50cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec56fccd4f83e34902b6b09ecccfff5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__impl.html#gadec56fccd4f83e34902b6b09ecccfff5">XXH_alignment</a> { <a class="el" href="group__impl.html#ggadec56fccd4f83e34902b6b09ecccfff5a41340c9f33fe739cef7a1c56dc617194">XXH_aligned</a>
, <a class="el" href="group__impl.html#ggadec56fccd4f83e34902b6b09ecccfff5ab082c14fd7eef12bcb1dfda2e813586f">XXH_unaligned</a>
 }</td></tr>
<tr class="separator:gadec56fccd4f83e34902b6b09ecccfff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781951c5a4951f8bb0ea9e713dfacf80"><td class="memItemLeft" align="right" valign="top"><a id="a781951c5a4951f8bb0ea9e713dfacf80"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>blockType_e</b> { <b>bt_raw</b>
, <b>bt_rle</b>
, <b>bt_compressed</b>
, <b>bt_reserved</b>
 }</td></tr>
<tr class="separator:a781951c5a4951f8bb0ea9e713dfacf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f3e35855fd11c4de5bef6a502d6f61"><td class="memItemLeft" align="right" valign="top"><a id="ae0f3e35855fd11c4de5bef6a502d6f61"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SymbolEncodingType_e</b> { <b>set_basic</b>
, <b>set_rle</b>
, <b>set_compressed</b>
, <b>set_repeat</b>
 }</td></tr>
<tr class="separator:ae0f3e35855fd11c4de5bef6a502d6f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52188369fa44532ad1f7c325cff4a0"><td class="memItemLeft" align="right" valign="top"><a id="aea52188369fa44532ad1f7c325cff4a0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_overlap_e</b> { <b>ZSTD_no_overlap</b>
, <b>ZSTD_overlap_src_before_dst</b>
 }</td></tr>
<tr class="separator:aea52188369fa44532ad1f7c325cff4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ac66b9d775c4f508ce638112bd7e79"><td class="memItemLeft" align="right" valign="top"><a id="af7ac66b9d775c4f508ce638112bd7e79"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_bufferMode_e</b> { <b>ZSTD_bm_buffered</b> = 0
, <b>ZSTD_bm_stable</b> = 1
 }</td></tr>
<tr class="separator:af7ac66b9d775c4f508ce638112bd7e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b2ab8d7c9c72e3fc1bd3407139190e"><td class="memItemLeft" align="right" valign="top"><a id="a42b2ab8d7c9c72e3fc1bd3407139190e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>HIST_checkInput_e</b> { <b>trustInput</b>
, <b>checkMaxSymbolValue</b>
 }</td></tr>
<tr class="separator:a42b2ab8d7c9c72e3fc1bd3407139190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ca0f9a9e0f2c35b44414e65c23191e"><td class="memItemLeft" align="right" valign="top"><a id="a54ca0f9a9e0f2c35b44414e65c23191e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>HUF_nbStreams_e</b> { <b>HUF_singleStream</b>
, <b>HUF_fourStreams</b>
 }</td></tr>
<tr class="separator:a54ca0f9a9e0f2c35b44414e65c23191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847d60a839dbaa26818fedaa8b5f2343"><td class="memItemLeft" align="right" valign="top"><a id="a847d60a839dbaa26818fedaa8b5f2343"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_alloc_phase_e</b> { <b>ZSTD_cwksp_alloc_objects</b>
, <b>ZSTD_cwksp_alloc_aligned_init_once</b>
, <b>ZSTD_cwksp_alloc_aligned</b>
, <b>ZSTD_cwksp_alloc_buffers</b>
 }</td></tr>
<tr class="separator:a847d60a839dbaa26818fedaa8b5f2343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df52ae5f2538c70f0db6f9c9377f6c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1df52ae5f2538c70f0db6f9c9377f6c7">ZSTD_cwksp_static_alloc_e</a> { <b>ZSTD_cwksp_dynamic_alloc</b>
, <b>ZSTD_cwksp_static_alloc</b>
 }</td></tr>
<tr class="separator:a1df52ae5f2538c70f0db6f9c9377f6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5758c1d9a3510d88eb6cb538edd75be"><td class="memItemLeft" align="right" valign="top"><a id="ab5758c1d9a3510d88eb6cb538edd75be"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressionStage_e</b> { <b>ZSTDcs_created</b> =0
, <b>ZSTDcs_init</b>
, <b>ZSTDcs_ongoing</b>
, <b>ZSTDcs_ending</b>
 }</td></tr>
<tr class="separator:ab5758c1d9a3510d88eb6cb538edd75be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbffdafdefdc803e73de1844f66ae00"><td class="memItemLeft" align="right" valign="top"><a id="a4cbffdafdefdc803e73de1844f66ae00"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cStreamStage</b> { <b>zcss_init</b> =0
, <b>zcss_load</b>
, <b>zcss_flush</b>
 }</td></tr>
<tr class="separator:a4cbffdafdefdc803e73de1844f66ae00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3201576b346e3e5ad420692cf097979f"><td class="memItemLeft" align="right" valign="top"><a id="a3201576b346e3e5ad420692cf097979f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_longLengthType_e</b> { <b>ZSTD_llt_none</b> = 0
, <b>ZSTD_llt_literalLength</b> = 1
, <b>ZSTD_llt_matchLength</b> = 2
 }</td></tr>
<tr class="separator:a3201576b346e3e5ad420692cf097979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ac3357d430e792d2e21f2f1b46dcea"><td class="memItemLeft" align="right" valign="top"><a id="a31ac3357d430e792d2e21f2f1b46dcea"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_OptPrice_e</b> { <b>zop_dynamic</b> =0
, <b>zop_predef</b>
 }</td></tr>
<tr class="separator:a31ac3357d430e792d2e21f2f1b46dcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00047efe2f309b66658fc8b33361ab1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a00047efe2f309b66658fc8b33361ab1a">ZSTD_buffered_policy_e</a> { <b>ZSTDb_not_buffered</b>
, <b>ZSTDb_buffered</b>
 }</td></tr>
<tr class="separator:a00047efe2f309b66658fc8b33361ab1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59ad5e0c9847cf2fc1713cc6f072fbd"><td class="memItemLeft" align="right" valign="top"><a id="ac59ad5e0c9847cf2fc1713cc6f072fbd"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dictTableLoadMethod_e</b> { <b>ZSTD_dtlm_fast</b>
, <b>ZSTD_dtlm_full</b>
 }</td></tr>
<tr class="separator:ac59ad5e0c9847cf2fc1713cc6f072fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62669e5f0bbcc61d89e2ac0b7a000cc"><td class="memItemLeft" align="right" valign="top"><a id="af62669e5f0bbcc61d89e2ac0b7a000cc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_tableFillPurpose_e</b> { <b>ZSTD_tfp_forCCtx</b>
, <b>ZSTD_tfp_forCDict</b>
 }</td></tr>
<tr class="separator:af62669e5f0bbcc61d89e2ac0b7a000cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa02da47ee749a002cae6faef5f4835f"><td class="memItemLeft" align="right" valign="top"><a id="afa02da47ee749a002cae6faef5f4835f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dictMode_e</b> { <b>ZSTD_noDict</b> = 0
, <b>ZSTD_extDict</b> = 1
, <b>ZSTD_dictMatchState</b> = 2
, <b>ZSTD_dedicatedDictSearch</b> = 3
 }</td></tr>
<tr class="separator:afa02da47ee749a002cae6faef5f4835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565fa85bd0d1636edd29c0867da43f2f"><td class="memItemLeft" align="right" valign="top"><a id="a565fa85bd0d1636edd29c0867da43f2f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CParamMode_e</b> { <b>ZSTD_cpm_noAttachDict</b> = 0
, <b>ZSTD_cpm_attachDict</b> = 1
, <b>ZSTD_cpm_createCDict</b> = 2
, <b>ZSTD_cpm_unknown</b> = 3
 }</td></tr>
<tr class="separator:a565fa85bd0d1636edd29c0867da43f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d824d7e72565b01d7e0da0afcf55e31"><td class="memItemLeft" align="right" valign="top"><a id="a1d824d7e72565b01d7e0da0afcf55e31"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DefaultPolicy_e</b> { <b>ZSTD_defaultDisallowed</b> = 0
, <b>ZSTD_defaultAllowed</b> = 1
 }</td></tr>
<tr class="separator:a1d824d7e72565b01d7e0da0afcf55e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bda71cebae53b2942b1c0eda3112e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a90bda71cebae53b2942b1c0eda3112e9">ZSTD_compResetPolicy_e</a> { <b>ZSTDcrp_makeClean</b>
, <b>ZSTDcrp_leaveDirty</b>
 }</td></tr>
<tr class="separator:a90bda71cebae53b2942b1c0eda3112e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ef91a46ef394adfb15fcc5404f0a89"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a60ef91a46ef394adfb15fcc5404f0a89">ZSTD_indexResetPolicy_e</a> { <b>ZSTDirp_continue</b>
, <b>ZSTDirp_reset</b>
 }</td></tr>
<tr class="separator:a60ef91a46ef394adfb15fcc5404f0a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635424e7c1ef008cb9f0b7ba93f87c01"><td class="memItemLeft" align="right" valign="top"><a id="a635424e7c1ef008cb9f0b7ba93f87c01"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_resetTarget_e</b> { <b>ZSTD_resetTarget_CDict</b>
, <b>ZSTD_resetTarget_CCtx</b>
 }</td></tr>
<tr class="separator:a635424e7c1ef008cb9f0b7ba93f87c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e3179a32015b64b7307ed98fefde7b"><td class="memItemLeft" align="right" valign="top"><a id="ab5e3179a32015b64b7307ed98fefde7b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_BuildSeqStore_e</b> { <b>ZSTDbss_compress</b>
, <b>ZSTDbss_noCompress</b>
 }</td></tr>
<tr class="separator:ab5e3179a32015b64b7307ed98fefde7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166037fa4a4135bc29ee47a92c899930"><td class="memItemLeft" align="right" valign="top"><a id="a166037fa4a4135bc29ee47a92c899930"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>searchMethod_e</b> { <b>search_hashChain</b> =0
, <b>search_binaryTree</b> =1
, <b>search_rowHash</b> =2
 }</td></tr>
<tr class="separator:a166037fa4a4135bc29ee47a92c899930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82073697c084fa3e2d941213c7bd904e"><td class="memItemLeft" align="right" valign="top"><a id="a82073697c084fa3e2d941213c7bd904e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>base_directive_e</b> { <b>base_0possible</b> =0
, <b>base_1guaranteed</b> =1
 }</td></tr>
<tr class="separator:a82073697c084fa3e2d941213c7bd904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa282092432324f27d17a518a30a6abf4"><td class="memItemLeft" align="right" valign="top"><a id="aa282092432324f27d17a518a30a6abf4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dStage</b> { <br />
&#160;&#160;<b>ZSTDds_getFrameHeaderSize</b>
, <b>ZSTDds_decodeFrameHeader</b>
, <b>ZSTDds_decodeBlockHeader</b>
, <b>ZSTDds_decompressBlock</b>
, <br />
&#160;&#160;<b>ZSTDds_decompressLastBlock</b>
, <b>ZSTDds_checkChecksum</b>
, <b>ZSTDds_decodeSkippableHeader</b>
, <b>ZSTDds_skipFrame</b>
<br />
 }</td></tr>
<tr class="separator:aa282092432324f27d17a518a30a6abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b97bf0277c0c76ed923d87a263b68f8"><td class="memItemLeft" align="right" valign="top"><a id="a0b97bf0277c0c76ed923d87a263b68f8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dStreamStage</b> { <br />
&#160;&#160;<b>zdss_init</b> =0
, <b>zdss_loadHeader</b>
, <b>zdss_read</b>
, <b>zdss_load</b>
, <br />
&#160;&#160;<b>zdss_flush</b>
<br />
 }</td></tr>
<tr class="separator:a0b97bf0277c0c76ed923d87a263b68f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361041084c20c9e4df19c910c6aeaca6"><td class="memItemLeft" align="right" valign="top"><a id="a361041084c20c9e4df19c910c6aeaca6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dictUses_e</b> { <b>ZSTD_use_indefinitely</b> = -1
, <b>ZSTD_dont_use</b> = 0
, <b>ZSTD_use_once</b> = 1
 }</td></tr>
<tr class="separator:a361041084c20c9e4df19c910c6aeaca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb547ce9d69e4c66db70906d8cc60213"><td class="memItemLeft" align="right" valign="top"><a id="acb547ce9d69e4c66db70906d8cc60213"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_litLocation_e</b> { <b>ZSTD_not_in_dst</b> = 0
, <b>ZSTD_in_dst</b> = 1
, <b>ZSTD_split</b> = 2
 }</td></tr>
<tr class="separator:acb547ce9d69e4c66db70906d8cc60213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae135a845fe93835c4ecd846e4e6aa65a"><td class="memItemLeft" align="right" valign="top"><a id="ae135a845fe93835c4ecd846e4e6aa65a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>streaming_operation</b> { <b>not_streaming</b> = 0
, <b>is_streaming</b> = 1
 }</td></tr>
<tr class="separator:ae135a845fe93835c4ecd846e4e6aa65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9100e2ec8de9fa0a4f7ac04f6439b225"><td class="memItemLeft" align="right" valign="top"><a id="a9100e2ec8de9fa0a4f7ac04f6439b225"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_longOffset_e</b> { <b>ZSTD_lo_isRegularOffset</b>
, <b>ZSTD_lo_isLongOffset</b> =1
 }</td></tr>
<tr class="separator:a9100e2ec8de9fa0a4f7ac04f6439b225"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2fe675a7b136fd92da121b4006d96724"><td class="memItemLeft" align="right" valign="top"><a id="a2fe675a7b136fd92da121b4006d96724"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_isPower2</b> (size_t u)</td></tr>
<tr class="separator:a2fe675a7b136fd92da121b4006d96724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e01b39b589cdfa16b1a952ebe472e5"><td class="memItemLeft" align="right" valign="top">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a42e01b39b589cdfa16b1a952ebe472e5">ZSTD_wrappedPtrDiff</a> (unsigned char const *lhs, unsigned char const *rhs)</td></tr>
<tr class="separator:a42e01b39b589cdfa16b1a952ebe472e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5515677ed3ff5244f9d64604bbebc541"><td class="memItemLeft" align="right" valign="top">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5515677ed3ff5244f9d64604bbebc541">ZSTD_wrappedPtrAdd</a> (const void *ptr, ptrdiff_t add)</td></tr>
<tr class="separator:a5515677ed3ff5244f9d64604bbebc541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee7f4ff2f1b7edb326c6bc5dad52b18"><td class="memItemLeft" align="right" valign="top">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4ee7f4ff2f1b7edb326c6bc5dad52b18">ZSTD_wrappedPtrSub</a> (const void *ptr, ptrdiff_t sub)</td></tr>
<tr class="separator:a4ee7f4ff2f1b7edb326c6bc5dad52b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899d0f1cff2c0925aae29d3620e91771"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a899d0f1cff2c0925aae29d3620e91771">ZSTD_maybeNullPtrAdd</a> (void *ptr, ptrdiff_t add)</td></tr>
<tr class="separator:a899d0f1cff2c0925aae29d3620e91771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e77a75ccecc21ae7bba184b9c15c98"><td class="memItemLeft" align="right" valign="top"><a id="a18e77a75ccecc21ae7bba184b9c15c98"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_32bits</b> (void)</td></tr>
<tr class="separator:a18e77a75ccecc21ae7bba184b9c15c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dde55c217c03b317ba03f77c65c33ff"><td class="memItemLeft" align="right" valign="top"><a id="a8dde55c217c03b317ba03f77c65c33ff"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_64bits</b> (void)</td></tr>
<tr class="separator:a8dde55c217c03b317ba03f77c65c33ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f55400481e77eaff572ca4810a75d8a"><td class="memItemLeft" align="right" valign="top"><a id="a6f55400481e77eaff572ca4810a75d8a"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_isLittleEndian</b> (void)</td></tr>
<tr class="separator:a6f55400481e77eaff572ca4810a75d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8baa9c29ded9e4db53cc9fbaebcd48"><td class="memItemLeft" align="right" valign="top"><a id="a2a8baa9c29ded9e4db53cc9fbaebcd48"></a>
MEM_STATIC U16&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_read16</b> (const void *memPtr)</td></tr>
<tr class="separator:a2a8baa9c29ded9e4db53cc9fbaebcd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217bf2f0a72e98c9dd5b7c4777a7c5b1"><td class="memItemLeft" align="right" valign="top"><a id="a217bf2f0a72e98c9dd5b7c4777a7c5b1"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_read32</b> (const void *memPtr)</td></tr>
<tr class="separator:a217bf2f0a72e98c9dd5b7c4777a7c5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e8ac6fcc8f3719cee9e32df7d9a580"><td class="memItemLeft" align="right" valign="top"><a id="ae9e8ac6fcc8f3719cee9e32df7d9a580"></a>
MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_read64</b> (const void *memPtr)</td></tr>
<tr class="separator:ae9e8ac6fcc8f3719cee9e32df7d9a580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dbb8562260a955804c84e135c9d6a6"><td class="memItemLeft" align="right" valign="top"><a id="a43dbb8562260a955804c84e135c9d6a6"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readST</b> (const void *memPtr)</td></tr>
<tr class="separator:a43dbb8562260a955804c84e135c9d6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1f06850ab39a708b5828f1e6d98f54"><td class="memItemLeft" align="right" valign="top"><a id="acc1f06850ab39a708b5828f1e6d98f54"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_write16</b> (void *memPtr, U16 value)</td></tr>
<tr class="separator:acc1f06850ab39a708b5828f1e6d98f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c41a4bffb616aa6f44fbafef54aa75"><td class="memItemLeft" align="right" valign="top"><a id="a98c41a4bffb616aa6f44fbafef54aa75"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_write32</b> (void *memPtr, U32 value)</td></tr>
<tr class="separator:a98c41a4bffb616aa6f44fbafef54aa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ae1fe53aa929a95ae11e9b87133577"><td class="memItemLeft" align="right" valign="top"><a id="a14ae1fe53aa929a95ae11e9b87133577"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_write64</b> (void *memPtr, U64 value)</td></tr>
<tr class="separator:a14ae1fe53aa929a95ae11e9b87133577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bb46c7ca94b708d315466f6a965fca"><td class="memItemLeft" align="right" valign="top"><a id="a74bb46c7ca94b708d315466f6a965fca"></a>
MEM_STATIC U16&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readLE16</b> (const void *memPtr)</td></tr>
<tr class="separator:a74bb46c7ca94b708d315466f6a965fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1471303596c711ed17413576e85675bc"><td class="memItemLeft" align="right" valign="top"><a id="a1471303596c711ed17413576e85675bc"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readLE24</b> (const void *memPtr)</td></tr>
<tr class="separator:a1471303596c711ed17413576e85675bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae961ae5bbdbb98421b173c05a67c1cec"><td class="memItemLeft" align="right" valign="top"><a id="ae961ae5bbdbb98421b173c05a67c1cec"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readLE32</b> (const void *memPtr)</td></tr>
<tr class="separator:ae961ae5bbdbb98421b173c05a67c1cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996497c67854d8927dd11e69cce49006"><td class="memItemLeft" align="right" valign="top"><a id="a996497c67854d8927dd11e69cce49006"></a>
MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readLE64</b> (const void *memPtr)</td></tr>
<tr class="separator:a996497c67854d8927dd11e69cce49006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8cb1fdc13ead05ea44b41ae242e790"><td class="memItemLeft" align="right" valign="top"><a id="a3a8cb1fdc13ead05ea44b41ae242e790"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readLEST</b> (const void *memPtr)</td></tr>
<tr class="separator:a3a8cb1fdc13ead05ea44b41ae242e790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ded5af45f44dfbd14f43d4912950d50"><td class="memItemLeft" align="right" valign="top"><a id="a4ded5af45f44dfbd14f43d4912950d50"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_writeLE16</b> (void *memPtr, U16 val)</td></tr>
<tr class="separator:a4ded5af45f44dfbd14f43d4912950d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4f5ec0e393e2fad84fca54ba971816"><td class="memItemLeft" align="right" valign="top"><a id="ada4f5ec0e393e2fad84fca54ba971816"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_writeLE24</b> (void *memPtr, U32 val)</td></tr>
<tr class="separator:ada4f5ec0e393e2fad84fca54ba971816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8c5ab3aa1eb7901adab8d65e2abd6e"><td class="memItemLeft" align="right" valign="top"><a id="a6f8c5ab3aa1eb7901adab8d65e2abd6e"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_writeLE32</b> (void *memPtr, U32 val32)</td></tr>
<tr class="separator:a6f8c5ab3aa1eb7901adab8d65e2abd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c28c12df129e8ad17c855b80ee3bb"><td class="memItemLeft" align="right" valign="top"><a id="ad39c28c12df129e8ad17c855b80ee3bb"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_writeLE64</b> (void *memPtr, U64 val64)</td></tr>
<tr class="separator:ad39c28c12df129e8ad17c855b80ee3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0028bdef9bf51707feddbf5d62d542"><td class="memItemLeft" align="right" valign="top"><a id="aba0028bdef9bf51707feddbf5d62d542"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_writeLEST</b> (void *memPtr, size_t val)</td></tr>
<tr class="separator:aba0028bdef9bf51707feddbf5d62d542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d776d11be8e5d61ef07b485df0010e1"><td class="memItemLeft" align="right" valign="top"><a id="a4d776d11be8e5d61ef07b485df0010e1"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readBE32</b> (const void *memPtr)</td></tr>
<tr class="separator:a4d776d11be8e5d61ef07b485df0010e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8d97285d5d46825f9c2d0a0341a1cc"><td class="memItemLeft" align="right" valign="top"><a id="a1d8d97285d5d46825f9c2d0a0341a1cc"></a>
MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readBE64</b> (const void *memPtr)</td></tr>
<tr class="separator:a1d8d97285d5d46825f9c2d0a0341a1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1d1e609b1c3d5645ec9608802077eb"><td class="memItemLeft" align="right" valign="top"><a id="a4b1d1e609b1c3d5645ec9608802077eb"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_readBEST</b> (const void *memPtr)</td></tr>
<tr class="separator:a4b1d1e609b1c3d5645ec9608802077eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b1fb799bbcbe77e601d75d65fc90f3"><td class="memItemLeft" align="right" valign="top"><a id="a36b1fb799bbcbe77e601d75d65fc90f3"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_writeBE32</b> (void *memPtr, U32 val32)</td></tr>
<tr class="separator:a36b1fb799bbcbe77e601d75d65fc90f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e3df5ac8f720c1e9af0a641b383eb5"><td class="memItemLeft" align="right" valign="top"><a id="af5e3df5ac8f720c1e9af0a641b383eb5"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_writeBE64</b> (void *memPtr, U64 val64)</td></tr>
<tr class="separator:af5e3df5ac8f720c1e9af0a641b383eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b82b9f4943ed2ae9d503ee201f5d99f"><td class="memItemLeft" align="right" valign="top"><a id="a5b82b9f4943ed2ae9d503ee201f5d99f"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_writeBEST</b> (void *memPtr, size_t val)</td></tr>
<tr class="separator:a5b82b9f4943ed2ae9d503ee201f5d99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23df46586bdbabc7acab5cd0bc8f78d0"><td class="memItemLeft" align="right" valign="top"><a id="a23df46586bdbabc7acab5cd0bc8f78d0"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_swap32</b> (U32 in)</td></tr>
<tr class="separator:a23df46586bdbabc7acab5cd0bc8f78d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2581ea2b65fee514fe7283f4058b6f"><td class="memItemLeft" align="right" valign="top"><a id="a1a2581ea2b65fee514fe7283f4058b6f"></a>
MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_swap64</b> (U64 in)</td></tr>
<tr class="separator:a1a2581ea2b65fee514fe7283f4058b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6228bfff649f9f5fda4b4d93e459e9bc"><td class="memItemLeft" align="right" valign="top"><a id="a6228bfff649f9f5fda4b4d93e459e9bc"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_swapST</b> (size_t in)</td></tr>
<tr class="separator:a6228bfff649f9f5fda4b4d93e459e9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf0ff7bfd7ef7218631967d06246a14"><td class="memItemLeft" align="right" valign="top"><a id="afaf0ff7bfd7ef7218631967d06246a14"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_swap32_fallback</b> (U32 in)</td></tr>
<tr class="separator:afaf0ff7bfd7ef7218631967d06246a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985c6fd0082439b7946e440b22c3519f"><td class="memItemLeft" align="right" valign="top"><a id="a985c6fd0082439b7946e440b22c3519f"></a>
MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_swap64_fallback</b> (U64 in)</td></tr>
<tr class="separator:a985c6fd0082439b7946e440b22c3519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7facc72c6a6a7d19c0cd418af86889f6"><td class="memItemLeft" align="right" valign="top"><a id="a7facc72c6a6a7d19c0cd418af86889f6"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_check</b> (void)</td></tr>
<tr class="separator:a7facc72c6a6a7d19c0cd418af86889f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e4ecc8ea4ad6359cdc9112661bfd2b"><td class="memItemLeft" align="right" valign="top">ZSTDERRORLIB_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa0e4ecc8ea4ad6359cdc9112661bfd2b">ZSTD_getErrorString</a> (ZSTD_ErrorCode code)</td></tr>
<tr class="separator:aa0e4ecc8ea4ad6359cdc9112661bfd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af8533d1342b5eedad6e03a82c3b1fe"><td class="memItemLeft" align="right" valign="top"><a id="a5af8533d1342b5eedad6e03a82c3b1fe"></a>
ERR_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ERR_isError</b> (size_t code)</td></tr>
<tr class="separator:a5af8533d1342b5eedad6e03a82c3b1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348b4470a78fb0e8e521782a860ffd95"><td class="memItemLeft" align="right" valign="top"><a id="a348b4470a78fb0e8e521782a860ffd95"></a>
ERR_STATIC ERR_enum&#160;</td><td class="memItemRight" valign="bottom"><b>ERR_getErrorCode</b> (size_t code)</td></tr>
<tr class="separator:a348b4470a78fb0e8e521782a860ffd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033c1426dcee573da273384017aaeeed"><td class="memItemLeft" align="right" valign="top"><a id="a033c1426dcee573da273384017aaeeed"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ERR_getErrorString</b> (ERR_enum code)</td></tr>
<tr class="separator:a033c1426dcee573da273384017aaeeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27eea291724029c89894e877fd1fae24"><td class="memItemLeft" align="right" valign="top"><a id="a27eea291724029c89894e877fd1fae24"></a>
ERR_STATIC const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ERR_getErrorName</b> (size_t code)</td></tr>
<tr class="separator:a27eea291724029c89894e877fd1fae24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd4435599681e40d938131f35b71208"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aadd4435599681e40d938131f35b71208">FSE_versionNumber</a> (void)</td></tr>
<tr class="separator:aadd4435599681e40d938131f35b71208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300cde07200a8b8ed1214b377fa5ab1b"><td class="memItemLeft" align="right" valign="top"><a id="a300cde07200a8b8ed1214b377fa5ab1b"></a>
FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_compressBound</b> (size_t size)</td></tr>
<tr class="separator:a300cde07200a8b8ed1214b377fa5ab1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b72bf1d6ebac556c0bcb7e5eafd72f7"><td class="memItemLeft" align="right" valign="top"><a id="a3b72bf1d6ebac556c0bcb7e5eafd72f7"></a>
FSE_PUBLIC_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_isError</b> (size_t code)</td></tr>
<tr class="separator:a3b72bf1d6ebac556c0bcb7e5eafd72f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7363e311b8ac13bf80e0f458415727b"><td class="memItemLeft" align="right" valign="top"><a id="af7363e311b8ac13bf80e0f458415727b"></a>
FSE_PUBLIC_API const char *&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_getErrorName</b> (size_t code)</td></tr>
<tr class="separator:af7363e311b8ac13bf80e0f458415727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fe7dfcc4c27edd4cc0f10d76ff0519"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad0fe7dfcc4c27edd4cc0f10d76ff0519">FSE_optimalTableLog</a> (unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue)</td></tr>
<tr class="separator:ad0fe7dfcc4c27edd4cc0f10d76ff0519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab659fb7b05c45be429e56529249b6c4"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aab659fb7b05c45be429e56529249b6c4">FSE_normalizeCount</a> (short *normalizedCounter, unsigned tableLog, const unsigned *count, size_t srcSize, unsigned maxSymbolValue, unsigned useLowProbCount)</td></tr>
<tr class="separator:aab659fb7b05c45be429e56529249b6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48aefa84ae52038efc7922d927f998a9"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a48aefa84ae52038efc7922d927f998a9">FSE_NCountWriteBound</a> (unsigned maxSymbolValue, unsigned tableLog)</td></tr>
<tr class="separator:a48aefa84ae52038efc7922d927f998a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada665be956caa74b8624b7042d289c61"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ada665be956caa74b8624b7042d289c61">FSE_writeNCount</a> (void *buffer, size_t bufferSize, const short *normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)</td></tr>
<tr class="separator:ada665be956caa74b8624b7042d289c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a83bf378068974a320feded073de7f"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a79a83bf378068974a320feded073de7f">FSE_buildCTable</a> (<a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *ct, const short *normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)</td></tr>
<tr class="separator:a79a83bf378068974a320feded073de7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe336004958f4bb7ba11ca3c847619"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#adcbe336004958f4bb7ba11ca3c847619">FSE_compress_usingCTable</a> (void *dst, size_t dstCapacity, const void *src, size_t srcSize, const <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *ct)</td></tr>
<tr class="separator:adcbe336004958f4bb7ba11ca3c847619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0aa1674b1444911966d291da574d5f0"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af0aa1674b1444911966d291da574d5f0">FSE_readNCount</a> (short *normalizedCounter, unsigned *maxSymbolValuePtr, unsigned *tableLogPtr, const void *rBuffer, size_t rBuffSize)</td></tr>
<tr class="separator:af0aa1674b1444911966d291da574d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8802383ab92b90f9c3582be513e4d0"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7d8802383ab92b90f9c3582be513e4d0">FSE_readNCount_bmi2</a> (short *normalizedCounter, unsigned *maxSymbolValuePtr, unsigned *tableLogPtr, const void *rBuffer, size_t rBuffSize, int bmi2)</td></tr>
<tr class="separator:a7d8802383ab92b90f9c3582be513e4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357c822d373030cfbc4a6716a71b8d6c"><td class="memItemLeft" align="right" valign="top"><a id="a357c822d373030cfbc4a6716a71b8d6c"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_countTrailingZeros32_fallback</b> (U32 val)</td></tr>
<tr class="separator:a357c822d373030cfbc4a6716a71b8d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea763cfedd3c787978622e74bf50e1a5"><td class="memItemLeft" align="right" valign="top"><a id="aea763cfedd3c787978622e74bf50e1a5"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_countTrailingZeros32</b> (U32 val)</td></tr>
<tr class="separator:aea763cfedd3c787978622e74bf50e1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eb6db382a59e8e8aeb386c1b38fc45"><td class="memItemLeft" align="right" valign="top"><a id="a24eb6db382a59e8e8aeb386c1b38fc45"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_countLeadingZeros32_fallback</b> (U32 val)</td></tr>
<tr class="separator:a24eb6db382a59e8e8aeb386c1b38fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87de457a5d760c09f1de736cea7b38f6"><td class="memItemLeft" align="right" valign="top"><a id="a87de457a5d760c09f1de736cea7b38f6"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_countLeadingZeros32</b> (U32 val)</td></tr>
<tr class="separator:a87de457a5d760c09f1de736cea7b38f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16089c506a0eca1589fc6b4dcb2ef26c"><td class="memItemLeft" align="right" valign="top"><a id="a16089c506a0eca1589fc6b4dcb2ef26c"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_countTrailingZeros64</b> (U64 val)</td></tr>
<tr class="separator:a16089c506a0eca1589fc6b4dcb2ef26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05d2e7750c84455b214d356f27eba20"><td class="memItemLeft" align="right" valign="top"><a id="ae05d2e7750c84455b214d356f27eba20"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_countLeadingZeros64</b> (U64 val)</td></tr>
<tr class="separator:ae05d2e7750c84455b214d356f27eba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b58ef210c7dce6d54b163c01c2787b"><td class="memItemLeft" align="right" valign="top"><a id="a05b58ef210c7dce6d54b163c01c2787b"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_NbCommonBytes</b> (size_t val)</td></tr>
<tr class="separator:a05b58ef210c7dce6d54b163c01c2787b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f06c12e5a5c0aca7c5ec877f2be0ced"><td class="memItemLeft" align="right" valign="top"><a id="a2f06c12e5a5c0aca7c5ec877f2be0ced"></a>
MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_highbit32</b> (U32 val)</td></tr>
<tr class="separator:a2f06c12e5a5c0aca7c5ec877f2be0ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadc4cc707b753748ed51e7b4d4ef3a"><td class="memItemLeft" align="right" valign="top"><a id="a9fadc4cc707b753748ed51e7b4d4ef3a"></a>
MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_rotateRight_U64</b> (U64 const value, U32 count)</td></tr>
<tr class="separator:a9fadc4cc707b753748ed51e7b4d4ef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca920b3b28d27cb4320b1c318b71c929"><td class="memItemLeft" align="right" valign="top"><a id="aca920b3b28d27cb4320b1c318b71c929"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_rotateRight_U32</b> (U32 const value, U32 count)</td></tr>
<tr class="separator:aca920b3b28d27cb4320b1c318b71c929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d9c1bfe3504066ffa0a17249c0aeda"><td class="memItemLeft" align="right" valign="top"><a id="ad1d9c1bfe3504066ffa0a17249c0aeda"></a>
MEM_STATIC U16&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_rotateRight_U16</b> (U16 const value, U32 count)</td></tr>
<tr class="separator:ad1d9c1bfe3504066ffa0a17249c0aeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77907fae42615fa580281a1b5b80b629"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a77907fae42615fa580281a1b5b80b629">BIT_initCStream</a> (<a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *bitC, void *dstBuffer, size_t dstCapacity)</td></tr>
<tr class="separator:a77907fae42615fa580281a1b5b80b629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48823f7e738bb39e6db428de599161b"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa48823f7e738bb39e6db428de599161b">BIT_addBits</a> (<a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *bitC, BitContainerType value, unsigned nbBits)</td></tr>
<tr class="separator:aa48823f7e738bb39e6db428de599161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c839965cf6a86f64d859153451ccab6"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4c839965cf6a86f64d859153451ccab6">BIT_flushBits</a> (<a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *bitC)</td></tr>
<tr class="separator:a4c839965cf6a86f64d859153451ccab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b24fd9264fb4cb14e5f9aecc26acbd"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a06b24fd9264fb4cb14e5f9aecc26acbd">BIT_closeCStream</a> (<a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *bitC)</td></tr>
<tr class="separator:a06b24fd9264fb4cb14e5f9aecc26acbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bc56df5d3b4844fd5bf6bde7393bd3"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a01bc56df5d3b4844fd5bf6bde7393bd3">BIT_initDStream</a> (<a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD, const void *srcBuffer, size_t srcSize)</td></tr>
<tr class="separator:a01bc56df5d3b4844fd5bf6bde7393bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d4701e95f21414679b1363b1d2cad7"><td class="memItemLeft" align="right" valign="top">MEM_STATIC BitContainerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a84d4701e95f21414679b1363b1d2cad7">BIT_readBits</a> (<a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD, unsigned nbBits)</td></tr>
<tr class="separator:a84d4701e95f21414679b1363b1d2cad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafff1d22e07fe1b4094557b38e44a111"><td class="memItemLeft" align="right" valign="top">MEM_STATIC BIT_DStream_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aafff1d22e07fe1b4094557b38e44a111">BIT_reloadDStream</a> (<a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD)</td></tr>
<tr class="separator:aafff1d22e07fe1b4094557b38e44a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1c18f5b36ba98fe0f9702bc74d86b1"><td class="memItemLeft" align="right" valign="top">MEM_STATIC unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8a1c18f5b36ba98fe0f9702bc74d86b1">BIT_endOfDStream</a> (const <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD)</td></tr>
<tr class="separator:a8a1c18f5b36ba98fe0f9702bc74d86b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eff282f423dfc3aa20a57d50cf4f8e9"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2eff282f423dfc3aa20a57d50cf4f8e9">BIT_addBitsFast</a> (<a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *bitC, BitContainerType value, unsigned nbBits)</td></tr>
<tr class="separator:a2eff282f423dfc3aa20a57d50cf4f8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedf7cf3cceebe81e04d22fd42971bd3"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aeedf7cf3cceebe81e04d22fd42971bd3">BIT_flushBitsFast</a> (<a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *bitC)</td></tr>
<tr class="separator:aeedf7cf3cceebe81e04d22fd42971bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbadcca4d24830dedbe2ebf5894bfaf"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#afcbadcca4d24830dedbe2ebf5894bfaf">BIT_readBitsFast</a> (<a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD, unsigned nbBits)</td></tr>
<tr class="separator:afcbadcca4d24830dedbe2ebf5894bfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef7202af0f971153e1a29c9fc2b6abb"><td class="memItemLeft" align="right" valign="top"><a id="aeef7202af0f971153e1a29c9fc2b6abb"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> BitContainerType&#160;</td><td class="memItemRight" valign="bottom"><b>BIT_getLowerBits</b> (BitContainerType bitContainer, U32 const nbBits)</td></tr>
<tr class="separator:aeef7202af0f971153e1a29c9fc2b6abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3a83341861ecb623a0539546dac165"><td class="memItemLeft" align="right" valign="top"><a id="aee3a83341861ecb623a0539546dac165"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> BitContainerType&#160;</td><td class="memItemRight" valign="bottom"><b>BIT_getUpperBits</b> (BitContainerType bitContainer, U32 const start)</td></tr>
<tr class="separator:aee3a83341861ecb623a0539546dac165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d2fc08b8ff03705833007fe82a076e"><td class="memItemLeft" align="right" valign="top"><a id="a95d2fc08b8ff03705833007fe82a076e"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> BitContainerType&#160;</td><td class="memItemRight" valign="bottom"><b>BIT_getMiddleBits</b> (BitContainerType bitContainer, U32 const start, U32 const nbBits)</td></tr>
<tr class="separator:a95d2fc08b8ff03705833007fe82a076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031ea40777b45663d375e2a41eb5e650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> BitContainerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a031ea40777b45663d375e2a41eb5e650">BIT_lookBits</a> (const <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD, U32 nbBits)</td></tr>
<tr class="separator:a031ea40777b45663d375e2a41eb5e650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e301dbc45a933652fbf9e0b5bf5072f"><td class="memItemLeft" align="right" valign="top">MEM_STATIC BitContainerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3e301dbc45a933652fbf9e0b5bf5072f">BIT_lookBitsFast</a> (const <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD, U32 nbBits)</td></tr>
<tr class="separator:a3e301dbc45a933652fbf9e0b5bf5072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d89a586d3bb6916856918a80d928fc8"><td class="memItemLeft" align="right" valign="top"><a id="a6d89a586d3bb6916856918a80d928fc8"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>BIT_skipBits</b> (<a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD, U32 nbBits)</td></tr>
<tr class="separator:a6d89a586d3bb6916856918a80d928fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5000ecd7f1ede095a7efa1df7e8e83"><td class="memItemLeft" align="right" valign="top">MEM_STATIC BIT_DStream_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aca5000ecd7f1ede095a7efa1df7e8e83">BIT_reloadDStream_internal</a> (<a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD)</td></tr>
<tr class="separator:aca5000ecd7f1ede095a7efa1df7e8e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50791a76727900102d2884fb09c3019"><td class="memItemLeft" align="right" valign="top">MEM_STATIC BIT_DStream_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad50791a76727900102d2884fb09c3019">BIT_reloadDStreamFast</a> (<a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD)</td></tr>
<tr class="separator:ad50791a76727900102d2884fb09c3019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b48bd698b011962206908be5c233e64"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5b48bd698b011962206908be5c233e64">FSE_optimalTableLog_internal</a> (unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue, unsigned minus)</td></tr>
<tr class="separator:a5b48bd698b011962206908be5c233e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991b38918a59bfa6ff384fa8d91e5924"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a991b38918a59bfa6ff384fa8d91e5924">FSE_buildCTable_rle</a> (<a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *ct, unsigned char symbolValue)</td></tr>
<tr class="separator:a991b38918a59bfa6ff384fa8d91e5924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ef3a630482b3e532474c50112421ec"><td class="memItemLeft" align="right" valign="top"><a id="a33ef3a630482b3e532474c50112421ec"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_buildCTable_wksp</b> (<a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *ct, const short *normalizedCounter, unsigned maxSymbolValue, unsigned tableLog, void *workSpace, size_t wkspSize)</td></tr>
<tr class="separator:a33ef3a630482b3e532474c50112421ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bcb1fb83cf281d2861108119597c7c"><td class="memItemLeft" align="right" valign="top">FSE_PUBLIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad5bcb1fb83cf281d2861108119597c7c">FSE_buildDTable_wksp</a> (FSE_DTable *dt, const short *normalizedCounter, unsigned maxSymbolValue, unsigned tableLog, void *workSpace, size_t wkspSize)</td></tr>
<tr class="separator:ad5bcb1fb83cf281d2861108119597c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d20cda1c8ed62dbef7b9ce571ce274c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8d20cda1c8ed62dbef7b9ce571ce274c">FSE_decompress_wksp_bmi2</a> (void *dst, size_t dstCapacity, const void *cSrc, size_t cSrcSize, unsigned maxLog, void *workSpace, size_t wkspSize, int bmi2)</td></tr>
<tr class="separator:a8d20cda1c8ed62dbef7b9ce571ce274c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2624e273b23c11c129813c95b589e3"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7f2624e273b23c11c129813c95b589e3">FSE_initCState2</a> (<a class="el" href="structFSE__CState__t.html">FSE_CState_t</a> *statePtr, const <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *ct, U32 symbol)</td></tr>
<tr class="separator:a7f2624e273b23c11c129813c95b589e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5baa3213c8d3f79a57a62b90c79459"><td class="memItemLeft" align="right" valign="top"><a id="aea5baa3213c8d3f79a57a62b90c79459"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_getMaxNbBits</b> (const void *symbolTTPtr, U32 symbolValue)</td></tr>
<tr class="separator:aea5baa3213c8d3f79a57a62b90c79459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5882f87834b13b4cb7c489b7bc886cc6"><td class="memItemLeft" align="right" valign="top"><a id="a5882f87834b13b4cb7c489b7bc886cc6"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_bitCost</b> (const void *symbolTTPtr, U32 tableLog, U32 symbolValue, U32 accuracyLog)</td></tr>
<tr class="separator:a5882f87834b13b4cb7c489b7bc886cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca1d98e2f7272cb2e7ce220bcf1275b"><td class="memItemLeft" align="right" valign="top"><a id="a0ca1d98e2f7272cb2e7ce220bcf1275b"></a>
MEM_STATIC BYTE&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_peekSymbol</b> (const <a class="el" href="structFSE__DState__t.html">FSE_DState_t</a> *DStatePtr)</td></tr>
<tr class="separator:a0ca1d98e2f7272cb2e7ce220bcf1275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba55ebfa2c8696faefe2cd0932014588"><td class="memItemLeft" align="right" valign="top"><a id="aba55ebfa2c8696faefe2cd0932014588"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_updateState</b> (<a class="el" href="structFSE__DState__t.html">FSE_DState_t</a> *DStatePtr, <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD)</td></tr>
<tr class="separator:aba55ebfa2c8696faefe2cd0932014588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d59eb211fff5bdf33704f563fe93af0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1d59eb211fff5bdf33704f563fe93af0">HUF_compressBound</a> (size_t size)</td></tr>
<tr class="separator:a1d59eb211fff5bdf33704f563fe93af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd113fa90a875ceddf133a530db912bc"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abd113fa90a875ceddf133a530db912bc">HUF_isError</a> (size_t code)</td></tr>
<tr class="separator:abd113fa90a875ceddf133a530db912bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2058676a94d9959e656bd0024e7fde97"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2058676a94d9959e656bd0024e7fde97">HUF_getErrorName</a> (size_t code)</td></tr>
<tr class="separator:a2058676a94d9959e656bd0024e7fde97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0c5354df5c8948fd993a96adf3bb29"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aec0c5354df5c8948fd993a96adf3bb29">HUF_minTableLog</a> (unsigned symbolCardinality)</td></tr>
<tr class="separator:aec0c5354df5c8948fd993a96adf3bb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d7d676c241ecf462ff78d116a0b4d7"><td class="memItemLeft" align="right" valign="top"><a id="a53d7d676c241ecf462ff78d116a0b4d7"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_cardinality</b> (const unsigned *count, unsigned maxSymbolValue)</td></tr>
<tr class="separator:a53d7d676c241ecf462ff78d116a0b4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af038d9caa766abe508c74abd0a2c4237"><td class="memItemLeft" align="right" valign="top"><a id="af038d9caa766abe508c74abd0a2c4237"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_optimalTableLog</b> (unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue, void *workSpace, size_t wkspSize, HUF_CElt *table, const unsigned *count, int flags)</td></tr>
<tr class="separator:af038d9caa766abe508c74abd0a2c4237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f621a6634304ce397e2ce808c54d1c"><td class="memItemLeft" align="right" valign="top"><a id="a51f621a6634304ce397e2ce808c54d1c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_writeCTable_wksp</b> (void *dst, size_t maxDstSize, const HUF_CElt *CTable, unsigned maxSymbolValue, unsigned huffLog, void *workspace, size_t workspaceSize)</td></tr>
<tr class="separator:a51f621a6634304ce397e2ce808c54d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fcc58074534319649ace5978cd0c9c"><td class="memItemLeft" align="right" valign="top"><a id="a89fcc58074534319649ace5978cd0c9c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_compress4X_usingCTable</b> (void *dst, size_t dstSize, const void *src, size_t srcSize, const HUF_CElt *CTable, int flags)</td></tr>
<tr class="separator:a89fcc58074534319649ace5978cd0c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99efa4915d4e6332bd71f1b84fee0e4c"><td class="memItemLeft" align="right" valign="top"><a id="a99efa4915d4e6332bd71f1b84fee0e4c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_estimateCompressedSize</b> (const HUF_CElt *CTable, const unsigned *count, unsigned maxSymbolValue)</td></tr>
<tr class="separator:a99efa4915d4e6332bd71f1b84fee0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e63fe282b49785a89a97861f92e1f6"><td class="memItemLeft" align="right" valign="top"><a id="a22e63fe282b49785a89a97861f92e1f6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_validateCTable</b> (const HUF_CElt *CTable, const unsigned *count, unsigned maxSymbolValue)</td></tr>
<tr class="separator:a22e63fe282b49785a89a97861f92e1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3feaf945233beb32ccd701396732e93"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad3feaf945233beb32ccd701396732e93">HUF_compress4X_repeat</a> (void *dst, size_t dstSize, const void *src, size_t srcSize, unsigned maxSymbolValue, unsigned tableLog, void *workSpace, size_t wkspSize, HUF_CElt *hufTable, <a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29">HUF_repeat</a> *repeat, int flags)</td></tr>
<tr class="separator:ad3feaf945233beb32ccd701396732e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bd533c548b31a0c7f4864ef2bf0704"><td class="memItemLeft" align="right" valign="top"><a id="ad2bd533c548b31a0c7f4864ef2bf0704"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_buildCTable_wksp</b> (HUF_CElt *tree, const unsigned *count, U32 maxSymbolValue, U32 maxNbBits, void *workSpace, size_t wkspSize)</td></tr>
<tr class="separator:ad2bd533c548b31a0c7f4864ef2bf0704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe44467e2590965c0dafba8df4d206c0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abe44467e2590965c0dafba8df4d206c0">HUF_readStats</a> (BYTE *huffWeight, size_t hwSize, U32 *rankStats, U32 *nbSymbolsPtr, U32 *tableLogPtr, const void *src, size_t srcSize)</td></tr>
<tr class="separator:abe44467e2590965c0dafba8df4d206c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7784ef4534541833d9dc7cd3e6c9937"><td class="memItemLeft" align="right" valign="top"><a id="ac7784ef4534541833d9dc7cd3e6c9937"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_readStats_wksp</b> (BYTE *huffWeight, size_t hwSize, U32 *rankStats, U32 *nbSymbolsPtr, U32 *tableLogPtr, const void *src, size_t srcSize, void *workspace, size_t wkspSize, int flags)</td></tr>
<tr class="separator:ac7784ef4534541833d9dc7cd3e6c9937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84c68f7351a48d41314ccf7343fd00f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae84c68f7351a48d41314ccf7343fd00f">HUF_readCTable</a> (HUF_CElt *CTable, unsigned *maxSymbolValuePtr, const void *src, size_t srcSize, unsigned *hasZeroWeights)</td></tr>
<tr class="separator:ae84c68f7351a48d41314ccf7343fd00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be050c0196368a09d7c1a678ef3d5dc"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5be050c0196368a09d7c1a678ef3d5dc">HUF_getNbBitsFromCTable</a> (const HUF_CElt *symbolTable, U32 symbolValue)</td></tr>
<tr class="separator:a5be050c0196368a09d7c1a678ef3d5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3488ca1538a51b4c89f28fbcd493939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHUF__CTableHeader.html">HUF_CTableHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac3488ca1538a51b4c89f28fbcd493939">HUF_readCTableHeader</a> (HUF_CElt const *ctable)</td></tr>
<tr class="separator:ac3488ca1538a51b4c89f28fbcd493939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319db2a71decf1639479172cc19c7e6b"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a319db2a71decf1639479172cc19c7e6b">HUF_selectDecoder</a> (size_t dstSize, size_t cSrcSize)</td></tr>
<tr class="separator:a319db2a71decf1639479172cc19c7e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac428701559575c1ce889cd9aa3d5f0bb"><td class="memItemLeft" align="right" valign="top"><a id="ac428701559575c1ce889cd9aa3d5f0bb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_compress1X_usingCTable</b> (void *dst, size_t dstSize, const void *src, size_t srcSize, const HUF_CElt *CTable, int flags)</td></tr>
<tr class="separator:ac428701559575c1ce889cd9aa3d5f0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d14775f9d3b42768c9c96dbd454f8ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8d14775f9d3b42768c9c96dbd454f8ad">HUF_compress1X_repeat</a> (void *dst, size_t dstSize, const void *src, size_t srcSize, unsigned maxSymbolValue, unsigned tableLog, void *workSpace, size_t wkspSize, HUF_CElt *hufTable, <a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29">HUF_repeat</a> *repeat, int flags)</td></tr>
<tr class="separator:a8d14775f9d3b42768c9c96dbd454f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee462716c536c6477737799e3b3a747c"><td class="memItemLeft" align="right" valign="top"><a id="aee462716c536c6477737799e3b3a747c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress1X_DCtx_wksp</b> (HUF_DTable *dctx, void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, void *workSpace, size_t wkspSize, int flags)</td></tr>
<tr class="separator:aee462716c536c6477737799e3b3a747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982c2fd95349e7646ef99ca4e2e256fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a982c2fd95349e7646ef99ca4e2e256fa">HUF_decompress1X2_DCtx_wksp</a> (HUF_DTable *dctx, void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, void *workSpace, size_t wkspSize, int flags)</td></tr>
<tr class="separator:a982c2fd95349e7646ef99ca4e2e256fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada711f1f4a0026266624dc84cfb4583a"><td class="memItemLeft" align="right" valign="top"><a id="ada711f1f4a0026266624dc84cfb4583a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress1X_usingDTable</b> (void *dst, size_t maxDstSize, const void *cSrc, size_t cSrcSize, const HUF_DTable *DTable, int flags)</td></tr>
<tr class="separator:ada711f1f4a0026266624dc84cfb4583a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b68bc4fc06559027e5c3493e8f0d42"><td class="memItemLeft" align="right" valign="top"><a id="aa4b68bc4fc06559027e5c3493e8f0d42"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress1X1_DCtx_wksp</b> (HUF_DTable *dctx, void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, void *workSpace, size_t wkspSize, int flags)</td></tr>
<tr class="separator:aa4b68bc4fc06559027e5c3493e8f0d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46190e80c84a57b2a46685db5433dca"><td class="memItemLeft" align="right" valign="top"><a id="ac46190e80c84a57b2a46685db5433dca"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress4X_usingDTable</b> (void *dst, size_t maxDstSize, const void *cSrc, size_t cSrcSize, const HUF_DTable *DTable, int flags)</td></tr>
<tr class="separator:ac46190e80c84a57b2a46685db5433dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f9080935701c8f0da790a4126c08b7"><td class="memItemLeft" align="right" valign="top"><a id="a50f9080935701c8f0da790a4126c08b7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress4X_hufOnly_wksp</b> (HUF_DTable *dctx, void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, void *workSpace, size_t wkspSize, int flags)</td></tr>
<tr class="separator:a50f9080935701c8f0da790a4126c08b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6eabee52ea2e237931415c73e9a34b6"><td class="memItemLeft" align="right" valign="top"><a id="ad6eabee52ea2e237931415c73e9a34b6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_readDTableX1_wksp</b> (HUF_DTable *DTable, const void *src, size_t srcSize, void *workSpace, size_t wkspSize, int flags)</td></tr>
<tr class="separator:ad6eabee52ea2e237931415c73e9a34b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b5ec1bd1a18cff5ceeb21af90a85e8"><td class="memItemLeft" align="right" valign="top"><a id="a15b5ec1bd1a18cff5ceeb21af90a85e8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_readDTableX2_wksp</b> (HUF_DTable *DTable, const void *src, size_t srcSize, void *workSpace, size_t wkspSize, int flags)</td></tr>
<tr class="separator:a15b5ec1bd1a18cff5ceeb21af90a85e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4285e05151836832ff026f4f9d0a41a2"><td class="memItemLeft" align="right" valign="top"><a id="a4285e05151836832ff026f4f9d0a41a2"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_readNCount_body</b> (short *normalizedCounter, unsigned *maxSVPtr, unsigned *tableLogPtr, const void *headerBuffer, size_t hbSize)</td></tr>
<tr class="separator:a4285e05151836832ff026f4f9d0a41a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157b7061ff30e541f35b5da1f9d6056a"><td class="memItemLeft" align="right" valign="top"><a id="a157b7061ff30e541f35b5da1f9d6056a"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_readStats_body</b> (BYTE *huffWeight, size_t hwSize, U32 *rankStats, U32 *nbSymbolsPtr, U32 *tableLogPtr, const void *src, size_t srcSize, void *workSpace, size_t wkspSize, int bmi2)</td></tr>
<tr class="separator:a157b7061ff30e541f35b5da1f9d6056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33a18a031cad67445e2106c97a7db9b"><td class="memItemLeft" align="right" valign="top"><a id="ad33a18a031cad67445e2106c97a7db9b"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_decompress_usingDTable_generic</b> (void *dst, size_t maxDstSize, const void *cSrc, size_t cSrcSize, const FSE_DTable *dt, const unsigned fast)</td></tr>
<tr class="separator:ad33a18a031cad67445e2106c97a7db9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2acfa3daf324ba62351b1ae72c42b68"><td class="memItemLeft" align="right" valign="top"><a id="ab2acfa3daf324ba62351b1ae72c42b68"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FSE_decompress_wksp_body</b> (void *dst, size_t dstCapacity, const void *cSrc, size_t cSrcSize, unsigned maxLog, void *workSpace, size_t wkspSize, int bmi2)</td></tr>
<tr class="separator:ab2acfa3daf324ba62351b1ae72c42b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9514c179be6ddc5ceab1ee75d631d27a"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9514c179be6ddc5ceab1ee75d631d27a">ZSTD_versionNumber</a> (void)</td></tr>
<tr class="separator:a9514c179be6ddc5ceab1ee75d631d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e9b58e46bb6e3ed78cd596aedeab4e"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a88e9b58e46bb6e3ed78cd596aedeab4e">ZSTD_versionString</a> (void)</td></tr>
<tr class="separator:a88e9b58e46bb6e3ed78cd596aedeab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10ee027998fbfbedc71961633791955"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress</a> (void *dst, size_t dstCapacity, const void *src, size_t srcSize, int compressionLevel)</td></tr>
<tr class="separator:ac10ee027998fbfbedc71961633791955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1667ea9aa85971c60ebca267d9540d9"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad1667ea9aa85971c60ebca267d9540d9">ZSTD_decompress</a> (void *dst, size_t dstCapacity, const void *src, size_t compressedSize)</td></tr>
<tr class="separator:ad1667ea9aa85971c60ebca267d9540d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5f5f8580da4af3bf95471bb2420bee"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9e5f5f8580da4af3bf95471bb2420bee">ZSTD_getFrameContentSize</a> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:a9e5f5f8580da4af3bf95471bb2420bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649e1fd37871a2dfed7833a7741735f8"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a649e1fd37871a2dfed7833a7741735f8">ZSTD_getDecompressedSize</a> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:a649e1fd37871a2dfed7833a7741735f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd57094fdf6ff305bc2bab286cade7cc"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abd57094fdf6ff305bc2bab286cade7cc">ZSTD_findFrameCompressedSize</a> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:abd57094fdf6ff305bc2bab286cade7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04413eba92e4dc84ca561de847fbcd06"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a04413eba92e4dc84ca561de847fbcd06">ZSTD_compressBound</a> (size_t srcSize)</td></tr>
<tr class="separator:a04413eba92e4dc84ca561de847fbcd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd9d17bd95d6109c21f92c569e32fd3"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError</a> (size_t result)</td></tr>
<tr class="separator:abbd9d17bd95d6109c21f92c569e32fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef04aa44c49420ae1fd65a855f7c25fc"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API ZSTD_ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aef04aa44c49420ae1fd65a855f7c25fc">ZSTD_getErrorCode</a> (size_t functionResult)</td></tr>
<tr class="separator:aef04aa44c49420ae1fd65a855f7c25fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc2497b2d23d0da90e96e669d938ce0"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7bc2497b2d23d0da90e96e669d938ce0">ZSTD_getErrorName</a> (size_t result)</td></tr>
<tr class="separator:a7bc2497b2d23d0da90e96e669d938ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1643fe2e77209052fc9266f9e0aa8a3"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac1643fe2e77209052fc9266f9e0aa8a3">ZSTD_minCLevel</a> (void)</td></tr>
<tr class="separator:ac1643fe2e77209052fc9266f9e0aa8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a3c5d5d32c4a8d758813054dfff72f"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a98a3c5d5d32c4a8d758813054dfff72f">ZSTD_maxCLevel</a> (void)</td></tr>
<tr class="separator:a98a3c5d5d32c4a8d758813054dfff72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f19080983172493738f0075a51e7fba"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5f19080983172493738f0075a51e7fba">ZSTD_defaultCLevel</a> (void)</td></tr>
<tr class="separator:a5f19080983172493738f0075a51e7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19162e0609b43660b9759265cb6232d2"><td class="memItemLeft" align="right" valign="top"><a id="a19162e0609b43660b9759265cb6232d2"></a>
ZSTDLIB_API <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createCCtx</b> (void)</td></tr>
<tr class="separator:a19162e0609b43660b9759265cb6232d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dd3d632162723ddbabe843a2ed3ed9"><td class="memItemLeft" align="right" valign="top"><a id="a42dd3d632162723ddbabe843a2ed3ed9"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_freeCCtx</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx)</td></tr>
<tr class="separator:a42dd3d632162723ddbabe843a2ed3ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16db44e4760f1b4ac38cb50ab2464a59"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a16db44e4760f1b4ac38cb50ab2464a59">ZSTD_compressCCtx</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, int compressionLevel)</td></tr>
<tr class="separator:a16db44e4760f1b4ac38cb50ab2464a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8210cc0fd796e83d90a172eea849d59"><td class="memItemLeft" align="right" valign="top"><a id="ad8210cc0fd796e83d90a172eea849d59"></a>
ZSTDLIB_API <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createDCtx</b> (void)</td></tr>
<tr class="separator:ad8210cc0fd796e83d90a172eea849d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b14d5ec4b89978356b7195346e1cbb8"><td class="memItemLeft" align="right" valign="top"><a id="a5b14d5ec4b89978356b7195346e1cbb8"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_freeDCtx</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx)</td></tr>
<tr class="separator:a5b14d5ec4b89978356b7195346e1cbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65d6c1880cffdf1120e06277a2d0a5b"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad65d6c1880cffdf1120e06277a2d0a5b">ZSTD_decompressDCtx</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:ad65d6c1880cffdf1120e06277a2d0a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34c6f9ee170db29838a57968716e28a"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API <a class="el" href="structZSTD__bounds.html">ZSTD_bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af34c6f9ee170db29838a57968716e28a">ZSTD_cParam_getBounds</a> (ZSTD_cParameter cParam)</td></tr>
<tr class="separator:af34c6f9ee170db29838a57968716e28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0122876033842c653406f9239ff64508"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0122876033842c653406f9239ff64508">ZSTD_CCtx_setParameter</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, ZSTD_cParameter param, int value)</td></tr>
<tr class="separator:a0122876033842c653406f9239ff64508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0795af794521da3907efa8fe850ed4"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8e0795af794521da3907efa8fe850ed4">ZSTD_CCtx_setPledgedSrcSize</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:a8e0795af794521da3907efa8fe850ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d7fa5aa19fa8325eec5670b1d7cf05"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a64d7fa5aa19fa8325eec5670b1d7cf05">ZSTD_CCtx_reset</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, ZSTD_ResetDirective reset)</td></tr>
<tr class="separator:a64d7fa5aa19fa8325eec5670b1d7cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48377b8080ba9ebc5651db59d4a63f3f"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a48377b8080ba9ebc5651db59d4a63f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102dc10a9332b4dcb3da3d0e5f1bfb5d"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API <a class="el" href="structZSTD__bounds.html">ZSTD_bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a102dc10a9332b4dcb3da3d0e5f1bfb5d">ZSTD_dParam_getBounds</a> (ZSTD_dParameter dParam)</td></tr>
<tr class="separator:a102dc10a9332b4dcb3da3d0e5f1bfb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4870b907a873b40e469f01127ba0232b"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4870b907a873b40e469f01127ba0232b">ZSTD_DCtx_setParameter</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, ZSTD_dParameter param, int value)</td></tr>
<tr class="separator:a4870b907a873b40e469f01127ba0232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614f5b2e6aa19d66eb91223ff23c99ed"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a614f5b2e6aa19d66eb91223ff23c99ed">ZSTD_DCtx_reset</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, ZSTD_ResetDirective reset)</td></tr>
<tr class="separator:a614f5b2e6aa19d66eb91223ff23c99ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0197e6d7e4b3789aa5edd9d23df6c9"><td class="memItemLeft" align="right" valign="top"><a id="afe0197e6d7e4b3789aa5edd9d23df6c9"></a>
ZSTDLIB_API <a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createCStream</b> (void)</td></tr>
<tr class="separator:afe0197e6d7e4b3789aa5edd9d23df6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15371b249bb15cd45e540316b0a12ee"><td class="memItemLeft" align="right" valign="top"><a id="aa15371b249bb15cd45e540316b0a12ee"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_freeCStream</b> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs)</td></tr>
<tr class="separator:aa15371b249bb15cd45e540316b0a12ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f92b06ea0440baf0763ce7104db86a5"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5f92b06ea0440baf0763ce7104db86a5">ZSTD_compressStream2</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, <a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *output, <a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer</a> *input, ZSTD_EndDirective endOp)</td></tr>
<tr class="separator:a5f92b06ea0440baf0763ce7104db86a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc1679273a9856ec0da228b33648039"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a6bc1679273a9856ec0da228b33648039">ZSTD_CStreamInSize</a> (void)</td></tr>
<tr class="separator:a6bc1679273a9856ec0da228b33648039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aa028d0ca4b708d0647952499edeb0"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab3aa028d0ca4b708d0647952499edeb0">ZSTD_CStreamOutSize</a> (void)</td></tr>
<tr class="separator:ab3aa028d0ca4b708d0647952499edeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b60144bc8895bcbc214bb6209529039"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a6b60144bc8895bcbc214bb6209529039">ZSTD_initCStream</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, int compressionLevel)</td></tr>
<tr class="separator:a6b60144bc8895bcbc214bb6209529039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0585b3bc8b65251e1bf8efcf8ca7382d"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0585b3bc8b65251e1bf8efcf8ca7382d">ZSTD_compressStream</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, <a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *output, <a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer</a> *input)</td></tr>
<tr class="separator:a0585b3bc8b65251e1bf8efcf8ca7382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526a86c539c8ed7f06a8400dccc458dd"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a526a86c539c8ed7f06a8400dccc458dd">ZSTD_flushStream</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, <a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *output)</td></tr>
<tr class="separator:a526a86c539c8ed7f06a8400dccc458dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1032e49a27beea5475f2bf91f3294116"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1032e49a27beea5475f2bf91f3294116">ZSTD_endStream</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, <a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *output)</td></tr>
<tr class="separator:a1032e49a27beea5475f2bf91f3294116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c32faa2c7383602b41f1c2c886b13c"><td class="memItemLeft" align="right" valign="top"><a id="a30c32faa2c7383602b41f1c2c886b13c"></a>
ZSTDLIB_API <a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createDStream</b> (void)</td></tr>
<tr class="separator:a30c32faa2c7383602b41f1c2c886b13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e98e9ea1278bf8c60c46ef341def281"><td class="memItemLeft" align="right" valign="top"><a id="a3e98e9ea1278bf8c60c46ef341def281"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_freeDStream</b> (<a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *zds)</td></tr>
<tr class="separator:a3e98e9ea1278bf8c60c46ef341def281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a019b45680ffdceacb717fd2f9cc02c"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a6a019b45680ffdceacb717fd2f9cc02c">ZSTD_initDStream</a> (<a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *zds)</td></tr>
<tr class="separator:a6a019b45680ffdceacb717fd2f9cc02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccda24ca50a1a35ea76a97b13edf398"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4ccda24ca50a1a35ea76a97b13edf398">ZSTD_decompressStream</a> (<a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *zds, <a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *output, <a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer</a> *input)</td></tr>
<tr class="separator:a4ccda24ca50a1a35ea76a97b13edf398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b2f64ffe93385932276d5776ae44c2"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab4b2f64ffe93385932276d5776ae44c2">ZSTD_DStreamInSize</a> (void)</td></tr>
<tr class="separator:ab4b2f64ffe93385932276d5776ae44c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8b9180d51fed828bdddf1fc970cc58"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9a8b9180d51fed828bdddf1fc970cc58">ZSTD_DStreamOutSize</a> (void)</td></tr>
<tr class="separator:a9a8b9180d51fed828bdddf1fc970cc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c959b4c56ac1f67e2a7b55a41184363"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9c959b4c56ac1f67e2a7b55a41184363">ZSTD_compress_usingDict</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *ctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, const void *dict, size_t dictSize, int compressionLevel)</td></tr>
<tr class="separator:a9c959b4c56ac1f67e2a7b55a41184363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618de4daf5319f07706ab01385292416"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a618de4daf5319f07706ab01385292416">ZSTD_decompress_usingDict</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, const void *dict, size_t dictSize)</td></tr>
<tr class="separator:a618de4daf5319f07706ab01385292416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab922a70d7520918a7d8def0dd138412"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aab922a70d7520918a7d8def0dd138412">ZSTD_createCDict</a> (const void *dictBuffer, size_t dictSize, int compressionLevel)</td></tr>
<tr class="separator:aab922a70d7520918a7d8def0dd138412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163bfbf4f7ece81967178ebc86f17667"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a163bfbf4f7ece81967178ebc86f17667">ZSTD_freeCDict</a> (<a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *CDict)</td></tr>
<tr class="separator:a163bfbf4f7ece81967178ebc86f17667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380e2bdc1072dec0c666044902403497"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a380e2bdc1072dec0c666044902403497">ZSTD_compress_usingCDict</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict)</td></tr>
<tr class="separator:a380e2bdc1072dec0c666044902403497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3598dadc58ed1b40f84c85f6da72a2"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4f3598dadc58ed1b40f84c85f6da72a2">ZSTD_createDDict</a> (const void *dictBuffer, size_t dictSize)</td></tr>
<tr class="separator:a4f3598dadc58ed1b40f84c85f6da72a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652594c16c4a53519a22ceac780a1158"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a652594c16c4a53519a22ceac780a1158">ZSTD_freeDDict</a> (<a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:a652594c16c4a53519a22ceac780a1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae313caadb1f107f1902ee7b5e1fd20a0"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae313caadb1f107f1902ee7b5e1fd20a0">ZSTD_decompress_usingDDict</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:ae313caadb1f107f1902ee7b5e1fd20a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edd273c98a72589bca72c7d66334748"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9edd273c98a72589bca72c7d66334748">ZSTD_getDictID_fromDict</a> (const void *dict, size_t dictSize)</td></tr>
<tr class="separator:a9edd273c98a72589bca72c7d66334748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71788eb03810e9b989c90534d6edb9f0"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a71788eb03810e9b989c90534d6edb9f0">ZSTD_getDictID_fromCDict</a> (const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict)</td></tr>
<tr class="separator:a71788eb03810e9b989c90534d6edb9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220ae369de09fde1ed3b71dd270ed6a6"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a220ae369de09fde1ed3b71dd270ed6a6">ZSTD_getDictID_fromDDict</a> (const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:a220ae369de09fde1ed3b71dd270ed6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e949ff08af79fcbe990465a055aaa5"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a87e949ff08af79fcbe990465a055aaa5">ZSTD_getDictID_fromFrame</a> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:a87e949ff08af79fcbe990465a055aaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f03e49aafdf252d4e9a10fdee0db68b"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9f03e49aafdf252d4e9a10fdee0db68b">ZSTD_CCtx_loadDictionary</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const void *dict, size_t dictSize)</td></tr>
<tr class="separator:a9f03e49aafdf252d4e9a10fdee0db68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3427f20d2276510d9a69db51e7d85"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a6ae3427f20d2276510d9a69db51e7d85">ZSTD_CCtx_refCDict</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict)</td></tr>
<tr class="separator:a6ae3427f20d2276510d9a69db51e7d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178ca3471ba2633b712683b3d6bea5f2"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a178ca3471ba2633b712683b3d6bea5f2">ZSTD_CCtx_refPrefix</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const void *prefix, size_t prefixSize)</td></tr>
<tr class="separator:a178ca3471ba2633b712683b3d6bea5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bcbfbf1f53a0a76b766e4b7a125e17"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a37bcbfbf1f53a0a76b766e4b7a125e17">ZSTD_DCtx_loadDictionary</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *dict, size_t dictSize)</td></tr>
<tr class="separator:a37bcbfbf1f53a0a76b766e4b7a125e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa204feb870502bcdf04f232f6aa1ee58"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa204feb870502bcdf04f232f6aa1ee58">ZSTD_DCtx_refDDict</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:aa204feb870502bcdf04f232f6aa1ee58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46706743c1bb9d7e6158635719f53caa"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a46706743c1bb9d7e6158635719f53caa">ZSTD_DCtx_refPrefix</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *prefix, size_t prefixSize)</td></tr>
<tr class="separator:a46706743c1bb9d7e6158635719f53caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a810611d44d7c2f604c6bc4bd677ed3"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0a810611d44d7c2f604c6bc4bd677ed3">ZSTD_sizeof_CCtx</a> (const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx)</td></tr>
<tr class="separator:a0a810611d44d7c2f604c6bc4bd677ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd5e8f8c2c9dd7c90d17e033fee130d"><td class="memItemLeft" align="right" valign="top"><a id="a6cd5e8f8c2c9dd7c90d17e033fee130d"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_sizeof_DCtx</b> (const <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx)</td></tr>
<tr class="separator:a6cd5e8f8c2c9dd7c90d17e033fee130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa848564b41f5a074b00a5e3e9f36a085"><td class="memItemLeft" align="right" valign="top"><a id="aa848564b41f5a074b00a5e3e9f36a085"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_sizeof_CStream</b> (const <a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs)</td></tr>
<tr class="separator:aa848564b41f5a074b00a5e3e9f36a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eea12dc97367e4f204c15b576876da"><td class="memItemLeft" align="right" valign="top"><a id="a36eea12dc97367e4f204c15b576876da"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_sizeof_DStream</b> (const <a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *zds)</td></tr>
<tr class="separator:a36eea12dc97367e4f204c15b576876da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95851012453864dedfa83ae6bea41ee9"><td class="memItemLeft" align="right" valign="top"><a id="a95851012453864dedfa83ae6bea41ee9"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_sizeof_CDict</b> (const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict)</td></tr>
<tr class="separator:a95851012453864dedfa83ae6bea41ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af942918c82a467ec60f6b074e2320fb8"><td class="memItemLeft" align="right" valign="top"><a id="af942918c82a467ec60f6b074e2320fb8"></a>
ZSTDLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_sizeof_DDict</b> (const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:af942918c82a467ec60f6b074e2320fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1783c67ba35d176f3dc849ca64e03e4"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab1783c67ba35d176f3dc849ca64e03e4">ZSTD_findDecompressedSize</a> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:ab1783c67ba35d176f3dc849ca64e03e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb06c2696dff08081184a1d5944a3946"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#adb06c2696dff08081184a1d5944a3946">ZSTD_decompressBound</a> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:adb06c2696dff08081184a1d5944a3946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da67395f18e3c94c2808cc4e7cc12a4"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9da67395f18e3c94c2808cc4e7cc12a4">ZSTD_frameHeaderSize</a> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:a9da67395f18e3c94c2808cc4e7cc12a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff97a2bf22193cbc22660738a34b09e6"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aff97a2bf22193cbc22660738a34b09e6">ZSTD_getFrameHeader</a> (<a class="el" href="structZSTD__FrameHeader.html">ZSTD_FrameHeader</a> *zfhPtr, const void *src, size_t srcSize)</td></tr>
<tr class="separator:aff97a2bf22193cbc22660738a34b09e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a477ddc60a332b675db0a8f1c0cac8e"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7a477ddc60a332b675db0a8f1c0cac8e">ZSTD_getFrameHeader_advanced</a> (<a class="el" href="structZSTD__FrameHeader.html">ZSTD_FrameHeader</a> *zfhPtr, const void *src, size_t srcSize, ZSTD_format_e format)</td></tr>
<tr class="separator:a7a477ddc60a332b675db0a8f1c0cac8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac079fdb80692d42f2ea5421bd83f8542"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac079fdb80692d42f2ea5421bd83f8542">ZSTD_decompressionMargin</a> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:ac079fdb80692d42f2ea5421bd83f8542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a83864277b6c6c6387cda028851100"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a66a83864277b6c6c6387cda028851100">ZSTD_sequenceBound</a> (size_t srcSize)</td></tr>
<tr class="separator:a66a83864277b6c6c6387cda028851100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fe7ad6ed4c7b4c9fbde2472650dd0e"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a73fe7ad6ed4c7b4c9fbde2472650dd0e">ZSTD_generateSequences</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *zc, <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *outSeqs, size_t outSeqsCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a73fe7ad6ed4c7b4c9fbde2472650dd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d70fd7f4b968b28b5bbaceed675e4d9"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3d70fd7f4b968b28b5bbaceed675e4d9">ZSTD_mergeBlockDelimiters</a> (<a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *sequences, size_t seqsSize)</td></tr>
<tr class="separator:a3d70fd7f4b968b28b5bbaceed675e4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea6e28236d8dc969c6296ab7896926c"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3ea6e28236d8dc969c6296ab7896926c">ZSTD_compressSequences</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *inSeqs, size_t inSeqsSize, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a3ea6e28236d8dc969c6296ab7896926c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88e972599baf04b649a83026907b484"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab88e972599baf04b649a83026907b484">ZSTD_compressSequencesAndLiterals</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *inSeqs, size_t nbSequences, const void *literals, size_t litSize, size_t litBufCapacity, size_t decompressedSize)</td></tr>
<tr class="separator:ab88e972599baf04b649a83026907b484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b7454a690528d1416a42c3047d0981"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a12b7454a690528d1416a42c3047d0981">ZSTD_writeSkippableFrame</a> (void *dst, size_t dstCapacity, const void *src, size_t srcSize, unsigned magicVariant)</td></tr>
<tr class="separator:a12b7454a690528d1416a42c3047d0981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75d4dcdac1651618b3bc792957181d8"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af75d4dcdac1651618b3bc792957181d8">ZSTD_readSkippableFrame</a> (void *dst, size_t dstCapacity, unsigned *magicVariant, const void *src, size_t srcSize)</td></tr>
<tr class="separator:af75d4dcdac1651618b3bc792957181d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf7dde6fc5edae03ee53dfccdce9d47"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8bf7dde6fc5edae03ee53dfccdce9d47">ZSTD_isSkippableFrame</a> (const void *buffer, size_t size)</td></tr>
<tr class="separator:a8bf7dde6fc5edae03ee53dfccdce9d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fc7a8d35315185605a25fd8c7d7b51"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa2fc7a8d35315185605a25fd8c7d7b51">ZSTD_estimateCCtxSize</a> (int maxCompressionLevel)</td></tr>
<tr class="separator:aa2fc7a8d35315185605a25fd8c7d7b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbe06c0dfbe79ca6b5a067a1a099b86"><td class="memItemLeft" align="right" valign="top"><a id="a1bbe06c0dfbe79ca6b5a067a1a099b86"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_estimateCCtxSize_usingCParams</b> (<a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> cParams)</td></tr>
<tr class="separator:a1bbe06c0dfbe79ca6b5a067a1a099b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2ffef7fca23fe793f1fa2b3127e15c"><td class="memItemLeft" align="right" valign="top"><a id="acc2ffef7fca23fe793f1fa2b3127e15c"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_estimateCCtxSize_usingCCtxParams</b> (const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params)</td></tr>
<tr class="separator:acc2ffef7fca23fe793f1fa2b3127e15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528a7edbf878a732601d012f626dc568"><td class="memItemLeft" align="right" valign="top"><a id="a528a7edbf878a732601d012f626dc568"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_estimateDCtxSize</b> (void)</td></tr>
<tr class="separator:a528a7edbf878a732601d012f626dc568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742e99e45f0994e0771caa9e9922363e"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a742e99e45f0994e0771caa9e9922363e">ZSTD_estimateCStreamSize</a> (int maxCompressionLevel)</td></tr>
<tr class="separator:a742e99e45f0994e0771caa9e9922363e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d4eb6a3afa8b942541a703b5564e7"><td class="memItemLeft" align="right" valign="top"><a id="aad9d4eb6a3afa8b942541a703b5564e7"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_estimateCStreamSize_usingCParams</b> (<a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> cParams)</td></tr>
<tr class="separator:aad9d4eb6a3afa8b942541a703b5564e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380d9dbec1b66dd31942f0423624b1d0"><td class="memItemLeft" align="right" valign="top"><a id="a380d9dbec1b66dd31942f0423624b1d0"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_estimateCStreamSize_usingCCtxParams</b> (const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params)</td></tr>
<tr class="separator:a380d9dbec1b66dd31942f0423624b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab190eff81253fb376c5d94fb1f3775f8"><td class="memItemLeft" align="right" valign="top"><a id="ab190eff81253fb376c5d94fb1f3775f8"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_estimateDStreamSize</b> (size_t maxWindowSize)</td></tr>
<tr class="separator:ab190eff81253fb376c5d94fb1f3775f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4137fc1d0a7492f8ddaa234f8dbab0c9"><td class="memItemLeft" align="right" valign="top"><a id="a4137fc1d0a7492f8ddaa234f8dbab0c9"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_estimateDStreamSize_fromFrame</b> (const void *src, size_t srcSize)</td></tr>
<tr class="separator:a4137fc1d0a7492f8ddaa234f8dbab0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a1d21490a08200ea600cae0fb3e350"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af5a1d21490a08200ea600cae0fb3e350">ZSTD_estimateCDictSize</a> (size_t dictSize, int compressionLevel)</td></tr>
<tr class="separator:af5a1d21490a08200ea600cae0fb3e350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c84a6149f417966cf33b72f074b010d"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5c84a6149f417966cf33b72f074b010d">ZSTD_estimateCDictSize_advanced</a> (size_t dictSize, <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> cParams, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod)</td></tr>
<tr class="separator:a5c84a6149f417966cf33b72f074b010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58508bbc810517a70a002961b9aa855c"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a58508bbc810517a70a002961b9aa855c">ZSTD_estimateDDictSize</a> (size_t dictSize, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod)</td></tr>
<tr class="separator:a58508bbc810517a70a002961b9aa855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546bc4b164b95226389a530c50782860"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a546bc4b164b95226389a530c50782860">ZSTD_initStaticCCtx</a> (void *workspace, size_t workspaceSize)</td></tr>
<tr class="separator:a546bc4b164b95226389a530c50782860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335eee8a5e5b93b43017b2d71f5e9535"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a335eee8a5e5b93b43017b2d71f5e9535">ZSTD_initStaticCStream</a> (void *workspace, size_t workspaceSize)</td></tr>
<tr class="separator:a335eee8a5e5b93b43017b2d71f5e9535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3aca59968d2483416a266e677e943f"><td class="memItemLeft" align="right" valign="top"><a id="a2c3aca59968d2483416a266e677e943f"></a>
ZSTDLIB_STATIC_API <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_initStaticDCtx</b> (void *workspace, size_t workspaceSize)</td></tr>
<tr class="separator:a2c3aca59968d2483416a266e677e943f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7217d0e1ebb5d623eb163584602ee736"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7217d0e1ebb5d623eb163584602ee736">ZSTD_initStaticDStream</a> (void *workspace, size_t workspaceSize)</td></tr>
<tr class="separator:a7217d0e1ebb5d623eb163584602ee736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af423c780d1eb3dc57c4e2a1446c4c59a"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af423c780d1eb3dc57c4e2a1446c4c59a">ZSTD_initStaticCDict</a> (void *workspace, size_t workspaceSize, const void *dict, size_t dictSize, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod, ZSTD_dictContentType_e dictContentType, <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> cParams)</td></tr>
<tr class="separator:af423c780d1eb3dc57c4e2a1446c4c59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3fa5d99791dda3d56edca352849337"><td class="memItemLeft" align="right" valign="top"><a id="adb3fa5d99791dda3d56edca352849337"></a>
ZSTDLIB_STATIC_API const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_initStaticDDict</b> (void *workspace, size_t workspaceSize, const void *dict, size_t dictSize, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod, ZSTD_dictContentType_e dictContentType)</td></tr>
<tr class="separator:adb3fa5d99791dda3d56edca352849337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4074ffa945106459b1003923298358"><td class="memItemLeft" align="right" valign="top"><a id="a1b4074ffa945106459b1003923298358"></a>
ZSTDLIB_STATIC_API <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createCCtx_advanced</b> (<a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:a1b4074ffa945106459b1003923298358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9358539569236faa272b87de49c439ac"><td class="memItemLeft" align="right" valign="top"><a id="a9358539569236faa272b87de49c439ac"></a>
ZSTDLIB_STATIC_API <a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createCStream_advanced</b> (<a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:a9358539569236faa272b87de49c439ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ec949547025d26fef9afbd4b24fe1e"><td class="memItemLeft" align="right" valign="top"><a id="ae5ec949547025d26fef9afbd4b24fe1e"></a>
ZSTDLIB_STATIC_API <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createDCtx_advanced</b> (<a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:ae5ec949547025d26fef9afbd4b24fe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b1942b25c8ac04b5f1e677553e60a3"><td class="memItemLeft" align="right" valign="top"><a id="a58b1942b25c8ac04b5f1e677553e60a3"></a>
ZSTDLIB_STATIC_API <a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createDStream_advanced</b> (<a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:a58b1942b25c8ac04b5f1e677553e60a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9c08cedf623879d92e8439669291df"><td class="memItemLeft" align="right" valign="top"><a id="aad9c08cedf623879d92e8439669291df"></a>
ZSTDLIB_STATIC_API <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createCDict_advanced</b> (const void *dict, size_t dictSize, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod, ZSTD_dictContentType_e dictContentType, <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> cParams, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:aad9c08cedf623879d92e8439669291df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad2d9adbe713a6024180be01d7fcc53"><td class="memItemLeft" align="right" valign="top"><a id="acad2d9adbe713a6024180be01d7fcc53"></a>
ZSTDLIB_STATIC_API <a class="el" href="zstd_8c.html#aa979b4b649aec2c11af1876dcae1590a">ZSTD_threadPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createThreadPool</b> (size_t numThreads)</td></tr>
<tr class="separator:acad2d9adbe713a6024180be01d7fcc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2f1936b45d78a859393b6cce4c0720"><td class="memItemLeft" align="right" valign="top"><a id="a1c2f1936b45d78a859393b6cce4c0720"></a>
ZSTDLIB_STATIC_API void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_freeThreadPool</b> (<a class="el" href="zstd_8c.html#aa979b4b649aec2c11af1876dcae1590a">ZSTD_threadPool</a> *pool)</td></tr>
<tr class="separator:a1c2f1936b45d78a859393b6cce4c0720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0478d528e7f323f696a0dc2be751223"><td class="memItemLeft" align="right" valign="top"><a id="ac0478d528e7f323f696a0dc2be751223"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_CCtx_refThreadPool</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, <a class="el" href="zstd_8c.html#aa979b4b649aec2c11af1876dcae1590a">ZSTD_threadPool</a> *pool)</td></tr>
<tr class="separator:ac0478d528e7f323f696a0dc2be751223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f454716f8836806425d766843b54bf"><td class="memItemLeft" align="right" valign="top"><a id="ac3f454716f8836806425d766843b54bf"></a>
ZSTDLIB_STATIC_API <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createCDict_advanced2</b> (const void *dict, size_t dictSize, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod, ZSTD_dictContentType_e dictContentType, const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *cctxParams, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:ac3f454716f8836806425d766843b54bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a772876384dedb4c511c4b37f79e56"><td class="memItemLeft" align="right" valign="top"><a id="a09a772876384dedb4c511c4b37f79e56"></a>
ZSTDLIB_STATIC_API <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_createDDict_advanced</b> (const void *dict, size_t dictSize, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod, ZSTD_dictContentType_e dictContentType, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:a09a772876384dedb4c511c4b37f79e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166359d0f6b1e6cfa6e1c51431e652a7"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a166359d0f6b1e6cfa6e1c51431e652a7">ZSTD_createCDict_byReference</a> (const void *dictBuffer, size_t dictSize, int compressionLevel)</td></tr>
<tr class="separator:a166359d0f6b1e6cfa6e1c51431e652a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ff760b75dc576f1cd0d2f9b2aab232"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams</a> (int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize)</td></tr>
<tr class="separator:ae0ff760b75dc576f1cd0d2f9b2aab232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7405de0de5192513fdc308082a88d926"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7405de0de5192513fdc308082a88d926">ZSTD_getParams</a> (int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize)</td></tr>
<tr class="separator:a7405de0de5192513fdc308082a88d926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4886f5f0746fa3fa8087093f68268c83"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4886f5f0746fa3fa8087093f68268c83">ZSTD_checkCParams</a> (<a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> params)</td></tr>
<tr class="separator:a4886f5f0746fa3fa8087093f68268c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788dffccbc0311102d8967c19ef9ab00"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a788dffccbc0311102d8967c19ef9ab00">ZSTD_adjustCParams</a> (<a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> cPar, unsigned long long srcSize, size_t dictSize)</td></tr>
<tr class="separator:a788dffccbc0311102d8967c19ef9ab00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05dc78925b27575799a234510c7d943"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af05dc78925b27575799a234510c7d943">ZSTD_CCtx_setCParams</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> cparams)</td></tr>
<tr class="separator:af05dc78925b27575799a234510c7d943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c2840a792656d0505b3e3ab0349067"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a32c2840a792656d0505b3e3ab0349067">ZSTD_CCtx_setFParams</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, <a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a> fparams)</td></tr>
<tr class="separator:a32c2840a792656d0505b3e3ab0349067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0e49ff9f3cb87838b1361847c4bc81"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aaa0e49ff9f3cb87838b1361847c4bc81">ZSTD_CCtx_setParams</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, <a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a> params)</td></tr>
<tr class="separator:aaa0e49ff9f3cb87838b1361847c4bc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb07ba1ea20a71939fc9b3c87f6050ad"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abb07ba1ea20a71939fc9b3c87f6050ad">ZSTD_compress_advanced</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, const void *dict, size_t dictSize, <a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a> params)</td></tr>
<tr class="separator:abb07ba1ea20a71939fc9b3c87f6050ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ead21650381561d00d2aaccb4e0b35"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af6ead21650381561d00d2aaccb4e0b35">ZSTD_compress_usingCDict_advanced</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict, <a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a> fParams)</td></tr>
<tr class="separator:af6ead21650381561d00d2aaccb4e0b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e1c921172c34cfaaad95ffc265d519"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a62e1c921172c34cfaaad95ffc265d519">ZSTD_CCtx_loadDictionary_byReference</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const void *dict, size_t dictSize)</td></tr>
<tr class="separator:a62e1c921172c34cfaaad95ffc265d519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c3c12ac624808016b5d8d0fb88bf84"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae8c3c12ac624808016b5d8d0fb88bf84">ZSTD_CCtx_loadDictionary_advanced</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const void *dict, size_t dictSize, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod, ZSTD_dictContentType_e dictContentType)</td></tr>
<tr class="separator:ae8c3c12ac624808016b5d8d0fb88bf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9de20b252b866996cd926c918c9504e"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae9de20b252b866996cd926c918c9504e">ZSTD_CCtx_refPrefix_advanced</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const void *prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType)</td></tr>
<tr class="separator:ae9de20b252b866996cd926c918c9504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab714f666f79d800d7e9f41334bb46c40"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab714f666f79d800d7e9f41334bb46c40">ZSTD_CCtx_getParameter</a> (const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, ZSTD_cParameter param, int *value)</td></tr>
<tr class="separator:ab714f666f79d800d7e9f41334bb46c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6105f6c1c1da52b3baf3a103fc3a8e49"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a6105f6c1c1da52b3baf3a103fc3a8e49">ZSTD_createCCtxParams</a> (void)</td></tr>
<tr class="separator:a6105f6c1c1da52b3baf3a103fc3a8e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2124e61a0391c70162a6b43359efa3a9"><td class="memItemLeft" align="right" valign="top"><a id="a2124e61a0391c70162a6b43359efa3a9"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_freeCCtxParams</b> (<a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params)</td></tr>
<tr class="separator:a2124e61a0391c70162a6b43359efa3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b30080999e29979948d5ef79396f5f"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae0b30080999e29979948d5ef79396f5f">ZSTD_CCtxParams_reset</a> (<a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params)</td></tr>
<tr class="separator:ae0b30080999e29979948d5ef79396f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f42ebe0ca87800289f2c83f6f529e9d"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5f42ebe0ca87800289f2c83f6f529e9d">ZSTD_CCtxParams_init</a> (<a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *cctxParams, int compressionLevel)</td></tr>
<tr class="separator:a5f42ebe0ca87800289f2c83f6f529e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0b5ad81ba3800d9cab1081a2e3b370"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#afd0b5ad81ba3800d9cab1081a2e3b370">ZSTD_CCtxParams_init_advanced</a> (<a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *cctxParams, <a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a> params)</td></tr>
<tr class="separator:afd0b5ad81ba3800d9cab1081a2e3b370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d05d6678c081447914362b2fd2ef7ea"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1d05d6678c081447914362b2fd2ef7ea">ZSTD_CCtxParams_setParameter</a> (<a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params, ZSTD_cParameter param, int value)</td></tr>
<tr class="separator:a1d05d6678c081447914362b2fd2ef7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c342690d88fe4d7a0ce195503eddb9"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad5c342690d88fe4d7a0ce195503eddb9">ZSTD_CCtxParams_getParameter</a> (const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params, ZSTD_cParameter param, int *value)</td></tr>
<tr class="separator:ad5c342690d88fe4d7a0ce195503eddb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f72c1097785403f80e261846cdb50b0"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9f72c1097785403f80e261846cdb50b0">ZSTD_CCtx_setParametersUsingCCtxParams</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params)</td></tr>
<tr class="separator:a9f72c1097785403f80e261846cdb50b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f77cdd326d5d47edbb3d0d66c1f719"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a06f77cdd326d5d47edbb3d0d66c1f719">ZSTD_compressStream2_simpleArgs</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, size_t *dstPos, const void *src, size_t srcSize, size_t *srcPos, ZSTD_EndDirective endOp)</td></tr>
<tr class="separator:a06f77cdd326d5d47edbb3d0d66c1f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf200ef640d9d65be6c6fac35c6aebda"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#acf200ef640d9d65be6c6fac35c6aebda">ZSTD_isFrame</a> (const void *buffer, size_t size)</td></tr>
<tr class="separator:acf200ef640d9d65be6c6fac35c6aebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df88e8b7d1663f64b4bdee696299ac1"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8df88e8b7d1663f64b4bdee696299ac1">ZSTD_createDDict_byReference</a> (const void *dictBuffer, size_t dictSize)</td></tr>
<tr class="separator:a8df88e8b7d1663f64b4bdee696299ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2444c8710a8e1edebc1a322ad4eb4553"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2444c8710a8e1edebc1a322ad4eb4553">ZSTD_DCtx_loadDictionary_byReference</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *dict, size_t dictSize)</td></tr>
<tr class="separator:a2444c8710a8e1edebc1a322ad4eb4553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c12ba2f1a31fbffd29b18db1937a8eb"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0c12ba2f1a31fbffd29b18db1937a8eb">ZSTD_DCtx_loadDictionary_advanced</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *dict, size_t dictSize, <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a> dictLoadMethod, ZSTD_dictContentType_e dictContentType)</td></tr>
<tr class="separator:a0c12ba2f1a31fbffd29b18db1937a8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f18b59b255826da90bc7403a11b60be"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7f18b59b255826da90bc7403a11b60be">ZSTD_DCtx_refPrefix_advanced</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType)</td></tr>
<tr class="separator:a7f18b59b255826da90bc7403a11b60be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7beb5c17c0ab64569b170dc3498aaee"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae7beb5c17c0ab64569b170dc3498aaee">ZSTD_DCtx_setMaxWindowSize</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, size_t maxWindowSize)</td></tr>
<tr class="separator:ae7beb5c17c0ab64569b170dc3498aaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdc640dacd339aeea1dcd84b3c7f4a0"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0fdc640dacd339aeea1dcd84b3c7f4a0">ZSTD_DCtx_getParameter</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, ZSTD_dParameter param, int *value)</td></tr>
<tr class="separator:a0fdc640dacd339aeea1dcd84b3c7f4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a62a9595a445da5dabaf411235127e"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a95a62a9595a445da5dabaf411235127e">ZSTD_DCtx_setFormat</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, ZSTD_format_e format)</td></tr>
<tr class="separator:a95a62a9595a445da5dabaf411235127e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf891757361cebbc29be37c8228202d4"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#acf891757361cebbc29be37c8228202d4">ZSTD_decompressStream_simpleArgs</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t dstCapacity, size_t *dstPos, const void *src, size_t srcSize, size_t *srcPos)</td></tr>
<tr class="separator:acf891757361cebbc29be37c8228202d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2c3cdba14edfbcaec1d2d04c3c6be8"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9b2c3cdba14edfbcaec1d2d04c3c6be8">ZSTD_initCStream_srcSize</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, int compressionLevel, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:a9b2c3cdba14edfbcaec1d2d04c3c6be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbfb3dd2cf3a661417dc6aed8c50bb0"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9bbfb3dd2cf3a661417dc6aed8c50bb0">ZSTD_initCStream_usingDict</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, const void *dict, size_t dictSize, int compressionLevel)</td></tr>
<tr class="separator:a9bbfb3dd2cf3a661417dc6aed8c50bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1721218446169ecdacca560ced7ae3"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aab1721218446169ecdacca560ced7ae3">ZSTD_initCStream_advanced</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, const void *dict, size_t dictSize, <a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a> params, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:aab1721218446169ecdacca560ced7ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b0b13da1840a10013a46f4b0c0e20d"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a09b0b13da1840a10013a46f4b0c0e20d">ZSTD_initCStream_usingCDict</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict)</td></tr>
<tr class="separator:a09b0b13da1840a10013a46f4b0c0e20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdba91ef84207e599df426633f8b94d"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5bdba91ef84207e599df426633f8b94d">ZSTD_initCStream_usingCDict_advanced</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict, <a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a> fParams, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:a5bdba91ef84207e599df426633f8b94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26382abc133c15147af8501c19b66db7"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a26382abc133c15147af8501c19b66db7">ZSTD_resetCStream</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:a26382abc133c15147af8501c19b66db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6978b81a42db7756726b08a2b87f673"><td class="memItemLeft" align="right" valign="top"><a id="aa6978b81a42db7756726b08a2b87f673"></a>
ZSTDLIB_STATIC_API <a class="el" href="structZSTD__frameProgression.html">ZSTD_frameProgression</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_getFrameProgression</b> (const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx)</td></tr>
<tr class="separator:aa6978b81a42db7756726b08a2b87f673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d02b3a890470f88ff278cbf56a2545"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a69d02b3a890470f88ff278cbf56a2545">ZSTD_toFlushNow</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx)</td></tr>
<tr class="separator:a69d02b3a890470f88ff278cbf56a2545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd20682299443222dcbd71b1db0ae29e"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#acd20682299443222dcbd71b1db0ae29e">ZSTD_initDStream_usingDict</a> (<a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *zds, const void *dict, size_t dictSize)</td></tr>
<tr class="separator:acd20682299443222dcbd71b1db0ae29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e888f5bf6ca75c11876d3173a87f56d"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3e888f5bf6ca75c11876d3173a87f56d">ZSTD_initDStream_usingDDict</a> (<a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *zds, const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:a3e888f5bf6ca75c11876d3173a87f56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1259efc8de4e58cbb0a08f1067fb1b"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5d1259efc8de4e58cbb0a08f1067fb1b">ZSTD_resetDStream</a> (<a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *zds)</td></tr>
<tr class="separator:a5d1259efc8de4e58cbb0a08f1067fb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b046dad80364659876af1447f09f63"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a82b046dad80364659876af1447f09f63">ZSTD_registerSequenceProducer</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *sequenceProducerState, ZSTD_sequenceProducer_F sequenceProducer)</td></tr>
<tr class="separator:a82b046dad80364659876af1447f09f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c553672fcaa18286712cc650a2b8b93"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8c553672fcaa18286712cc650a2b8b93">ZSTD_CCtxParams_registerSequenceProducer</a> (<a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params, void *sequenceProducerState, ZSTD_sequenceProducer_F sequenceProducer)</td></tr>
<tr class="separator:a8c553672fcaa18286712cc650a2b8b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358ee3d278050504ecc5b10ce412659"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2358ee3d278050504ecc5b10ce412659">ZSTD_compressBegin</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, int compressionLevel)</td></tr>
<tr class="separator:a2358ee3d278050504ecc5b10ce412659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a0b466e8a723140957dfea338ed559"><td class="memItemLeft" align="right" valign="top"><a id="a00a0b466e8a723140957dfea338ed559"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBegin_usingDict</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const void *dict, size_t dictSize, int compressionLevel)</td></tr>
<tr class="separator:a00a0b466e8a723140957dfea338ed559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f4b4d57189368d6467e6681b0bc90d"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a25f4b4d57189368d6467e6681b0bc90d">ZSTD_compressBegin_usingCDict</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict)</td></tr>
<tr class="separator:a25f4b4d57189368d6467e6681b0bc90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac1086436297ae878a8d658547dbe58"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8ac1086436297ae878a8d658547dbe58">ZSTD_copyCCtx</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *preparedCCtx, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:a8ac1086436297ae878a8d658547dbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00d2a334eb96923cae6e1918cd674ef"><td class="memItemLeft" align="right" valign="top"><a id="aa00d2a334eb96923cae6e1918cd674ef"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressContinue</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:aa00d2a334eb96923cae6e1918cd674ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a45d885f97e1a611b0a5b8dc3bb40b"><td class="memItemLeft" align="right" valign="top"><a id="a77a45d885f97e1a611b0a5b8dc3bb40b"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressEnd</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a77a45d885f97e1a611b0a5b8dc3bb40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cea029a0bb52342323fb0cec22d35b0"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9cea029a0bb52342323fb0cec22d35b0">ZSTD_compressBegin_advanced</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const void *dict, size_t dictSize, <a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a> params, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:a9cea029a0bb52342323fb0cec22d35b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d9beb7e208a8739efc74e36ef58974"><td class="memItemLeft" align="right" valign="top"><a id="af3d9beb7e208a8739efc74e36ef58974"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBegin_usingCDict_advanced</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *const cctx, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *const cdict, <a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a> const fParams, unsigned long long const pledgedSrcSize)</td></tr>
<tr class="separator:af3d9beb7e208a8739efc74e36ef58974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb290eb615bc723cfc4877d3d116dd7"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0fb290eb615bc723cfc4877d3d116dd7">ZSTD_decodingBufferSize_min</a> (unsigned long long windowSize, unsigned long long frameContentSize)</td></tr>
<tr class="separator:a0fb290eb615bc723cfc4877d3d116dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512467bdb67ad16006523dbc209746a4"><td class="memItemLeft" align="right" valign="top"><a id="a512467bdb67ad16006523dbc209746a4"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressBegin</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx)</td></tr>
<tr class="separator:a512467bdb67ad16006523dbc209746a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817763e938b70ecdfee8b4e6e70aa0f2"><td class="memItemLeft" align="right" valign="top"><a id="a817763e938b70ecdfee8b4e6e70aa0f2"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressBegin_usingDict</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *dict, size_t dictSize)</td></tr>
<tr class="separator:a817763e938b70ecdfee8b4e6e70aa0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2919ca8f7fab978b60984bf3dd45096c"><td class="memItemLeft" align="right" valign="top"><a id="a2919ca8f7fab978b60984bf3dd45096c"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressBegin_usingDDict</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:a2919ca8f7fab978b60984bf3dd45096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9c39f19b63989c8618e34500c6b982"><td class="memItemLeft" align="right" valign="top"><a id="a0e9c39f19b63989c8618e34500c6b982"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_nextSrcSizeToDecompress</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx)</td></tr>
<tr class="separator:a0e9c39f19b63989c8618e34500c6b982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebff1bb57c32239b35f2b5fd4c391159"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:aebff1bb57c32239b35f2b5fd4c391159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e55d5f45416f0a7413086b5cc7b3d6"><td class="memItemLeft" align="right" valign="top"><a id="a14e55d5f45416f0a7413086b5cc7b3d6"></a>
ZSTDLIB_STATIC_API void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_copyDCtx</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *preparedDCtx)</td></tr>
<tr class="separator:a14e55d5f45416f0a7413086b5cc7b3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492ecace4f69ccdd1ae9cee3311dff26"><td class="memItemLeft" align="right" valign="top"><a id="a492ecace4f69ccdd1ae9cee3311dff26"></a>
ZSTDLIB_STATIC_API ZSTD_nextInputType_e&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_nextInputType</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx)</td></tr>
<tr class="separator:a492ecace4f69ccdd1ae9cee3311dff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa5ce80027dc7ed0a3dc65dffa1d5ef"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9aa5ce80027dc7ed0a3dc65dffa1d5ef">ZSTD_isDeterministicBuild</a> (void)</td></tr>
<tr class="separator:a9aa5ce80027dc7ed0a3dc65dffa1d5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1254a7c7cfebe755e7ab7339894fedcb"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1254a7c7cfebe755e7ab7339894fedcb">ZSTD_getBlockSize</a> (const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx)</td></tr>
<tr class="separator:a1254a7c7cfebe755e7ab7339894fedcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c455e7f6f5ca8319fc57a5c3a68975"><td class="memItemLeft" align="right" valign="top"><a id="a23c455e7f6f5ca8319fc57a5c3a68975"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a23c455e7f6f5ca8319fc57a5c3a68975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941f489daf3d394cc0e0240be2a47e11"><td class="memItemLeft" align="right" valign="top"><a id="a941f489daf3d394cc0e0240be2a47e11"></a>
ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressBlock</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a941f489daf3d394cc0e0240be2a47e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad324c6f4cfa62ee290f487baba56a87f"><td class="memItemLeft" align="right" valign="top">ZSTDLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad324c6f4cfa62ee290f487baba56a87f">ZSTD_insertBlock</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *blockStart, size_t blockSize)</td></tr>
<tr class="separator:ad324c6f4cfa62ee290f487baba56a87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d4cfdabc4f2fc80f61bd8dfebbaee8"><td class="memItemLeft" align="right" valign="top"><a id="aa5d4cfdabc4f2fc80f61bd8dfebbaee8"></a>
MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_customMalloc</b> (size_t size, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:aa5d4cfdabc4f2fc80f61bd8dfebbaee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf32fae3c6087a74aff8484d1b569b4e"><td class="memItemLeft" align="right" valign="top"><a id="aaf32fae3c6087a74aff8484d1b569b4e"></a>
MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_customCalloc</b> (size_t size, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:aaf32fae3c6087a74aff8484d1b569b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c0b419031fc1f2730218ce3cc3764f"><td class="memItemLeft" align="right" valign="top"><a id="a61c0b419031fc1f2730218ce3cc3764f"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_customFree</b> (void *ptr, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:a61c0b419031fc1f2730218ce3cc3764f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05016dd101d21fdc429f76c78cdbb236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a05016dd101d21fdc429f76c78cdbb236">POOL_create</a> (size_t numThreads, size_t queueSize)</td></tr>
<tr class="separator:a05016dd101d21fdc429f76c78cdbb236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d8a8e083b6c1735209468a5c9bd641"><td class="memItemLeft" align="right" valign="top"><a id="ad1d8a8e083b6c1735209468a5c9bd641"></a>
<a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>POOL_create_advanced</b> (size_t numThreads, size_t queueSize, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:ad1d8a8e083b6c1735209468a5c9bd641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4303d0084a4b529708500c2eb4ed341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa4303d0084a4b529708500c2eb4ed341">POOL_free</a> (<a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *ctx)</td></tr>
<tr class="separator:aa4303d0084a4b529708500c2eb4ed341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad822a2ce1a25429021571168b81a0fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad822a2ce1a25429021571168b81a0fb8">POOL_joinJobs</a> (<a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *ctx)</td></tr>
<tr class="separator:ad822a2ce1a25429021571168b81a0fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fdba7fe95ecb80063409162667b017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a39fdba7fe95ecb80063409162667b017">POOL_resize</a> (<a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *ctx, size_t numThreads)</td></tr>
<tr class="separator:a39fdba7fe95ecb80063409162667b017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35eac29d884213562eb548b072404bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa35eac29d884213562eb548b072404bd">POOL_sizeof</a> (const <a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *ctx)</td></tr>
<tr class="separator:aa35eac29d884213562eb548b072404bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e76d52639b0b67a406728d425ba32d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9e76d52639b0b67a406728d425ba32d8">POOL_add</a> (<a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *ctx, <a class="el" href="zstd_8c.html#a657f7753ec82fce04c212f38d9c58e61">POOL_function</a> function, void *opaque)</td></tr>
<tr class="separator:a9e76d52639b0b67a406728d425ba32d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcee4187d26bc6387494caf7fb3b59cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#afcee4187d26bc6387494caf7fb3b59cd">POOL_tryAdd</a> (<a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *ctx, <a class="el" href="zstd_8c.html#a657f7753ec82fce04c212f38d9c58e61">POOL_function</a> function, void *opaque)</td></tr>
<tr class="separator:afcee4187d26bc6387494caf7fb3b59cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a6773999ec058a68d305925239c0ae"><td class="memItemLeft" align="right" valign="top"><a id="a78a6773999ec058a68d305925239c0ae"></a>
MEM_STATIC <a class="el" href="structZSTD__cpuid__t.html">ZSTD_cpuid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cpuid</b> (void)</td></tr>
<tr class="separator:a78a6773999ec058a68d305925239c0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015574d10965c31792507a6446bddd0f"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_PUREF XXH32_hash_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#ga015574d10965c31792507a6446bddd0f">XXH32</a> (const void *input, size_t length, XXH32_hash_t seed)</td></tr>
<tr class="memdesc:ga015574d10965c31792507a6446bddd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the 32-bit hash of <code>input</code> using xxHash32.  <a href="group__XXH32__family.html#ga015574d10965c31792507a6446bddd0f">More...</a><br /></td></tr>
<tr class="separator:ga015574d10965c31792507a6446bddd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2c0ec5dbb1b738d3f58aa3fc640243"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_errorcode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#gaab2c0ec5dbb1b738d3f58aa3fc640243">XXH32_freeState</a> (<a class="el" href="structXXH32__state__s.html">XXH32_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:gaab2c0ec5dbb1b738d3f58aa3fc640243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an <a class="el" href="group__XXH32__family.html#ga0c18948935999c41f3f3cb74db83e51e">XXH32_state_t</a>.  <a href="group__XXH32__family.html#gaab2c0ec5dbb1b738d3f58aa3fc640243">More...</a><br /></td></tr>
<tr class="separator:gaab2c0ec5dbb1b738d3f58aa3fc640243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9354b1d57d79b128917ba28c1ca8230e"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#ga9354b1d57d79b128917ba28c1ca8230e">XXH32_copyState</a> (<a class="el" href="structXXH32__state__s.html">XXH32_state_t</a> *dst_state, const <a class="el" href="structXXH32__state__s.html">XXH32_state_t</a> *src_state)</td></tr>
<tr class="memdesc:ga9354b1d57d79b128917ba28c1ca8230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one <a class="el" href="group__XXH32__family.html#ga0c18948935999c41f3f3cb74db83e51e">XXH32_state_t</a> to another.  <a href="group__XXH32__family.html#ga9354b1d57d79b128917ba28c1ca8230e">More...</a><br /></td></tr>
<tr class="separator:ga9354b1d57d79b128917ba28c1ca8230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817d5e6ae49b78747e5af15e5cc88b2b"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_errorcode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#ga817d5e6ae49b78747e5af15e5cc88b2b">XXH32_reset</a> (<a class="el" href="structXXH32__state__s.html">XXH32_state_t</a> *statePtr, XXH32_hash_t seed)</td></tr>
<tr class="memdesc:ga817d5e6ae49b78747e5af15e5cc88b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an <a class="el" href="group__XXH32__family.html#ga0c18948935999c41f3f3cb74db83e51e">XXH32_state_t</a> to begin a new hash.  <a href="group__XXH32__family.html#ga817d5e6ae49b78747e5af15e5cc88b2b">More...</a><br /></td></tr>
<tr class="separator:ga817d5e6ae49b78747e5af15e5cc88b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc2e89656b7b7184279c2d621594afa"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_errorcode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#gaacc2e89656b7b7184279c2d621594afa">XXH32_update</a> (<a class="el" href="structXXH32__state__s.html">XXH32_state_t</a> *statePtr, const void *input, size_t length)</td></tr>
<tr class="memdesc:gaacc2e89656b7b7184279c2d621594afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes a block of <code>input</code> to an <a class="el" href="group__XXH32__family.html#ga0c18948935999c41f3f3cb74db83e51e">XXH32_state_t</a>.  <a href="group__XXH32__family.html#gaacc2e89656b7b7184279c2d621594afa">More...</a><br /></td></tr>
<tr class="separator:gaacc2e89656b7b7184279c2d621594afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d5f5298193818366420a8f25e3ee46e"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_PUREF XXH32_hash_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#ga2d5f5298193818366420a8f25e3ee46e">XXH32_digest</a> (const <a class="el" href="structXXH32__state__s.html">XXH32_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:ga2d5f5298193818366420a8f25e3ee46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the calculated hash value from an <a class="el" href="group__XXH32__family.html#ga0c18948935999c41f3f3cb74db83e51e">XXH32_state_t</a>.  <a href="group__XXH32__family.html#ga2d5f5298193818366420a8f25e3ee46e">More...</a><br /></td></tr>
<tr class="separator:ga2d5f5298193818366420a8f25e3ee46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade47204bc3908fdc401a68e9c295e233"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#gade47204bc3908fdc401a68e9c295e233">XXH32_canonicalFromHash</a> (<a class="el" href="structXXH32__canonical__t.html">XXH32_canonical_t</a> *dst, XXH32_hash_t hash)</td></tr>
<tr class="memdesc:gade47204bc3908fdc401a68e9c295e233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an XXH32_hash_t to a big endian <a class="el" href="structXXH32__canonical__t.html">XXH32_canonical_t</a>.  <a href="group__XXH32__family.html#gade47204bc3908fdc401a68e9c295e233">More...</a><br /></td></tr>
<tr class="separator:gade47204bc3908fdc401a68e9c295e233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206cac74a0c149b244d3532186a4930f"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_PUREF XXH32_hash_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH32__family.html#ga206cac74a0c149b244d3532186a4930f">XXH32_hashFromCanonical</a> (const <a class="el" href="structXXH32__canonical__t.html">XXH32_canonical_t</a> *src)</td></tr>
<tr class="memdesc:ga206cac74a0c149b244d3532186a4930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="structXXH32__canonical__t.html">XXH32_canonical_t</a> to a native XXH32_hash_t.  <a href="group__XXH32__family.html#ga206cac74a0c149b244d3532186a4930f">More...</a><br /></td></tr>
<tr class="separator:ga206cac74a0c149b244d3532186a4930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9837cb71877781b9d5c9f942fcf923"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_PUREF XXH64_hash_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#ga1e9837cb71877781b9d5c9f942fcf923">XXH64</a> (XXH_NOESCAPE const void *input, size_t length, XXH64_hash_t seed)</td></tr>
<tr class="memdesc:ga1e9837cb71877781b9d5c9f942fcf923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the 64-bit hash of <code>input</code> using xxHash64.  <a href="group__XXH64__family.html#ga1e9837cb71877781b9d5c9f942fcf923">More...</a><br /></td></tr>
<tr class="separator:ga1e9837cb71877781b9d5c9f942fcf923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae490ef51db9c960da09189c2774cf82e"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_errorcode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#gae490ef51db9c960da09189c2774cf82e">XXH64_freeState</a> (<a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:gae490ef51db9c960da09189c2774cf82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a>.  <a href="group__XXH64__family.html#gae490ef51db9c960da09189c2774cf82e">More...</a><br /></td></tr>
<tr class="separator:gae490ef51db9c960da09189c2774cf82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b5dd41dddb52667cef0525cf43f43a"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#ga83b5dd41dddb52667cef0525cf43f43a">XXH64_copyState</a> (XXH_NOESCAPE <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> *dst_state, const <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> *src_state)</td></tr>
<tr class="memdesc:ga83b5dd41dddb52667cef0525cf43f43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> to another.  <a href="group__XXH64__family.html#ga83b5dd41dddb52667cef0525cf43f43a">More...</a><br /></td></tr>
<tr class="separator:ga83b5dd41dddb52667cef0525cf43f43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9aebe63b2d4687808385c70460de1a"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_errorcode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#ga3d9aebe63b2d4687808385c70460de1a">XXH64_reset</a> (XXH_NOESCAPE <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> *statePtr, XXH64_hash_t seed)</td></tr>
<tr class="memdesc:ga3d9aebe63b2d4687808385c70460de1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> to begin a new hash.  <a href="group__XXH64__family.html#ga3d9aebe63b2d4687808385c70460de1a">More...</a><br /></td></tr>
<tr class="separator:ga3d9aebe63b2d4687808385c70460de1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf987b6f8910fea00aa458b6a513e01"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_errorcode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#ga8cf987b6f8910fea00aa458b6a513e01">XXH64_update</a> (XXH_NOESCAPE <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> *statePtr, XXH_NOESCAPE const void *input, size_t length)</td></tr>
<tr class="memdesc:ga8cf987b6f8910fea00aa458b6a513e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes a block of <code>input</code> to an <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a>.  <a href="group__XXH64__family.html#ga8cf987b6f8910fea00aa458b6a513e01">More...</a><br /></td></tr>
<tr class="separator:ga8cf987b6f8910fea00aa458b6a513e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33184b2b593fced263842be35a4ea90"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_PUREF XXH64_hash_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#gae33184b2b593fced263842be35a4ea90">XXH64_digest</a> (XXH_NOESCAPE const <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a> *statePtr)</td></tr>
<tr class="memdesc:gae33184b2b593fced263842be35a4ea90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the calculated hash value from an <a class="el" href="group__XXH64__family.html#ga0702bdbc80b0cf9e94f2379f7d839b8c">XXH64_state_t</a>.  <a href="group__XXH64__family.html#gae33184b2b593fced263842be35a4ea90">More...</a><br /></td></tr>
<tr class="separator:gae33184b2b593fced263842be35a4ea90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad28aa4810c34a5e439077feb4fd32b"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#ga5ad28aa4810c34a5e439077feb4fd32b">XXH64_canonicalFromHash</a> (XXH_NOESCAPE <a class="el" href="structXXH64__canonical__t.html">XXH64_canonical_t</a> *dst, XXH64_hash_t hash)</td></tr>
<tr class="memdesc:ga5ad28aa4810c34a5e439077feb4fd32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an XXH64_hash_t to a big endian <a class="el" href="structXXH64__canonical__t.html">XXH64_canonical_t</a>.  <a href="group__XXH64__family.html#ga5ad28aa4810c34a5e439077feb4fd32b">More...</a><br /></td></tr>
<tr class="separator:ga5ad28aa4810c34a5e439077feb4fd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22cd9a932467a6ea2396a8496f57ddf9"><td class="memItemLeft" align="right" valign="top">XXH_PUBLIC_API XXH_PUREF XXH64_hash_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__XXH64__family.html#ga22cd9a932467a6ea2396a8496f57ddf9">XXH64_hashFromCanonical</a> (XXH_NOESCAPE const <a class="el" href="structXXH64__canonical__t.html">XXH64_canonical_t</a> *src)</td></tr>
<tr class="memdesc:ga22cd9a932467a6ea2396a8496f57ddf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="structXXH64__canonical__t.html">XXH64_canonical_t</a> to a native XXH64_hash_t.  <a href="group__XXH64__family.html#ga22cd9a932467a6ea2396a8496f57ddf9">More...</a><br /></td></tr>
<tr class="separator:ga22cd9a932467a6ea2396a8496f57ddf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147dcfc03a43fa8cb851d9390c690aa7"><td class="memItemLeft" align="right" valign="top">
XXH_FORCE_INLINE xxh_u32&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_readLE32</b> (const void *ptr)</td></tr>
<tr class="separator:ga147dcfc03a43fa8cb851d9390c690aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2279f0253f2fa64e95f3ed43f5b81e77"><td class="memItemLeft" align="right" valign="top">
XXH_FORCE_INLINE xxh_u32&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_readLE32_align</b> (const void *ptr, <a class="el" href="group__impl.html#gadec56fccd4f83e34902b6b09ecccfff5">XXH_alignment</a> align)</td></tr>
<tr class="separator:ga2279f0253f2fa64e95f3ed43f5b81e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaafc43e66631d1642be8c0034dd9a60f"><td class="memItemLeft" align="right" valign="top">
XXH_FORCE_INLINE XXH_PUREF xxh_u32&#160;</td><td class="memItemRight" valign="bottom"><b>XXH32_endian_align</b> (const xxh_u8 *input, size_t len, xxh_u32 seed, <a class="el" href="group__impl.html#gadec56fccd4f83e34902b6b09ecccfff5">XXH_alignment</a> align)</td></tr>
<tr class="separator:gaaafc43e66631d1642be8c0034dd9a60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6c28d4b5f850fc6e364ad5e1565de2d"><td class="memItemLeft" align="right" valign="top">
XXH_FORCE_INLINE XXH_PUREF xxh_u64&#160;</td><td class="memItemRight" valign="bottom"><b>XXH64_endian_align</b> (const xxh_u8 *input, size_t len, xxh_u64 seed, <a class="el" href="group__impl.html#gadec56fccd4f83e34902b6b09ecccfff5">XXH_alignment</a> align)</td></tr>
<tr class="separator:gab6c28d4b5f850fc6e364ad5e1565de2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30bb0eb81bd37e9868e6603ef3c5893"><td class="memItemLeft" align="right" valign="top">MEM_STATIC FORCE_INLINE_ATTR void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac30bb0eb81bd37e9868e6603ef3c5893">ZSTD_wildcopy</a> (void *dst, const void *src, size_t length, ZSTD_overlap_e const ovtype)</td></tr>
<tr class="separator:ac30bb0eb81bd37e9868e6603ef3c5893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e8102738929be11b7c09f6d4dbe81e"><td class="memItemLeft" align="right" valign="top"><a id="a73e8102738929be11b7c09f6d4dbe81e"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_limitCopy</b> (void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a73e8102738929be11b7c09f6d4dbe81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2ddac2f9396e37f68acd80d4c5cedb"><td class="memItemLeft" align="right" valign="top"><a id="add2ddac2f9396e37f68acd80d4c5cedb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_invalidateRepCodes</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx)</td></tr>
<tr class="separator:add2ddac2f9396e37f68acd80d4c5cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d9ed5da5bfdf578587adfbff628914"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae6d9ed5da5bfdf578587adfbff628914">ZSTD_getcBlockSize</a> (const void *src, size_t srcSize, <a class="el" href="structblockProperties__t.html">blockProperties_t</a> *bpPtr)</td></tr>
<tr class="separator:ae6d9ed5da5bfdf578587adfbff628914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9823b75f8714fe6107131aaf9367e6ef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9823b75f8714fe6107131aaf9367e6ef">ZSTD_decodeSeqHeaders</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, int *nbSeqPtr, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a9823b75f8714fe6107131aaf9367e6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec7e4f9d0a247be967793eedbe00673"><td class="memItemLeft" align="right" valign="top">MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4ec7e4f9d0a247be967793eedbe00673">ZSTD_cpuSupportsBmi2</a> (void)</td></tr>
<tr class="separator:a4ec7e4f9d0a247be967793eedbe00673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dbaaf72547121048940fd59d0e1727"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a46dbaaf72547121048940fd59d0e1727">HIST_count</a> (unsigned *count, unsigned *maxSymbolValuePtr, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a46dbaaf72547121048940fd59d0e1727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c2e5928da9e31f5d79543a595ee0fd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a96c2e5928da9e31f5d79543a595ee0fd">HIST_isError</a> (size_t code)</td></tr>
<tr class="separator:a96c2e5928da9e31f5d79543a595ee0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ab7952432d609b1da77ac0a3506425"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a46ab7952432d609b1da77ac0a3506425">HIST_count_wksp</a> (unsigned *count, unsigned *maxSymbolValuePtr, const void *src, size_t srcSize, void *workSpace, size_t workSpaceSize)</td></tr>
<tr class="separator:a46ab7952432d609b1da77ac0a3506425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786e489f8396de1fbadacb8a322e1740"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a786e489f8396de1fbadacb8a322e1740">HIST_countFast</a> (unsigned *count, unsigned *maxSymbolValuePtr, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a786e489f8396de1fbadacb8a322e1740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a8bb4116cae3ba238217110a833f03"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab1a8bb4116cae3ba238217110a833f03">HIST_countFast_wksp</a> (unsigned *count, unsigned *maxSymbolValuePtr, const void *src, size_t srcSize, void *workSpace, size_t workSpaceSize)</td></tr>
<tr class="separator:ab1a8bb4116cae3ba238217110a833f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90d2ab8d87fa086bed70e192ed7602b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad90d2ab8d87fa086bed70e192ed7602b">HIST_count_simple</a> (unsigned *count, unsigned *maxSymbolValuePtr, const void *src, size_t srcSize)</td></tr>
<tr class="separator:ad90d2ab8d87fa086bed70e192ed7602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38f3702c85ebaee0ffa8ee7ac1ffc4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af38f3702c85ebaee0ffa8ee7ac1ffc4b">HIST_add</a> (unsigned *count, const void *src, size_t srcSize)</td></tr>
<tr class="separator:af38f3702c85ebaee0ffa8ee7ac1ffc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ad7f0988cbb73306157dabebeb28a9"><td class="memItemLeft" align="right" valign="top"><a id="aa9ad7f0988cbb73306157dabebeb28a9"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_isSorted</b> (<a class="el" href="structnodeElt__s.html">nodeElt</a> huffNode[], U32 const maxSymbolValue1)</td></tr>
<tr class="separator:aa9ad7f0988cbb73306157dabebeb28a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74599bdae5baf87a79f68625a6d12c20"><td class="memItemLeft" align="right" valign="top"><a id="a74599bdae5baf87a79f68625a6d12c20"></a>
<a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_insertionSort</b> (<a class="el" href="structnodeElt__s.html">nodeElt</a> huffNode[], int const low, int const high)</td></tr>
<tr class="separator:a74599bdae5baf87a79f68625a6d12c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3ef7f6d6f019c23b27a79c73118850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abd3ef7f6d6f019c23b27a79c73118850">HUF_addBits</a> (<a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *bitC, HUF_CElt elt, int idx, int kFast)</td></tr>
<tr class="separator:abd3ef7f6d6f019c23b27a79c73118850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9703d0c9d5133fd00077651f1d493640"><td class="memItemLeft" align="right" valign="top"><a id="a9703d0c9d5133fd00077651f1d493640"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_zeroIndex1</b> (<a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *bitC)</td></tr>
<tr class="separator:a9703d0c9d5133fd00077651f1d493640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db3be6d7198e3ef6601d8e14102f5e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7db3be6d7198e3ef6601d8e14102f5e8">HUF_mergeIndex1</a> (<a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *bitC)</td></tr>
<tr class="separator:a7db3be6d7198e3ef6601d8e14102f5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fc656720e8cbcbf0b7a0a938bc26fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac1fc656720e8cbcbf0b7a0a938bc26fb">HUF_flushBits</a> (<a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *bitC, int kFast)</td></tr>
<tr class="separator:ac1fc656720e8cbcbf0b7a0a938bc26fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704ed8d82de2399bdd1242fb19caff88"><td class="memItemLeft" align="right" valign="top"><a id="a704ed8d82de2399bdd1242fb19caff88"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_encodeSymbol</b> (<a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *bitCPtr, U32 symbol, const HUF_CElt *CTable, int idx, int fast)</td></tr>
<tr class="separator:a704ed8d82de2399bdd1242fb19caff88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60af95392de19d2dd3d09b6e5ec31554"><td class="memItemLeft" align="right" valign="top"><a id="a60af95392de19d2dd3d09b6e5ec31554"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_compress1X_usingCTable_internal_body_loop</b> (<a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *bitC, const BYTE *ip, size_t srcSize, const HUF_CElt *ct, int kUnroll, int kFastFlush, int kLastFast)</td></tr>
<tr class="separator:a60af95392de19d2dd3d09b6e5ec31554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c20f58c71b92ed2b0fe074b570641b"><td class="memItemLeft" align="right" valign="top"><a id="ae3c20f58c71b92ed2b0fe074b570641b"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_compress1X_usingCTable_internal_body</b> (void *dst, size_t dstSize, const void *src, size_t srcSize, const HUF_CElt *CTable)</td></tr>
<tr class="separator:ae3c20f58c71b92ed2b0fe074b570641b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f28b678632973bb80f9738d7b3faee"><td class="memItemLeft" align="right" valign="top"><a id="af9f28b678632973bb80f9738d7b3faee"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_available_space</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:af9f28b678632973bb80f9738d7b3faee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc69eacbcc3d83f39715edfb69653a7c"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#acc69eacbcc3d83f39715edfb69653a7c">ZSTD_cwksp_initialAllocStart</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:acc69eacbcc3d83f39715edfb69653a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf3b7c9a7fe923f3c9ba6575c917320"><td class="memItemLeft" align="right" valign="top"><a id="a4cf3b7c9a7fe923f3c9ba6575c917320"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_assert_internal_consistency</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a4cf3b7c9a7fe923f3c9ba6575c917320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c7428a6eec1a205b646f4133fe097f"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af5c7428a6eec1a205b646f4133fe097f">ZSTD_cwksp_align</a> (size_t size, size_t align)</td></tr>
<tr class="separator:af5c7428a6eec1a205b646f4133fe097f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab886033561bea9f8fa032aaae25b284e"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab886033561bea9f8fa032aaae25b284e">ZSTD_cwksp_alloc_size</a> (size_t size)</td></tr>
<tr class="separator:ab886033561bea9f8fa032aaae25b284e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c86dafa5e39f9004b2243dbc6850afa"><td class="memItemLeft" align="right" valign="top"><a id="a1c86dafa5e39f9004b2243dbc6850afa"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_aligned_alloc_size</b> (size_t size, size_t alignment)</td></tr>
<tr class="separator:a1c86dafa5e39f9004b2243dbc6850afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a28334c5a4c55877e288328c54fa37"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa0a28334c5a4c55877e288328c54fa37">ZSTD_cwksp_aligned64_alloc_size</a> (size_t size)</td></tr>
<tr class="separator:aa0a28334c5a4c55877e288328c54fa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712ad2c6986cfb21f049a8227e87b8cb"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a712ad2c6986cfb21f049a8227e87b8cb">ZSTD_cwksp_slack_space_required</a> (void)</td></tr>
<tr class="separator:a712ad2c6986cfb21f049a8227e87b8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44833bd0cfaac545a4eccd464dbed6ee"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a44833bd0cfaac545a4eccd464dbed6ee">ZSTD_cwksp_bytes_to_align_ptr</a> (void *ptr, const size_t alignBytes)</td></tr>
<tr class="separator:a44833bd0cfaac545a4eccd464dbed6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd4d6f76057094c6ce936e815dd609c"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aacd4d6f76057094c6ce936e815dd609c">ZSTD_cwksp_reserve_internal_buffer_space</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t const bytes)</td></tr>
<tr class="separator:aacd4d6f76057094c6ce936e815dd609c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8b87655edbfd16eef8f1ab70d2b2b"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a29f8b87655edbfd16eef8f1ab70d2b2b">ZSTD_cwksp_internal_advance_phase</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, ZSTD_cwksp_alloc_phase_e phase)</td></tr>
<tr class="separator:a29f8b87655edbfd16eef8f1ab70d2b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a1b7fd981681509a8d79affbbb7294"><td class="memItemLeft" align="right" valign="top">MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a54a1b7fd981681509a8d79affbbb7294">ZSTD_cwksp_owns_buffer</a> (const <a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, const void *ptr)</td></tr>
<tr class="separator:a54a1b7fd981681509a8d79affbbb7294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f9aca41390497f2dec429797d17395"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ac3f9aca41390497f2dec429797d17395">ZSTD_cwksp_reserve_internal</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t bytes, ZSTD_cwksp_alloc_phase_e phase)</td></tr>
<tr class="separator:ac3f9aca41390497f2dec429797d17395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e326d108fc103d7e1fee18839e782ef"><td class="memItemLeft" align="right" valign="top">MEM_STATIC BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9e326d108fc103d7e1fee18839e782ef">ZSTD_cwksp_reserve_buffer</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t bytes)</td></tr>
<tr class="separator:a9e326d108fc103d7e1fee18839e782ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3845a2db282659f4f05d5346fc54856e"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3845a2db282659f4f05d5346fc54856e">ZSTD_cwksp_reserve_aligned_init_once</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t bytes)</td></tr>
<tr class="separator:a3845a2db282659f4f05d5346fc54856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94ed00041b94ff70bde142fe3017543"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad94ed00041b94ff70bde142fe3017543">ZSTD_cwksp_reserve_aligned64</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t bytes)</td></tr>
<tr class="separator:ad94ed00041b94ff70bde142fe3017543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba21778f86bacfea78d3f50b910ce0"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a01ba21778f86bacfea78d3f50b910ce0">ZSTD_cwksp_reserve_table</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t bytes)</td></tr>
<tr class="separator:a01ba21778f86bacfea78d3f50b910ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b8fbd1feebad4abde04d20531a9a97"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a71b8fbd1feebad4abde04d20531a9a97">ZSTD_cwksp_reserve_object</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t bytes)</td></tr>
<tr class="separator:a71b8fbd1feebad4abde04d20531a9a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ef4ae1942bd067061b33f27d015574"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ae6ef4ae1942bd067061b33f27d015574">ZSTD_cwksp_reserve_object_aligned</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t byteSize, size_t alignment)</td></tr>
<tr class="separator:ae6ef4ae1942bd067061b33f27d015574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7701edeea53bd3e326c65c90a9274f62"><td class="memItemLeft" align="right" valign="top"><a id="a7701edeea53bd3e326c65c90a9274f62"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_mark_tables_dirty</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a7701edeea53bd3e326c65c90a9274f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb8336e3c1e1f1bd6e689181d1da15e"><td class="memItemLeft" align="right" valign="top"><a id="a0fb8336e3c1e1f1bd6e689181d1da15e"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_mark_tables_clean</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a0fb8336e3c1e1f1bd6e689181d1da15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe429aca2f2a9063b08a2372dd82e58"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3fe429aca2f2a9063b08a2372dd82e58">ZSTD_cwksp_clean_tables</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a3fe429aca2f2a9063b08a2372dd82e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ddee198a3d51f146cf9cb0e3c259c9"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a48ddee198a3d51f146cf9cb0e3c259c9">ZSTD_cwksp_clear_tables</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a48ddee198a3d51f146cf9cb0e3c259c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4481557c43ba23a4ca8be832b0b765"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8f4481557c43ba23a4ca8be832b0b765">ZSTD_cwksp_clear</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a8f4481557c43ba23a4ca8be832b0b765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bb0f0f87883b48bbba0330db3ab2e0"><td class="memItemLeft" align="right" valign="top"><a id="a65bb0f0f87883b48bbba0330db3ab2e0"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_sizeof</b> (const <a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a65bb0f0f87883b48bbba0330db3ab2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3850657b9354aafcdcdfbc3ce8d53a3b"><td class="memItemLeft" align="right" valign="top"><a id="a3850657b9354aafcdcdfbc3ce8d53a3b"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_used</b> (const <a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a3850657b9354aafcdcdfbc3ce8d53a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaede5bc13074b11c101505128283c810"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aaede5bc13074b11c101505128283c810">ZSTD_cwksp_init</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, void *start, size_t size, <a class="el" href="zstd_8c.html#a1df52ae5f2538c70f0db6f9c9377f6c7">ZSTD_cwksp_static_alloc_e</a> isStatic)</td></tr>
<tr class="separator:aaede5bc13074b11c101505128283c810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02af981589dbdc42e18ae680f1a18daa"><td class="memItemLeft" align="right" valign="top"><a id="a02af981589dbdc42e18ae680f1a18daa"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_create</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t size, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:a02af981589dbdc42e18ae680f1a18daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cb1dc328ba75e8bb63a14636bd603f"><td class="memItemLeft" align="right" valign="top"><a id="a86cb1dc328ba75e8bb63a14636bd603f"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_free</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> customMem)</td></tr>
<tr class="separator:a86cb1dc328ba75e8bb63a14636bd603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2134dd2d9a727e3215a0c80b5b9df0b7"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2134dd2d9a727e3215a0c80b5b9df0b7">ZSTD_cwksp_move</a> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *dst, <a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *src)</td></tr>
<tr class="separator:a2134dd2d9a727e3215a0c80b5b9df0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1482c65b46014c2e46eaa911c6189039"><td class="memItemLeft" align="right" valign="top"><a id="a1482c65b46014c2e46eaa911c6189039"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_reserve_failed</b> (const <a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws)</td></tr>
<tr class="separator:a1482c65b46014c2e46eaa911c6189039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbc5375e4a613ca84e3655019bbe8ee"><td class="memItemLeft" align="right" valign="top"><a id="a8dbc5375e4a613ca84e3655019bbe8ee"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_estimated_space_within_bounds</b> (const <a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *const ws, size_t const estimatedSpace)</td></tr>
<tr class="separator:a8dbc5375e4a613ca84e3655019bbe8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb576ce45cc40051f7fea734068eceba"><td class="memItemLeft" align="right" valign="top"><a id="abb576ce45cc40051f7fea734068eceba"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_check_available</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t additionalNeededSpace)</td></tr>
<tr class="separator:abb576ce45cc40051f7fea734068eceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426d15e33b19566ea9032f97ab876ed4"><td class="memItemLeft" align="right" valign="top"><a id="a426d15e33b19566ea9032f97ab876ed4"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_check_too_large</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t additionalNeededSpace)</td></tr>
<tr class="separator:a426d15e33b19566ea9032f97ab876ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbdfd92eff20915b8993f77f2063371"><td class="memItemLeft" align="right" valign="top"><a id="a5bbdfd92eff20915b8993f77f2063371"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_check_wasteful</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t additionalNeededSpace)</td></tr>
<tr class="separator:a5bbdfd92eff20915b8993f77f2063371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70258e4389e8f9a325810ba1d82b8e57"><td class="memItemLeft" align="right" valign="top"><a id="a70258e4389e8f9a325810ba1d82b8e57"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cwksp_bump_oversized_duration</b> (<a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *ws, size_t additionalNeededSpace)</td></tr>
<tr class="separator:a70258e4389e8f9a325810ba1d82b8e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28e544964088f3d27cfe81ccb4c9395"><td class="memItemLeft" align="right" valign="top"><a id="ac28e544964088f3d27cfe81ccb4c9395"></a>
<a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_createCCtx_advanced</b> (unsigned nbWorkers, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> cMem, <a class="el" href="zstd_8c.html#aa979b4b649aec2c11af1876dcae1590a">ZSTD_threadPool</a> *pool)</td></tr>
<tr class="separator:ac28e544964088f3d27cfe81ccb4c9395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c47c421163caa33164a894e87dccb1c"><td class="memItemLeft" align="right" valign="top"><a id="a7c47c421163caa33164a894e87dccb1c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_freeCCtx</b> (<a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *mtctx)</td></tr>
<tr class="separator:a7c47c421163caa33164a894e87dccb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827cc3b54e66b16eeff38550cf534066"><td class="memItemLeft" align="right" valign="top"><a id="a827cc3b54e66b16eeff38550cf534066"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_sizeof_CCtx</b> (<a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *mtctx)</td></tr>
<tr class="separator:a827cc3b54e66b16eeff38550cf534066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7309a31a630ed75ed66c37d175477080"><td class="memItemLeft" align="right" valign="top"><a id="a7309a31a630ed75ed66c37d175477080"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_nextInputSizeHint</b> (const <a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *mtctx)</td></tr>
<tr class="separator:a7309a31a630ed75ed66c37d175477080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12f1edba314c587743801d624f71873"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aa12f1edba314c587743801d624f71873">ZSTDMT_initCStream_internal</a> (<a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *mtctx, const void *dict, size_t dictSize, ZSTD_dictContentType_e dictContentType, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict, <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> params, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:aa12f1edba314c587743801d624f71873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac5048ac979153a18b921b710e3e8d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1ac5048ac979153a18b921b710e3e8d1">ZSTDMT_compressStream_generic</a> (<a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *mtctx, <a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *output, <a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer</a> *input, ZSTD_EndDirective endOp)</td></tr>
<tr class="separator:a1ac5048ac979153a18b921b710e3e8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d200c4c6b7a3c7a045a181dfa29c322"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0d200c4c6b7a3c7a045a181dfa29c322">ZSTDMT_toFlushNow</a> (<a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *mtctx)</td></tr>
<tr class="separator:a0d200c4c6b7a3c7a045a181dfa29c322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5723a37881527037ffcdfbc157c121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3f5723a37881527037ffcdfbc157c121">ZSTDMT_updateCParams_whileCompressing</a> (<a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *mtctx, const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *cctxParams)</td></tr>
<tr class="separator:a3f5723a37881527037ffcdfbc157c121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c822c10aa6f503cebf7e35746b7c206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structZSTD__frameProgression.html">ZSTD_frameProgression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3c822c10aa6f503cebf7e35746b7c206">ZSTDMT_getFrameProgression</a> (<a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *mtctx)</td></tr>
<tr class="separator:a3c822c10aa6f503cebf7e35746b7c206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdd434ac2b0af9f641732af7f9c5b97"><td class="memItemLeft" align="right" valign="top"><a id="a0bdd434ac2b0af9f641732af7f9c5b97"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_splitBlock</b> (const void *blockStart, size_t blockSize, int level, void *workspace, size_t wkspSize)</td></tr>
<tr class="separator:a0bdd434ac2b0af9f641732af7f9c5b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fe97fad779223a0024b6f8f036b32b"><td class="memItemLeft" align="right" valign="top">MEM_STATIC <a class="el" href="structZSTD__SequenceLength.html">ZSTD_SequenceLength</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab6fe97fad779223a0024b6f8f036b32b">ZSTD_getSequenceLength</a> (<a class="el" href="structSeqStore__t.html">SeqStore_t</a> const *seqStore, <a class="el" href="structSeqDef__s.html">SeqDef</a> const *seq)</td></tr>
<tr class="separator:ab6fe97fad779223a0024b6f8f036b32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b054daa8fa9bae5686459a1f256a1"><td class="memItemLeft" align="right" valign="top"><a id="ac42b054daa8fa9bae5686459a1f256a1"></a>
const <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_getSeqStore</b> (const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *ctx)</td></tr>
<tr class="separator:ac42b054daa8fa9bae5686459a1f256a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea18f4d098a43e969a4c39d72aa0f15"><td class="memItemLeft" align="right" valign="top"><a id="a5ea18f4d098a43e969a4c39d72aa0f15"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_seqToCodes</b> (const <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStorePtr)</td></tr>
<tr class="separator:a5ea18f4d098a43e969a4c39d72aa0f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d0135361a97baeba2bedde58c1acca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a21d0135361a97baeba2bedde58c1acca">ZSTD_buildBlockEntropyStats</a> (const <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStorePtr, const <a class="el" href="structZSTD__entropyCTables__t.html">ZSTD_entropyCTables_t</a> *prevEntropy, <a class="el" href="structZSTD__entropyCTables__t.html">ZSTD_entropyCTables_t</a> *nextEntropy, const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *cctxParams, <a class="el" href="structZSTD__entropyCTablesMetadata__t.html">ZSTD_entropyCTablesMetadata_t</a> *entropyMetadata, void *workspace, size_t wkspSize)</td></tr>
<tr class="separator:a21d0135361a97baeba2bedde58c1acca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6393a065fab24a251e10cf75b113d08"><td class="memItemLeft" align="right" valign="top"><a id="ab6393a065fab24a251e10cf75b113d08"></a>
ZSTD_BlockCompressor_f&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_selectBlockCompressor</b> (ZSTD_strategy strat, ZSTD_ParamSwitch_e rowMatchfinderMode, ZSTD_dictMode_e dictMode)</td></tr>
<tr class="separator:ab6393a065fab24a251e10cf75b113d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b788119531859302ff7a28db7104797"><td class="memItemLeft" align="right" valign="top"><a id="a7b788119531859302ff7a28db7104797"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_LLcode</b> (U32 litLength)</td></tr>
<tr class="separator:a7b788119531859302ff7a28db7104797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07360b76b6838e22efb0621f09e4fff0"><td class="memItemLeft" align="right" valign="top"><a id="a07360b76b6838e22efb0621f09e4fff0"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_MLcode</b> (U32 mlBase)</td></tr>
<tr class="separator:a07360b76b6838e22efb0621f09e4fff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa474c52b707b593ae5e5885701bf772a"><td class="memItemLeft" align="right" valign="top"><a id="aa474c52b707b593ae5e5885701bf772a"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_cParam_withinBounds</b> (ZSTD_cParameter cParam, int value)</td></tr>
<tr class="separator:aa474c52b707b593ae5e5885701bf772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0a91cb43441ae8b8c79b603b474e36"><td class="memItemLeft" align="right" valign="top"><a id="aee0a91cb43441ae8b8c79b603b474e36"></a>
MEM_STATIC const BYTE *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_selectAddr</b> (U32 index, U32 lowLimit, const BYTE *candidate, const BYTE *backup)</td></tr>
<tr class="separator:aee0a91cb43441ae8b8c79b603b474e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d60ca49fa5407fe071973a0d8a302e9"><td class="memItemLeft" align="right" valign="top"><a id="a4d60ca49fa5407fe071973a0d8a302e9"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_noCompressBlock</b> (void *dst, size_t dstCapacity, const void *src, size_t srcSize, U32 lastBlock)</td></tr>
<tr class="separator:a4d60ca49fa5407fe071973a0d8a302e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bb6511eef9a8a412e2f5aece6c0326"><td class="memItemLeft" align="right" valign="top"><a id="aa0bb6511eef9a8a412e2f5aece6c0326"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_rleCompressBlock</b> (void *dst, size_t dstCapacity, BYTE src, size_t srcSize, U32 lastBlock)</td></tr>
<tr class="separator:aa0bb6511eef9a8a412e2f5aece6c0326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073144908de935e8082331888faaad04"><td class="memItemLeft" align="right" valign="top"><a id="a073144908de935e8082331888faaad04"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_minGain</b> (size_t srcSize, ZSTD_strategy strat)</td></tr>
<tr class="separator:a073144908de935e8082331888faaad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c6407b244b27b227bb5f697550fa91"><td class="memItemLeft" align="right" valign="top"><a id="a44c6407b244b27b227bb5f697550fa91"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_literalsCompressionIsDisabled</b> (const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *cctxParams)</td></tr>
<tr class="separator:a44c6407b244b27b227bb5f697550fa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b5bce120d275827e4c1da586aa26ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> UNUSED_ATTR void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a43b5bce120d275827e4c1da586aa26ef">ZSTD_storeSeqOnly</a> (<a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStorePtr, size_t litLength, U32 offBase, size_t matchLength)</td></tr>
<tr class="separator:a43b5bce120d275827e4c1da586aa26ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42cff93ddcb09ef56fe0bc4f3d2f8d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> UNUSED_ATTR void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ab42cff93ddcb09ef56fe0bc4f3d2f8d3">ZSTD_storeSeq</a> (<a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStorePtr, size_t litLength, const BYTE *literals, const BYTE *litLimit, U32 offBase, size_t matchLength)</td></tr>
<tr class="separator:ab42cff93ddcb09ef56fe0bc4f3d2f8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74aa4155d1b81fa61c5e7c22af6fe635"><td class="memItemLeft" align="right" valign="top"><a id="a74aa4155d1b81fa61c5e7c22af6fe635"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_updateRep</b> (U32 rep[ZSTD_REP_NUM], U32 const offBase, U32 const ll0)</td></tr>
<tr class="separator:a74aa4155d1b81fa61c5e7c22af6fe635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fea256cc0920a0d7be95214fe5a50f"><td class="memItemLeft" align="right" valign="top"><a id="a82fea256cc0920a0d7be95214fe5a50f"></a>
MEM_STATIC <a class="el" href="structrepcodes__s.html">Repcodes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_newRep</b> (U32 const rep[ZSTD_REP_NUM], U32 const offBase, U32 const ll0)</td></tr>
<tr class="separator:a82fea256cc0920a0d7be95214fe5a50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d6a0f10739e9ce21fdf1a9706373e4"><td class="memItemLeft" align="right" valign="top"><a id="a92d6a0f10739e9ce21fdf1a9706373e4"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_count</b> (const BYTE *pIn, const BYTE *pMatch, const BYTE *const pInLimit)</td></tr>
<tr class="separator:a92d6a0f10739e9ce21fdf1a9706373e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57701da2b1d85e5caef04c0f7a825609"><td class="memItemLeft" align="right" valign="top">MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a57701da2b1d85e5caef04c0f7a825609">ZSTD_count_2segments</a> (const BYTE *ip, const BYTE *match, const BYTE *iEnd, const BYTE *mEnd, const BYTE *iStart)</td></tr>
<tr class="separator:a57701da2b1d85e5caef04c0f7a825609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab819d6bd1ab37d3c94ac9673b5a2b7de"><td class="memItemLeft" align="right" valign="top"><a id="ab819d6bd1ab37d3c94ac9673b5a2b7de"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_hash3Ptr</b> (const void *ptr, U32 h)</td></tr>
<tr class="separator:ab819d6bd1ab37d3c94ac9673b5a2b7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace94ce0d2c5b89d1da502e4c1a1b1660"><td class="memItemLeft" align="right" valign="top"><a id="ace94ce0d2c5b89d1da502e4c1a1b1660"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_hash3PtrS</b> (const void *ptr, U32 h, U32 s)</td></tr>
<tr class="separator:ace94ce0d2c5b89d1da502e4c1a1b1660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed0bc6c9056ad0d41b0e930b21c4841"><td class="memItemLeft" align="right" valign="top"><a id="a8ed0bc6c9056ad0d41b0e930b21c4841"></a>
MEM_STATIC FORCE_INLINE_ATTR size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_hashPtr</b> (const void *p, U32 hBits, U32 mls)</td></tr>
<tr class="separator:a8ed0bc6c9056ad0d41b0e930b21c4841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fac913946f2902d1bbe7fca52c16b9"><td class="memItemLeft" align="right" valign="top"><a id="ab8fac913946f2902d1bbe7fca52c16b9"></a>
MEM_STATIC FORCE_INLINE_ATTR size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_hashPtrSalted</b> (const void *p, U32 hBits, U32 mls, const U64 hashSalt)</td></tr>
<tr class="separator:ab8fac913946f2902d1bbe7fca52c16b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bc513996e13d72e5b0cc6d11c21970"><td class="memItemLeft" align="right" valign="top">MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a34bc513996e13d72e5b0cc6d11c21970">ZSTD_rollingHash_compute</a> (void const *buf, size_t size)</td></tr>
<tr class="separator:a34bc513996e13d72e5b0cc6d11c21970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602fbbe915e54e330f1cc6252080d7a7"><td class="memItemLeft" align="right" valign="top">MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a602fbbe915e54e330f1cc6252080d7a7">ZSTD_rollingHash_primePower</a> (U32 length)</td></tr>
<tr class="separator:a602fbbe915e54e330f1cc6252080d7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3724dab957ebcd9f208ee18737d99bec"><td class="memItemLeft" align="right" valign="top">MEM_STATIC U64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3724dab957ebcd9f208ee18737d99bec">ZSTD_rollingHash_rotate</a> (U64 hash, BYTE toRemove, BYTE toAdd, U64 primePower)</td></tr>
<tr class="separator:a3724dab957ebcd9f208ee18737d99bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1754250a088c051bfdaa3722b196f6"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2b1754250a088c051bfdaa3722b196f6">ZSTD_window_clear</a> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *window)</td></tr>
<tr class="separator:a2b1754250a088c051bfdaa3722b196f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e1877b9279ba10de47d1efaeb6fe96"><td class="memItemLeft" align="right" valign="top"><a id="a63e1877b9279ba10de47d1efaeb6fe96"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_window_isEmpty</b> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> const window)</td></tr>
<tr class="separator:a63e1877b9279ba10de47d1efaeb6fe96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aeb6153e79460e67e19938c5376e0d"><td class="memItemLeft" align="right" valign="top">MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a76aeb6153e79460e67e19938c5376e0d">ZSTD_window_hasExtDict</a> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> const window)</td></tr>
<tr class="separator:a76aeb6153e79460e67e19938c5376e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271b90fe6607653a89b99c4926cc9d5f"><td class="memItemLeft" align="right" valign="top">MEM_STATIC ZSTD_dictMode_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a271b90fe6607653a89b99c4926cc9d5f">ZSTD_matchState_dictMode</a> (const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms)</td></tr>
<tr class="separator:a271b90fe6607653a89b99c4926cc9d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc8b3af4bbb26a05f4fcf52145c20e9"><td class="memItemLeft" align="right" valign="top">MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9fc8b3af4bbb26a05f4fcf52145c20e9">ZSTD_window_canOverflowCorrect</a> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> const window, U32 cycleLog, U32 maxDist, U32 loadedDictEnd, void const *src)</td></tr>
<tr class="separator:a9fc8b3af4bbb26a05f4fcf52145c20e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af7a893a783cfcdd6e3738674344f48"><td class="memItemLeft" align="right" valign="top">MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1af7a893a783cfcdd6e3738674344f48">ZSTD_window_needOverflowCorrection</a> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> const window, U32 cycleLog, U32 maxDist, U32 loadedDictEnd, void const *src, void const *srcEnd)</td></tr>
<tr class="separator:a1af7a893a783cfcdd6e3738674344f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909342229fb07f0ff63025cdff6a69f4"><td class="memItemLeft" align="right" valign="top">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a909342229fb07f0ff63025cdff6a69f4">ZSTD_window_correctOverflow</a> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *window, U32 cycleLog, U32 maxDist, void const *src)</td></tr>
<tr class="separator:a909342229fb07f0ff63025cdff6a69f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf5737b37d58228f331a8e47ad0142a"><td class="memItemLeft" align="right" valign="top">MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a3cf5737b37d58228f331a8e47ad0142a">ZSTD_window_enforceMaxDist</a> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *window, const void *blockEnd, U32 maxDist, U32 *loadedDictEndPtr, const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> **dictMatchStatePtr)</td></tr>
<tr class="separator:a3cf5737b37d58228f331a8e47ad0142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e2ce285c7bc6ba42496fd84da2e9aa"><td class="memItemLeft" align="right" valign="top"><a id="a02e2ce285c7bc6ba42496fd84da2e9aa"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_checkDictValidity</b> (const <a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *window, const void *blockEnd, U32 maxDist, U32 *loadedDictEndPtr, const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> **dictMatchStatePtr)</td></tr>
<tr class="separator:a02e2ce285c7bc6ba42496fd84da2e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b252ed0616abd4d1be9db6f559436a2"><td class="memItemLeft" align="right" valign="top"><a id="a8b252ed0616abd4d1be9db6f559436a2"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_window_init</b> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *window)</td></tr>
<tr class="separator:a8b252ed0616abd4d1be9db6f559436a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a04814aabcae6a2990b9c342be3f7e"><td class="memItemLeft" align="right" valign="top">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a31a04814aabcae6a2990b9c342be3f7e">ZSTD_window_update</a> (<a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *window, const void *src, size_t srcSize, int forceNonContiguous)</td></tr>
<tr class="separator:a31a04814aabcae6a2990b9c342be3f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490a09a11a85f1d07f0fd24616025627"><td class="memItemLeft" align="right" valign="top">MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a490a09a11a85f1d07f0fd24616025627">ZSTD_getLowestMatchIndex</a> (const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, U32 curr, unsigned windowLog)</td></tr>
<tr class="separator:a490a09a11a85f1d07f0fd24616025627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fac416e05311464f030f33ee6264253"><td class="memItemLeft" align="right" valign="top">MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0fac416e05311464f030f33ee6264253">ZSTD_getLowestPrefixIndex</a> (const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, U32 curr, unsigned windowLog)</td></tr>
<tr class="separator:a0fac416e05311464f030f33ee6264253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f42198abeca3ca577510ef266b272ef"><td class="memItemLeft" align="right" valign="top"><a id="a1f42198abeca3ca577510ef266b272ef"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_index_overlap_check</b> (const U32 prefixLowestIndex, const U32 repIndex)</td></tr>
<tr class="separator:a1f42198abeca3ca577510ef266b272ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638bc8eedb6f158ffb49ebb1bce2097f"><td class="memItemLeft" align="right" valign="top"><a id="a638bc8eedb6f158ffb49ebb1bce2097f"></a>
MEM_STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_writeTaggedIndex</b> (U32 *const hashTable, size_t hashAndTag, U32 index)</td></tr>
<tr class="separator:a638bc8eedb6f158ffb49ebb1bce2097f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daf4f47413799313089f92863403e74"><td class="memItemLeft" align="right" valign="top"><a id="a6daf4f47413799313089f92863403e74"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_comparePackedTags</b> (size_t packedTag1, size_t packedTag2)</td></tr>
<tr class="separator:a6daf4f47413799313089f92863403e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7a517af19084eecc50bb03bf5d715e"><td class="memItemLeft" align="right" valign="top"><a id="a6a7a517af19084eecc50bb03bf5d715e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_loadCEntropy</b> (<a class="el" href="structZSTD__compressedBlockState__t.html">ZSTD_compressedBlockState_t</a> *bs, void *workspace, const void *const dict, size_t dictSize)</td></tr>
<tr class="separator:a6a7a517af19084eecc50bb03bf5d715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11535f7fadf39074ab5c2db81722eb4"><td class="memItemLeft" align="right" valign="top"><a id="ad11535f7fadf39074ab5c2db81722eb4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_reset_compressedBlockState</b> (<a class="el" href="structZSTD__compressedBlockState__t.html">ZSTD_compressedBlockState_t</a> *bs)</td></tr>
<tr class="separator:ad11535f7fadf39074ab5c2db81722eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8783051a32ab3750afdee449b1f8f4"><td class="memItemLeft" align="right" valign="top"><a id="ada8783051a32ab3750afdee449b1f8f4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_convertBlockSequences</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *const inSeqs, size_t nbSequences, int repcodeResolution)</td></tr>
<tr class="separator:ada8783051a32ab3750afdee449b1f8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c63ce584653c6004da06453f8a68174"><td class="memItemLeft" align="right" valign="top"><a id="a4c63ce584653c6004da06453f8a68174"></a>
<a class="el" href="structBlockSummary.html">BlockSummary</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_get1BlockSummary</b> (const <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *seqs, size_t nbSeqs)</td></tr>
<tr class="separator:a4c63ce584653c6004da06453f8a68174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22ea4847e0af36a529ae90498797303"><td class="memItemLeft" align="right" valign="top"><a id="aa22ea4847e0af36a529ae90498797303"></a>
<a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_getCParamsFromCCtxParams</b> (const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *CCtxParams, U64 srcSizeHint, size_t dictSize, ZSTD_CParamMode_e mode)</td></tr>
<tr class="separator:aa22ea4847e0af36a529ae90498797303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997205b667d236d5164f6481e657f7e0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a997205b667d236d5164f6481e657f7e0">ZSTD_initCStream_internal</a> (<a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *zcs, const void *dict, size_t dictSize, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict, const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:a997205b667d236d5164f6481e657f7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209a8e6db1c7c4581ce63fff8a1e30d7"><td class="memItemLeft" align="right" valign="top"><a id="a209a8e6db1c7c4581ce63fff8a1e30d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_resetSeqStore</b> (<a class="el" href="structSeqStore__t.html">SeqStore_t</a> *ssPtr)</td></tr>
<tr class="separator:a209a8e6db1c7c4581ce63fff8a1e30d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7224903a99baeada3c87a06b38a4b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af7224903a99baeada3c87a06b38a4b97">ZSTD_getCParamsFromCDict</a> (const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict)</td></tr>
<tr class="separator:af7224903a99baeada3c87a06b38a4b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93df0c814f549b18102123fea086a55c"><td class="memItemLeft" align="right" valign="top"><a id="a93df0c814f549b18102123fea086a55c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBegin_advanced_internal</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const void *dict, size_t dictSize, ZSTD_dictContentType_e dictContentType, ZSTD_dictTableLoadMethod_e dtlm, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict, const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params, unsigned long long pledgedSrcSize)</td></tr>
<tr class="separator:a93df0c814f549b18102123fea086a55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031aea6afc015d3df80679b41f6c7e57"><td class="memItemLeft" align="right" valign="top"><a id="a031aea6afc015d3df80679b41f6c7e57"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compress_advanced_internal</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, const void *dict, size_t dictSize, const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params)</td></tr>
<tr class="separator:a031aea6afc015d3df80679b41f6c7e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c37cf8d4ad072477906dd1986d7bef"><td class="memItemLeft" align="right" valign="top"><a id="ac7c37cf8d4ad072477906dd1986d7bef"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_writeLastEmptyBlock</b> (void *dst, size_t dstCapacity)</td></tr>
<tr class="separator:ac7c37cf8d4ad072477906dd1986d7bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaced7cea929b48668dbc06bce9ea056e"><td class="memItemLeft" align="right" valign="top"><a id="aaced7cea929b48668dbc06bce9ea056e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_referenceExternalSequences</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, <a class="el" href="structrawSeq.html">rawSeq</a> *seq, size_t nbSeq)</td></tr>
<tr class="separator:aaced7cea929b48668dbc06bce9ea056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba07604a85fd9f1d3cc0ce6c76bd6f0d"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aba07604a85fd9f1d3cc0ce6c76bd6f0d">ZSTD_cycleLog</a> (U32 hashLog, ZSTD_strategy strat)</td></tr>
<tr class="separator:aba07604a85fd9f1d3cc0ce6c76bd6f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2479336b82724682dafbc8e0ab99bcd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2479336b82724682dafbc8e0ab99bcd0">ZSTD_CCtx_trace</a> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, size_t extraCSize)</td></tr>
<tr class="separator:a2479336b82724682dafbc8e0ab99bcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2160456e6f0fb00e23fa7978e67186f"><td class="memItemLeft" align="right" valign="top"><a id="ae2160456e6f0fb00e23fa7978e67186f"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_hasExtSeqProd</b> (const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *params)</td></tr>
<tr class="separator:ae2160456e6f0fb00e23fa7978e67186f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31581828d1f82897692929081073270"><td class="memItemLeft" align="right" valign="top"><a id="aa31581828d1f82897692929081073270"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBegin_usingCDict_deprecated</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *cdict)</td></tr>
<tr class="separator:aa31581828d1f82897692929081073270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf6f0290d82e383edfc2c4947cc96d8"><td class="memItemLeft" align="right" valign="top"><a id="aeaf6f0290d82e383edfc2c4947cc96d8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressContinue_public</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:aeaf6f0290d82e383edfc2c4947cc96d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e97916d464f7e2fac3ca4814883b334"><td class="memItemLeft" align="right" valign="top"><a id="a2e97916d464f7e2fac3ca4814883b334"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressEnd_public</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a2e97916d464f7e2fac3ca4814883b334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f96d34eb3da181165e1332ab78308c"><td class="memItemLeft" align="right" valign="top"><a id="a42f96d34eb3da181165e1332ab78308c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_deprecated</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *cctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a42f96d34eb3da181165e1332ab78308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499af15218a3888f7e4b120a24ff2d96"><td class="memItemLeft" align="right" valign="top"><a id="a499af15218a3888f7e4b120a24ff2d96"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_noCompressLiterals</b> (void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a499af15218a3888f7e4b120a24ff2d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67291bd3cf0eb279e3b6d25f6945e63"><td class="memItemLeft" align="right" valign="top"><a id="ae67291bd3cf0eb279e3b6d25f6945e63"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressRleLiteralsBlock</b> (void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:ae67291bd3cf0eb279e3b6d25f6945e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca5939493a9e33c3da498e1d139f601"><td class="memItemLeft" align="right" valign="top"><a id="afca5939493a9e33c3da498e1d139f601"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressLiterals</b> (void *dst, size_t dstCapacity, const void *src, size_t srcSize, void *entropyWorkspace, size_t entropyWorkspaceSize, const <a class="el" href="structZSTD__hufCTables__t.html">ZSTD_hufCTables_t</a> *prevHuf, <a class="el" href="structZSTD__hufCTables__t.html">ZSTD_hufCTables_t</a> *nextHuf, ZSTD_strategy strategy, int disableLiteralCompression, int suspectUncompressible, int bmi2)</td></tr>
<tr class="separator:afca5939493a9e33c3da498e1d139f601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e62056cb67f421e0c049db279197d8f"><td class="memItemLeft" align="right" valign="top"><a id="a0e62056cb67f421e0c049db279197d8f"></a>
SymbolEncodingType_e&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_selectEncodingType</b> (<a class="el" href="zstd_8c.html#aebeae519ed239e8ec29b2926630400b2">FSE_repeat</a> *repeatMode, unsigned const *count, unsigned const max, size_t const mostFrequent, size_t nbSeq, unsigned const FSELog, <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *prevCTable, short const *defaultNorm, U32 defaultNormLog, ZSTD_DefaultPolicy_e const isDefaultAllowed, ZSTD_strategy const strategy)</td></tr>
<tr class="separator:a0e62056cb67f421e0c049db279197d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad426f9c39c10874f35d8a3ca6bc2f4c2"><td class="memItemLeft" align="right" valign="top"><a id="ad426f9c39c10874f35d8a3ca6bc2f4c2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_buildCTable</b> (void *dst, size_t dstCapacity, <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *nextCTable, U32 FSELog, SymbolEncodingType_e type, unsigned *count, U32 max, const BYTE *codeTable, size_t nbSeq, const S16 *defaultNorm, U32 defaultNormLog, U32 defaultMax, const <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *prevCTable, size_t prevCTableSize, void *entropyWorkspace, size_t entropyWorkspaceSize)</td></tr>
<tr class="separator:ad426f9c39c10874f35d8a3ca6bc2f4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c705636d3487a88cd3404beab17c42"><td class="memItemLeft" align="right" valign="top"><a id="af0c705636d3487a88cd3404beab17c42"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_encodeSequences</b> (void *dst, size_t dstCapacity, <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *CTable_MatchLength, BYTE const *mlCodeTable, <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *CTable_OffsetBits, BYTE const *ofCodeTable, <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *CTable_LitLength, BYTE const *llCodeTable, <a class="el" href="structSeqDef__s.html">SeqDef</a> const *sequences, size_t nbSeq, int longOffsets, int bmi2)</td></tr>
<tr class="separator:af0c705636d3487a88cd3404beab17c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace25de051ef535d3ffc9868001417d3b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ace25de051ef535d3ffc9868001417d3b">ZSTD_fseBitCost</a> (<a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *ctable, unsigned const *count, unsigned const max)</td></tr>
<tr class="separator:ace25de051ef535d3ffc9868001417d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cf8e1c619a5e19173ae8a0a29d99ed"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a13cf8e1c619a5e19173ae8a0a29d99ed">ZSTD_crossEntropyCost</a> (short const *norm, unsigned accuracyLog, unsigned const *count, unsigned const max)</td></tr>
<tr class="separator:a13cf8e1c619a5e19173ae8a0a29d99ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b27ac7385a51502a7368c4e13de7143"><td class="memItemLeft" align="right" valign="top"><a id="a9b27ac7385a51502a7368c4e13de7143"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_encodeSequences_body</b> (void *dst, size_t dstCapacity, <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *CTable_MatchLength, BYTE const *mlCodeTable, <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *CTable_OffsetBits, BYTE const *ofCodeTable, <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *CTable_LitLength, BYTE const *llCodeTable, <a class="el" href="structSeqDef__s.html">SeqDef</a> const *sequences, size_t nbSeq, int longOffsets)</td></tr>
<tr class="separator:a9b27ac7385a51502a7368c4e13de7143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7442f7e913229ddf50615c9cf268c01"><td class="memItemLeft" align="right" valign="top"><a id="ae7442f7e913229ddf50615c9cf268c01"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressSuperBlock</b> (<a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *zc, void *dst, size_t dstCapacity, void const *src, size_t srcSize, unsigned lastBlock)</td></tr>
<tr class="separator:ae7442f7e913229ddf50615c9cf268c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b27b395c22175220384b74fb18145b"><td class="memItemLeft" align="right" valign="top"><a id="ae7b27b395c22175220384b74fb18145b"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>hash2</b> (const void *p, unsigned hashLog)</td></tr>
<tr class="separator:ae7b27b395c22175220384b74fb18145b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0773e5bb38c08ec0599e27052bb24b84"><td class="memItemLeft" align="right" valign="top"><a id="a0773e5bb38c08ec0599e27052bb24b84"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>addEvents_generic</b> (<a class="el" href="structFingerprint.html">Fingerprint</a> *fp, const void *src, size_t srcSize, size_t samplingRate, unsigned hashLog)</td></tr>
<tr class="separator:a0773e5bb38c08ec0599e27052bb24b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826e4922bd6871ab2627c0999cb2a1c0"><td class="memItemLeft" align="right" valign="top"><a id="a826e4922bd6871ab2627c0999cb2a1c0"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>recordFingerprint_generic</b> (<a class="el" href="structFingerprint.html">Fingerprint</a> *fp, const void *src, size_t srcSize, size_t samplingRate, unsigned hashLog)</td></tr>
<tr class="separator:a826e4922bd6871ab2627c0999cb2a1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8894777bb1e4eb7d8e835dfa6f210f69"><td class="memItemLeft" align="right" valign="top"><a id="a8894777bb1e4eb7d8e835dfa6f210f69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_fillHashTable</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, void const *end, ZSTD_dictTableLoadMethod_e dtlm, ZSTD_tableFillPurpose_e tfp)</td></tr>
<tr class="separator:a8894777bb1e4eb7d8e835dfa6f210f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c333171bc77513220c3be9093078e"><td class="memItemLeft" align="right" valign="top"><a id="ac44c333171bc77513220c3be9093078e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_fast</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:ac44c333171bc77513220c3be9093078e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beffde2ac537f21e93fcb028e7d300b"><td class="memItemLeft" align="right" valign="top"><a id="a9beffde2ac537f21e93fcb028e7d300b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_fast_dictMatchState</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a9beffde2ac537f21e93fcb028e7d300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4ef67220f1942c6123d71dbeca4a02"><td class="memItemLeft" align="right" valign="top"><a id="a6a4ef67220f1942c6123d71dbeca4a02"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_fast_extDict</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a6a4ef67220f1942c6123d71dbeca4a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acc13e9b1c8e9cae42da6652f971c7a"><td class="memItemLeft" align="right" valign="top"><a id="a1acc13e9b1c8e9cae42da6652f971c7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_fillDoubleHashTable</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, void const *end, ZSTD_dictTableLoadMethod_e dtlm, ZSTD_tableFillPurpose_e tfp)</td></tr>
<tr class="separator:a1acc13e9b1c8e9cae42da6652f971c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac490df0a0e2d71fb50d88a0e7d082991"><td class="memItemLeft" align="right" valign="top"><a id="ac490df0a0e2d71fb50d88a0e7d082991"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_doubleFast</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:ac490df0a0e2d71fb50d88a0e7d082991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe96f0a7b2baf59480e4f35342c96e"><td class="memItemLeft" align="right" valign="top"><a id="a7cfe96f0a7b2baf59480e4f35342c96e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_doubleFast_dictMatchState</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a7cfe96f0a7b2baf59480e4f35342c96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c7ffe3745475b5d6dd1c3c3948c142"><td class="memItemLeft" align="right" valign="top"><a id="ae5c7ffe3745475b5d6dd1c3c3948c142"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_doubleFast_extDict</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:ae5c7ffe3745475b5d6dd1c3c3948c142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b559c97035023245fae1f74c5e5697"><td class="memItemLeft" align="right" valign="top"><a id="a84b559c97035023245fae1f74c5e5697"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_insertAndFindFirstIndex</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *ip)</td></tr>
<tr class="separator:a84b559c97035023245fae1f74c5e5697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2993d983a65251d92c7bb47f929618ac"><td class="memItemLeft" align="right" valign="top"><a id="a2993d983a65251d92c7bb47f929618ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_update</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *const ms, const BYTE *ip)</td></tr>
<tr class="separator:a2993d983a65251d92c7bb47f929618ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa705408e483f9509d1efd1b3b2f5c6e9"><td class="memItemLeft" align="right" valign="top"><a id="aa705408e483f9509d1efd1b3b2f5c6e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dedicatedDictSearch_lazy_loadDictionary</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *const ip)</td></tr>
<tr class="separator:aa705408e483f9509d1efd1b3b2f5c6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138012f4948d5907886447b8423ed091"><td class="memItemLeft" align="right" valign="top"><a id="a138012f4948d5907886447b8423ed091"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_preserveUnsortedMark</b> (U32 *const table, U32 const size, U32 const reducerValue)</td></tr>
<tr class="separator:a138012f4948d5907886447b8423ed091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1c3b7591d8f246da5805d86947daea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a5f1c3b7591d8f246da5805d86947daea">ZSTD_compressBlock_greedy</a> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a5f1c3b7591d8f246da5805d86947daea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0611f848519f1a831da4c007341af7a"><td class="memItemLeft" align="right" valign="top"><a id="ad0611f848519f1a831da4c007341af7a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_greedy_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:ad0611f848519f1a831da4c007341af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d8125b4bc554443f20a3c79b44a9a2"><td class="memItemLeft" align="right" valign="top"><a id="a63d8125b4bc554443f20a3c79b44a9a2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_greedy_dictMatchState</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a63d8125b4bc554443f20a3c79b44a9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b5ca4499c143a10e2333ccfa827b9a"><td class="memItemLeft" align="right" valign="top"><a id="a48b5ca4499c143a10e2333ccfa827b9a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_greedy_dictMatchState_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a48b5ca4499c143a10e2333ccfa827b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eee3fe7e7382557d397e3f51cfe9c6"><td class="memItemLeft" align="right" valign="top"><a id="a04eee3fe7e7382557d397e3f51cfe9c6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_greedy_dedicatedDictSearch</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a04eee3fe7e7382557d397e3f51cfe9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f45881e6d99d049f8d53fb5b0ef1846"><td class="memItemLeft" align="right" valign="top"><a id="a7f45881e6d99d049f8d53fb5b0ef1846"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_greedy_dedicatedDictSearch_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a7f45881e6d99d049f8d53fb5b0ef1846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25452e639388c4757d75d64ae4b7cebb"><td class="memItemLeft" align="right" valign="top"><a id="a25452e639388c4757d75d64ae4b7cebb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_greedy_extDict</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a25452e639388c4757d75d64ae4b7cebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba5cbee0715f63bb964a84493673303"><td class="memItemLeft" align="right" valign="top"><a id="acba5cbee0715f63bb964a84493673303"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_greedy_extDict_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:acba5cbee0715f63bb964a84493673303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eef3a0cb29149e76317ef820ee1eba0"><td class="memItemLeft" align="right" valign="top"><a id="a2eef3a0cb29149e76317ef820ee1eba0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a2eef3a0cb29149e76317ef820ee1eba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7096babef481b7dafe497bd1f4ad5e43"><td class="memItemLeft" align="right" valign="top"><a id="a7096babef481b7dafe497bd1f4ad5e43"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a7096babef481b7dafe497bd1f4ad5e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913996e549fe1c8869a2a2a84c692dd5"><td class="memItemLeft" align="right" valign="top"><a id="a913996e549fe1c8869a2a2a84c692dd5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_dictMatchState</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a913996e549fe1c8869a2a2a84c692dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4976a5e070b3ccfc2f14dd3baf2f2e"><td class="memItemLeft" align="right" valign="top"><a id="aec4976a5e070b3ccfc2f14dd3baf2f2e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_dictMatchState_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:aec4976a5e070b3ccfc2f14dd3baf2f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc2382a82874b1be34fe17130afcc30"><td class="memItemLeft" align="right" valign="top"><a id="a4dc2382a82874b1be34fe17130afcc30"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_dedicatedDictSearch</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a4dc2382a82874b1be34fe17130afcc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7ab01239f8d3d7a50345704d8c227d"><td class="memItemLeft" align="right" valign="top"><a id="a3e7ab01239f8d3d7a50345704d8c227d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_dedicatedDictSearch_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a3e7ab01239f8d3d7a50345704d8c227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab837f41d8e68d78e72b648d0302b60cc"><td class="memItemLeft" align="right" valign="top"><a id="ab837f41d8e68d78e72b648d0302b60cc"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_extDict</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:ab837f41d8e68d78e72b648d0302b60cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a70f588e89470f5b78333036f7b396"><td class="memItemLeft" align="right" valign="top"><a id="a71a70f588e89470f5b78333036f7b396"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_extDict_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a71a70f588e89470f5b78333036f7b396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f3fdbb012db86bab0650e515a4b1c0"><td class="memItemLeft" align="right" valign="top"><a id="a87f3fdbb012db86bab0650e515a4b1c0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy2</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a87f3fdbb012db86bab0650e515a4b1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce29a80b54d7b3d433369852004fbcf"><td class="memItemLeft" align="right" valign="top"><a id="a5ce29a80b54d7b3d433369852004fbcf"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy2_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a5ce29a80b54d7b3d433369852004fbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f6bff5ecb51a6377417df399a7755a"><td class="memItemLeft" align="right" valign="top"><a id="a39f6bff5ecb51a6377417df399a7755a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy2_dictMatchState</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a39f6bff5ecb51a6377417df399a7755a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af852f6d2d96993bee8144cff33c2a19b"><td class="memItemLeft" align="right" valign="top"><a id="af852f6d2d96993bee8144cff33c2a19b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy2_dictMatchState_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:af852f6d2d96993bee8144cff33c2a19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0439bd0669ec52abbbf0cf4d81921434"><td class="memItemLeft" align="right" valign="top"><a id="a0439bd0669ec52abbbf0cf4d81921434"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy2_dedicatedDictSearch</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a0439bd0669ec52abbbf0cf4d81921434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e91cc4138133c39790faccfd56902a"><td class="memItemLeft" align="right" valign="top"><a id="ad7e91cc4138133c39790faccfd56902a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy2_dedicatedDictSearch_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:ad7e91cc4138133c39790faccfd56902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2150feb58d1267f413c0bbbdfb57b8e8"><td class="memItemLeft" align="right" valign="top"><a id="a2150feb58d1267f413c0bbbdfb57b8e8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy2_extDict</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a2150feb58d1267f413c0bbbdfb57b8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907b3ebebe5577ad126d579929e35968"><td class="memItemLeft" align="right" valign="top"><a id="a907b3ebebe5577ad126d579929e35968"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy2_extDict_row</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a907b3ebebe5577ad126d579929e35968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18402aec18dcea152cce9bfabf930cb0"><td class="memItemLeft" align="right" valign="top"><a id="a18402aec18dcea152cce9bfabf930cb0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btlazy2</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a18402aec18dcea152cce9bfabf930cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf3b8b9812247bd4f9a0901068d67d3"><td class="memItemLeft" align="right" valign="top"><a id="aacf3b8b9812247bd4f9a0901068d67d3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btlazy2_dictMatchState</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:aacf3b8b9812247bd4f9a0901068d67d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72655c03d2f662208890e56c289a790f"><td class="memItemLeft" align="right" valign="top"><a id="a72655c03d2f662208890e56c289a790f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btlazy2_extDict</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a72655c03d2f662208890e56c289a790f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99997532f466a34c01e9083b5cd2d400"><td class="memItemLeft" align="right" valign="top"><a id="a99997532f466a34c01e9083b5cd2d400"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_updateTree</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *ip, const BYTE *iend)</td></tr>
<tr class="separator:a99997532f466a34c01e9083b5cd2d400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ca8ab3ace20c5204be59862f8f6fa9"><td class="memItemLeft" align="right" valign="top"><a id="a58ca8ab3ace20c5204be59862f8f6fa9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btopt</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a58ca8ab3ace20c5204be59862f8f6fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db411c192afa3a5d40f5ac96b17216b"><td class="memItemLeft" align="right" valign="top"><a id="a9db411c192afa3a5d40f5ac96b17216b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btopt_dictMatchState</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a9db411c192afa3a5d40f5ac96b17216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1432cee3fad0c212c1b5a3fbf978c73c"><td class="memItemLeft" align="right" valign="top"><a id="a1432cee3fad0c212c1b5a3fbf978c73c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btopt_extDict</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a1432cee3fad0c212c1b5a3fbf978c73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35851f1969685b48e3e82355da165865"><td class="memItemLeft" align="right" valign="top"><a id="a35851f1969685b48e3e82355da165865"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btultra</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a35851f1969685b48e3e82355da165865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab5fe8e3c80271dfb56de78eb04b37f"><td class="memItemLeft" align="right" valign="top"><a id="abab5fe8e3c80271dfb56de78eb04b37f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btultra_dictMatchState</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:abab5fe8e3c80271dfb56de78eb04b37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31790347671f00e3d7b2ab3a584eb64"><td class="memItemLeft" align="right" valign="top"><a id="ab31790347671f00e3d7b2ab3a584eb64"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btultra_extDict</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:ab31790347671f00e3d7b2ab3a584eb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cd801d8869f47db7a6e2410d7b3ff7"><td class="memItemLeft" align="right" valign="top"><a id="a40cd801d8869f47db7a6e2410d7b3ff7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_btultra2</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize)</td></tr>
<tr class="separator:a40cd801d8869f47db7a6e2410d7b3ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb22a163701a9f0295da8e8038e5837"><td class="memItemLeft" align="right" valign="top"><a id="a0bb22a163701a9f0295da8e8038e5837"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ldm_fillHashTable</b> (<a class="el" href="structldmState__t.html">ldmState_t</a> *state, const BYTE *ip, const BYTE *iend, <a class="el" href="structldmParams__t.html">ldmParams_t</a> const *params)</td></tr>
<tr class="separator:a0bb22a163701a9f0295da8e8038e5837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5c9ac495d0bdcdfe9884ef3539b34f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#abc5c9ac495d0bdcdfe9884ef3539b34f">ZSTD_ldm_generateSequences</a> (<a class="el" href="structldmState__t.html">ldmState_t</a> *ldms, <a class="el" href="structRawSeqStore__t.html">RawSeqStore_t</a> *sequences, <a class="el" href="structldmParams__t.html">ldmParams_t</a> const *params, void const *src, size_t srcSize)</td></tr>
<tr class="separator:abc5c9ac495d0bdcdfe9884ef3539b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87025f90027ce06919c80a0e6858dc38"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a87025f90027ce06919c80a0e6858dc38">ZSTD_ldm_blockCompress</a> (<a class="el" href="structRawSeqStore__t.html">RawSeqStore_t</a> *rawSeqStore, <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], ZSTD_ParamSwitch_e useRowMatchFinder, void const *src, size_t srcSize)</td></tr>
<tr class="separator:a87025f90027ce06919c80a0e6858dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0669d4bb3b7e8a22e6a0604938aca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1d0669d4bb3b7e8a22e6a0604938aca1">ZSTD_ldm_skipSequences</a> (<a class="el" href="structRawSeqStore__t.html">RawSeqStore_t</a> *rawSeqStore, size_t srcSize, U32 const minMatch)</td></tr>
<tr class="separator:a1d0669d4bb3b7e8a22e6a0604938aca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c7a0249afd333165d38a4ac4a9a0f2"><td class="memItemLeft" align="right" valign="top"><a id="a59c7a0249afd333165d38a4ac4a9a0f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_ldm_skipRawSeqStoreBytes</b> (<a class="el" href="structRawSeqStore__t.html">RawSeqStore_t</a> *rawSeqStore, size_t nbBytes)</td></tr>
<tr class="separator:a59c7a0249afd333165d38a4ac4a9a0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a6ee793b025994c7102e0b08918129"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#af3a6ee793b025994c7102e0b08918129">ZSTD_ldm_getTableSize</a> (<a class="el" href="structldmParams__t.html">ldmParams_t</a> params)</td></tr>
<tr class="separator:af3a6ee793b025994c7102e0b08918129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e65e54701af3291da1246800b46cc81"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8e65e54701af3291da1246800b46cc81">ZSTD_ldm_getMaxNbSeq</a> (<a class="el" href="structldmParams__t.html">ldmParams_t</a> params, size_t maxChunkSize)</td></tr>
<tr class="separator:a8e65e54701af3291da1246800b46cc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516b3c0b84a8f87c0257e945fccbb1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a516b3c0b84a8f87c0257e945fccbb1a3">ZSTD_ldm_adjustParameters</a> (<a class="el" href="structldmParams__t.html">ldmParams_t</a> *params, <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> const *cParams)</td></tr>
<tr class="separator:a516b3c0b84a8f87c0257e945fccbb1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1bca487b05d262cc8c91a5e999e785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1c1bca487b05d262cc8c91a5e999e785">ZSTD_reduceTable_internal</a> (U32 *const table, U32 const size, U32 const reducerValue, int const preserveMark)</td></tr>
<tr class="separator:a1c1bca487b05d262cc8c91a5e999e785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8a3b1fecfacc453e48fac218806d23"><td class="memItemLeft" align="right" valign="top"><a id="a6a8a3b1fecfacc453e48fac218806d23"></a>
MEM_STATIC size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_entropyCompressSeqStore_internal</b> (void *dst, size_t dstCapacity, const void *literals, size_t litSize, const <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStorePtr, const <a class="el" href="structZSTD__entropyCTables__t.html">ZSTD_entropyCTables_t</a> *prevEntropy, <a class="el" href="structZSTD__entropyCTables__t.html">ZSTD_entropyCTables_t</a> *nextEntropy, const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *cctxParams, void *entropyWorkspace, size_t entropyWkspSize, const int bmi2)</td></tr>
<tr class="separator:a6a8a3b1fecfacc453e48fac218806d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45fd981751eeb5431a8e45b93cde4b"><td class="memItemLeft" align="right" valign="top"><a id="a9b45fd981751eeb5431a8e45b93cde4b"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_doubleFast_noDict_generic</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize, U32 const mls)</td></tr>
<tr class="separator:a9b45fd981751eeb5431a8e45b93cde4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7e7b79ce1972e7b657218561120488"><td class="memItemLeft" align="right" valign="top"><a id="a8c7e7b79ce1972e7b657218561120488"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_doubleFast_dictMatchState_generic</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize, U32 const mls)</td></tr>
<tr class="separator:a8c7e7b79ce1972e7b657218561120488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90708241a9dd80d0ed983f4671f1649b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a90708241a9dd80d0ed983f4671f1649b">ZSTD_compressBlock_fast_noDict_generic</a> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize, U32 const mls, int useCmov)</td></tr>
<tr class="separator:a90708241a9dd80d0ed983f4671f1649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e6ae81ae5b662f016c5e21e0f7c26a"><td class="memItemLeft" align="right" valign="top"><a id="af4e6ae81ae5b662f016c5e21e0f7c26a"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_fast_dictMatchState_generic</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], void const *src, size_t srcSize, U32 const mls, U32 const hasStep)</td></tr>
<tr class="separator:af4e6ae81ae5b662f016c5e21e0f7c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd10da54840c09ebe9e65c70abf28bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#afd10da54840c09ebe9e65c70abf28bd5">ZSTD_BtFindBestMatch</a> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *const ip, const BYTE *const iLimit, size_t *offBasePtr, const U32 mls, const ZSTD_dictMode_e dictMode)</td></tr>
<tr class="separator:afd10da54840c09ebe9e65c70abf28bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f4dacbb84289c11a5fdcea5892818a"><td class="memItemLeft" align="right" valign="top"><a id="a68f4dacbb84289c11a5fdcea5892818a"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_dedicatedDictSearch_lazy_search</b> (size_t *offsetPtr, size_t ml, U32 nbAttempts, const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *const dms, const BYTE *const ip, const BYTE *const iLimit, const BYTE *const prefixStart, const U32 curr, const U32 dictLimit, const size_t ddsIdx)</td></tr>
<tr class="separator:a68f4dacbb84289c11a5fdcea5892818a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace86e455cf82e1fe4722712cc4f63c0"><td class="memItemLeft" align="right" valign="top"><a id="aace86e455cf82e1fe4722712cc4f63c0"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_insertAndFindFirstIndex_internal</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const <a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> *const cParams, const BYTE *ip, U32 const mls, U32 const lazySkipping)</td></tr>
<tr class="separator:aace86e455cf82e1fe4722712cc4f63c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e16727a035ca1d9ae1ffd485bcd013"><td class="memItemLeft" align="right" valign="top"><a id="a76e16727a035ca1d9ae1ffd485bcd013"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_HcFindBestMatch</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *const ip, const BYTE *const iLimit, size_t *offsetPtr, const U32 mls, const ZSTD_dictMode_e dictMode)</td></tr>
<tr class="separator:a76e16727a035ca1d9ae1ffd485bcd013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1371be76dbb7b9617348d8f3d606e460"><td class="memItemLeft" align="right" valign="top"><a id="a1371be76dbb7b9617348d8f3d606e460"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_VecMask_next</b> (ZSTD_VecMask val)</td></tr>
<tr class="separator:a1371be76dbb7b9617348d8f3d606e460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57939a28977369de3a1c876372bc3cac"><td class="memItemLeft" align="right" valign="top"><a id="a57939a28977369de3a1c876372bc3cac"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_nextIndex</b> (BYTE *const tagRow, U32 const rowMask)</td></tr>
<tr class="separator:a57939a28977369de3a1c876372bc3cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f52ad7259e5af8c1500a3bd568e7d81"><td class="memItemLeft" align="right" valign="top"><a id="a2f52ad7259e5af8c1500a3bd568e7d81"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_isAligned</b> (void const *ptr, size_t align)</td></tr>
<tr class="separator:a2f52ad7259e5af8c1500a3bd568e7d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ba03919f23d7902e7bc2fa1edf6dab"><td class="memItemLeft" align="right" valign="top"><a id="aa4ba03919f23d7902e7bc2fa1edf6dab"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_prefetch</b> (U32 const *hashTable, BYTE const *tagTable, U32 const relRow, U32 const rowLog)</td></tr>
<tr class="separator:aa4ba03919f23d7902e7bc2fa1edf6dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daa2c570c793b6656ef1ff4b80b4d5a"><td class="memItemLeft" align="right" valign="top"><a id="a4daa2c570c793b6656ef1ff4b80b4d5a"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_fillHashCache</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *base, U32 const rowLog, U32 const mls, U32 idx, const BYTE *const iLimit)</td></tr>
<tr class="separator:a4daa2c570c793b6656ef1ff4b80b4d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8716a84934389fa16137a0b7a8f7b18"><td class="memItemLeft" align="right" valign="top"><a id="af8716a84934389fa16137a0b7a8f7b18"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_nextCachedHash</b> (U32 *cache, U32 const *hashTable, BYTE const *tagTable, BYTE const *base, U32 idx, U32 const hashLog, U32 const rowLog, U32 const mls, U64 const hashSalt)</td></tr>
<tr class="separator:af8716a84934389fa16137a0b7a8f7b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac1d477c9da8cd9c64a7437e8ab6d76"><td class="memItemLeft" align="right" valign="top"><a id="abac1d477c9da8cd9c64a7437e8ab6d76"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_update_internalImpl</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, U32 updateStartIdx, U32 const updateEndIdx, U32 const mls, U32 const rowLog, U32 const rowMask, U32 const useCache)</td></tr>
<tr class="separator:abac1d477c9da8cd9c64a7437e8ab6d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be69d3ec7b397c9f53453fba897cdfb"><td class="memItemLeft" align="right" valign="top"><a id="a4be69d3ec7b397c9f53453fba897cdfb"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_update_internal</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *ip, U32 const mls, U32 const rowLog, U32 const rowMask, U32 const useCache)</td></tr>
<tr class="separator:a4be69d3ec7b397c9f53453fba897cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2426ae62a314d5d64592b980f3c73fb5"><td class="memItemLeft" align="right" valign="top"><a id="a2426ae62a314d5d64592b980f3c73fb5"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_matchMaskGroupWidth</b> (const U32 rowEntries)</td></tr>
<tr class="separator:a2426ae62a314d5d64592b980f3c73fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3172d4c55d9066eb65c9e9540c589b"><td class="memItemLeft" align="right" valign="top"><a id="abe3172d4c55d9066eb65c9e9540c589b"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> ZSTD_VecMask&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_row_getMatchMask</b> (const BYTE *const tagRow, const BYTE tag, const U32 headGrouped, const U32 rowEntries)</td></tr>
<tr class="separator:abe3172d4c55d9066eb65c9e9540c589b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1eb28119d07b5a510170678bc9733d"><td class="memItemLeft" align="right" valign="top"><a id="afd1eb28119d07b5a510170678bc9733d"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_RowFindBestMatch</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *const ip, const BYTE *const iLimit, size_t *offsetPtr, const U32 mls, const ZSTD_dictMode_e dictMode, const U32 rowLog)</td></tr>
<tr class="separator:afd1eb28119d07b5a510170678bc9733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d83089efbda033b3ff3ac36e1e52b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a56d83089efbda033b3ff3ac36e1e52b6">ZSTD_searchMax</a> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *ip, const BYTE *iend, size_t *offsetPtr, U32 const mls, U32 const rowLog, searchMethod_e const searchMethod, ZSTD_dictMode_e const dictMode)</td></tr>
<tr class="separator:a56d83089efbda033b3ff3ac36e1e52b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c418298528f5926a058f683e2f2b3a"><td class="memItemLeft" align="right" valign="top"><a id="ae7c418298528f5926a058f683e2f2b3a"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_generic</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], const void *src, size_t srcSize, const searchMethod_e searchMethod, const U32 depth, ZSTD_dictMode_e const dictMode)</td></tr>
<tr class="separator:ae7c418298528f5926a058f683e2f2b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904e4502f9de20c12040fb77732dcd22"><td class="memItemLeft" align="right" valign="top"><a id="a904e4502f9de20c12040fb77732dcd22"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_lazy_extDict_generic</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], const void *src, size_t srcSize, const searchMethod_e searchMethod, const U32 depth)</td></tr>
<tr class="separator:a904e4502f9de20c12040fb77732dcd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0b56a337d75ef9ec821f7895d3a2db"><td class="memItemLeft" align="right" valign="top"><a id="a2f0b56a337d75ef9ec821f7895d3a2db"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_bitWeight</b> (U32 stat)</td></tr>
<tr class="separator:a2f0b56a337d75ef9ec821f7895d3a2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f26b4677512b92fc7bc958d96762be"><td class="memItemLeft" align="right" valign="top"><a id="a08f26b4677512b92fc7bc958d96762be"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_fracWeight</b> (U32 rawStat)</td></tr>
<tr class="separator:a08f26b4677512b92fc7bc958d96762be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbebd9580f99b455e657f9209eb40b9"><td class="memItemLeft" align="right" valign="top"><a id="a8cbebd9580f99b455e657f9209eb40b9"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_getMatchPrice</b> (U32 const offBase, U32 const matchLength, const <a class="el" href="structoptState__t.html">optState_t</a> *const optPtr, int const optLevel)</td></tr>
<tr class="separator:a8cbebd9580f99b455e657f9209eb40b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c64d42ac6a40371809f34b9a7c3f32e"><td class="memItemLeft" align="right" valign="top"><a id="a8c64d42ac6a40371809f34b9a7c3f32e"></a>
MEM_STATIC U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_readMINMATCH</b> (const void *memPtr, U32 length)</td></tr>
<tr class="separator:a8c64d42ac6a40371809f34b9a7c3f32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa469195b2ba28394889f03699a144dd"><td class="memItemLeft" align="right" valign="top"><a id="afa469195b2ba28394889f03699a144dd"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_updateTree_internal</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, const BYTE *const ip, const BYTE *const iend, const U32 mls, const ZSTD_dictMode_e dictMode)</td></tr>
<tr class="separator:afa469195b2ba28394889f03699a144dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6af11856964351554b9d1eab7d16eb"><td class="memItemLeft" align="right" valign="top"><a id="aab6af11856964351554b9d1eab7d16eb"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_insertBtAndGetAllMatches</b> (<a class="el" href="structZSTD__match__t.html">ZSTD_match_t</a> *matches, <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, U32 *nextToUpdate3, const BYTE *const ip, const BYTE *const iLimit, const ZSTD_dictMode_e dictMode, const U32 rep[ZSTD_REP_NUM], const U32 ll0, const U32 lengthToBeat, const U32 mls)</td></tr>
<tr class="separator:aab6af11856964351554b9d1eab7d16eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e467ec4c049e455318435f69db909fe"><td class="memItemLeft" align="right" valign="top"><a id="a0e467ec4c049e455318435f69db909fe"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_btGetAllMatches_internal</b> (<a class="el" href="structZSTD__match__t.html">ZSTD_match_t</a> *matches, <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, U32 *nextToUpdate3, const BYTE *ip, const BYTE *const iHighLimit, const U32 rep[ZSTD_REP_NUM], U32 const ll0, U32 const lengthToBeat, const ZSTD_dictMode_e dictMode, const U32 mls)</td></tr>
<tr class="separator:a0e467ec4c049e455318435f69db909fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55c0365aa847b13e4529f391960fdf8"><td class="memItemLeft" align="right" valign="top"><a id="ac55c0365aa847b13e4529f391960fdf8"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_compressBlock_opt_generic</b> (<a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *ms, <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *seqStore, U32 rep[ZSTD_REP_NUM], const void *src, size_t srcSize, const int optLevel, const ZSTD_dictMode_e dictMode)</td></tr>
<tr class="separator:ac55c0365aa847b13e4529f391960fdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203bf2e3779b22d9213664313057641e"><td class="memItemLeft" align="right" valign="top"><a id="a203bf2e3779b22d9213664313057641e"></a>
MEM_STATIC <a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTDMT_createCCtx_advanced_internal</b> (unsigned nbWorkers, <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> cMem, <a class="el" href="zstd_8c.html#aa979b4b649aec2c11af1876dcae1590a">ZSTD_threadPool</a> *pool)</td></tr>
<tr class="separator:a203bf2e3779b22d9213664313057641e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dd8c0b265075d80e846871925ef541"><td class="memItemLeft" align="right" valign="top"><a id="a48dd8c0b265075d80e846871925ef541"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> BYTE&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decodeSymbolX1</b> (<a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *Dstream, const <a class="el" href="structHUF__DEltX1.html">HUF_DEltX1</a> *dt, const U32 dtLog)</td></tr>
<tr class="separator:a48dd8c0b265075d80e846871925ef541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e44e9f1add94934647e21a65e6986d"><td class="memItemLeft" align="right" valign="top"><a id="a18e44e9f1add94934647e21a65e6986d"></a>
<a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decodeStreamX1</b> (BYTE *p, <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *const bitDPtr, BYTE *const pEnd, const <a class="el" href="structHUF__DEltX1.html">HUF_DEltX1</a> *const dt, const U32 dtLog)</td></tr>
<tr class="separator:a18e44e9f1add94934647e21a65e6986d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8170a42f77deec470d9c267069d869"><td class="memItemLeft" align="right" valign="top"><a id="abd8170a42f77deec470d9c267069d869"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress1X1_usingDTable_internal_body</b> (void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, const HUF_DTable *DTable)</td></tr>
<tr class="separator:abd8170a42f77deec470d9c267069d869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa290486718f30d3114b0aff7c35f155b"><td class="memItemLeft" align="right" valign="top"><a id="aa290486718f30d3114b0aff7c35f155b"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress4X1_usingDTable_internal_body</b> (void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, const HUF_DTable *DTable)</td></tr>
<tr class="separator:aa290486718f30d3114b0aff7c35f155b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53f7189d29992e316c61fa3609d3f32"><td class="memItemLeft" align="right" valign="top"><a id="ac53f7189d29992e316c61fa3609d3f32"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decodeSymbolX2</b> (void *op, <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *DStream, const <a class="el" href="structHUF__DEltX2.html">HUF_DEltX2</a> *dt, const U32 dtLog)</td></tr>
<tr class="separator:ac53f7189d29992e316c61fa3609d3f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50ab3693c5bc5e1e68a33c16873878c"><td class="memItemLeft" align="right" valign="top"><a id="af50ab3693c5bc5e1e68a33c16873878c"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> U32&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decodeLastSymbolX2</b> (void *op, <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *DStream, const <a class="el" href="structHUF__DEltX2.html">HUF_DEltX2</a> *dt, const U32 dtLog)</td></tr>
<tr class="separator:af50ab3693c5bc5e1e68a33c16873878c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101c3188c4918fd7cb6afd53f9d81a15"><td class="memItemLeft" align="right" valign="top"><a id="a101c3188c4918fd7cb6afd53f9d81a15"></a>
<a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decodeStreamX2</b> (BYTE *p, <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitDPtr, BYTE *const pEnd, const <a class="el" href="structHUF__DEltX2.html">HUF_DEltX2</a> *const dt, const U32 dtLog)</td></tr>
<tr class="separator:a101c3188c4918fd7cb6afd53f9d81a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602437097a8e42c11b34c25d185f34f9"><td class="memItemLeft" align="right" valign="top"><a id="a602437097a8e42c11b34c25d185f34f9"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress1X2_usingDTable_internal_body</b> (void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, const HUF_DTable *DTable)</td></tr>
<tr class="separator:a602437097a8e42c11b34c25d185f34f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb1f2743ef280f0116006dc03912d12"><td class="memItemLeft" align="right" valign="top"><a id="a4bb1f2743ef280f0116006dc03912d12"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>HUF_decompress4X2_usingDTable_internal_body</b> (void *dst, size_t dstSize, const void *cSrc, size_t cSrcSize, const HUF_DTable *DTable)</td></tr>
<tr class="separator:a4bb1f2743ef280f0116006dc03912d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f16d60b82001e335c85046ba9a1c138"><td class="memItemLeft" align="right" valign="top"><a id="a3f16d60b82001e335c85046ba9a1c138"></a>
MEM_STATIC int&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DCtx_get_bmi2</b> (const struct <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx_s</a> *dctx)</td></tr>
<tr class="separator:a3f16d60b82001e335c85046ba9a1c138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af4eab5a51ba4fcef1a28f25a44f0a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a6af4eab5a51ba4fcef1a28f25a44f0a5">ZSTD_loadDEntropy</a> (<a class="el" href="structZSTD__entropyDTables__t.html">ZSTD_entropyDTables_t</a> *entropy, const void *const dict, size_t const dictSize)</td></tr>
<tr class="separator:a6af4eab5a51ba4fcef1a28f25a44f0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4057190c93c37f887735a7e1c152ddc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4057190c93c37f887735a7e1c152ddc5">ZSTD_checkContinuity</a> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *dst, size_t dstSize)</td></tr>
<tr class="separator:a4057190c93c37f887735a7e1c152ddc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76365037bee4336a8f3db94a5afbe665"><td class="memItemLeft" align="right" valign="top"><a id="a76365037bee4336a8f3db94a5afbe665"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DDict_dictContent</b> (const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:a76365037bee4336a8f3db94a5afbe665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420ed034ce4edbe8a8fb4bdce8075bb"><td class="memItemLeft" align="right" valign="top"><a id="ac420ed034ce4edbe8a8fb4bdce8075bb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_DDict_dictSize</b> (const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:ac420ed034ce4edbe8a8fb4bdce8075bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfe859207981d85e750824a21e74d61"><td class="memItemLeft" align="right" valign="top"><a id="a5bfe859207981d85e750824a21e74d61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_copyDDictParameters</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *ddict)</td></tr>
<tr class="separator:a5bfe859207981d85e750824a21e74d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63e21ca8915aad528a26782a5c0c5fa"><td class="memItemLeft" align="right" valign="top"><a id="ac63e21ca8915aad528a26782a5c0c5fa"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressBlock_internal</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize, const streaming_operation streaming)</td></tr>
<tr class="separator:ac63e21ca8915aad528a26782a5c0c5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1de30cc49bd814d054e34a2bbf6f16c"><td class="memItemLeft" align="right" valign="top"><a id="ab1de30cc49bd814d054e34a2bbf6f16c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_buildFSETable</b> (<a class="el" href="structZSTD__seqSymbol.html">ZSTD_seqSymbol</a> *dt, const short *normalizedCounter, unsigned maxSymbolValue, const U32 *baseValue, const U8 *nbAdditionalBits, unsigned tableLog, void *wksp, size_t wkspSize, int bmi2)</td></tr>
<tr class="separator:ab1de30cc49bd814d054e34a2bbf6f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd054ccbbdd6a55685009d397cdb008"><td class="memItemLeft" align="right" valign="top"><a id="a0fd054ccbbdd6a55685009d397cdb008"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressBlock_deprecated</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t dstCapacity, const void *src, size_t srcSize)</td></tr>
<tr class="separator:a0fd054ccbbdd6a55685009d397cdb008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfd7d03fa8df0992586a3189b1075db"><td class="memItemLeft" align="right" valign="top"><a id="aabfd7d03fa8df0992586a3189b1075db"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decodeLiteralsBlock_wrapper</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, const void *src, size_t srcSize, void *dst, size_t dstCapacity)</td></tr>
<tr class="separator:aabfd7d03fa8df0992586a3189b1075db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb680ce5542e874a9d7691c4665c6916"><td class="memItemLeft" align="right" valign="top"><a id="adb680ce5542e874a9d7691c4665c6916"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_buildFSETable_body</b> (<a class="el" href="structZSTD__seqSymbol.html">ZSTD_seqSymbol</a> *dt, const short *normalizedCounter, unsigned maxSymbolValue, const U32 *baseValue, const U8 *nbAdditionalBits, unsigned tableLog, void *wksp, size_t wkspSize)</td></tr>
<tr class="separator:adb680ce5542e874a9d7691c4665c6916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bb8df3c6a43218a558c2ce1a69b3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a14bb8df3c6a43218a558c2ce1a69b3f4">ZSTD_overlapCopy8</a> (BYTE **op, BYTE const **ip, size_t offset)</td></tr>
<tr class="separator:a14bb8df3c6a43218a558c2ce1a69b3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b8a2651dd2cad0dccf84f21ea3e9cc"><td class="memItemLeft" align="right" valign="top"><a id="a64b8a2651dd2cad0dccf84f21ea3e9cc"></a>
FORCE_NOINLINE <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_execSequenceEnd</b> (BYTE *op, BYTE *const oend, <a class="el" href="structseq__t.html">seq_t</a> sequence, const BYTE **litPtr, const BYTE *const litLimit, const BYTE *const prefixStart, const BYTE *const virtualStart, const BYTE *const dictEnd)</td></tr>
<tr class="separator:a64b8a2651dd2cad0dccf84f21ea3e9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b3d6504f8abd631313907b708dbcf5"><td class="memItemLeft" align="right" valign="top"><a id="ac3b3d6504f8abd631313907b708dbcf5"></a>
FORCE_NOINLINE <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_execSequenceEndSplitLitBuffer</b> (BYTE *op, BYTE *const oend, const BYTE *const oend_w, <a class="el" href="structseq__t.html">seq_t</a> sequence, const BYTE **litPtr, const BYTE *const litLimit, const BYTE *const prefixStart, const BYTE *const virtualStart, const BYTE *const dictEnd)</td></tr>
<tr class="separator:ac3b3d6504f8abd631313907b708dbcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d8156a8b827f47096b2adf4d4dc4dd"><td class="memItemLeft" align="right" valign="top"><a id="ac3d8156a8b827f47096b2adf4d4dc4dd"></a>
<a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_execSequence</b> (BYTE *op, BYTE *const oend, <a class="el" href="structseq__t.html">seq_t</a> sequence, const BYTE **litPtr, const BYTE *const litLimit, const BYTE *const prefixStart, const BYTE *const virtualStart, const BYTE *const dictEnd)</td></tr>
<tr class="separator:ac3d8156a8b827f47096b2adf4d4dc4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875a52c9230172b36ff152f4b6eb8a9a"><td class="memItemLeft" align="right" valign="top"><a id="a875a52c9230172b36ff152f4b6eb8a9a"></a>
<a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_execSequenceSplitLitBuffer</b> (BYTE *op, BYTE *const oend, const BYTE *const oend_w, <a class="el" href="structseq__t.html">seq_t</a> sequence, const BYTE **litPtr, const BYTE *const litLimit, const BYTE *const prefixStart, const BYTE *const virtualStart, const BYTE *const dictEnd)</td></tr>
<tr class="separator:a875a52c9230172b36ff152f4b6eb8a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f16c7ae1e2ae16b8710e54c92c28199"><td class="memItemLeft" align="right" valign="top"><a id="a5f16c7ae1e2ae16b8710e54c92c28199"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_updateFseStateWithDInfo</b> (<a class="el" href="structZSTD__fseState.html">ZSTD_fseState</a> *DStatePtr, <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *bitD, U16 nextState, U32 nbBits)</td></tr>
<tr class="separator:a5f16c7ae1e2ae16b8710e54c92c28199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5f39b04f25f22e9299d7f1baf82efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="structseq__t.html">seq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a9b5f39b04f25f22e9299d7f1baf82efc">ZSTD_decodeSequence</a> (<a class="el" href="structseqState__t.html">seqState_t</a> *seqState, const ZSTD_longOffset_e longOffsets, const int isLastSeq)</td></tr>
<tr class="separator:a9b5f39b04f25f22e9299d7f1baf82efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ca65fd1b95822e8776fce6cec9b26a"><td class="memItemLeft" align="right" valign="top"><a id="ac7ca65fd1b95822e8776fce6cec9b26a"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t DONT_VECTORIZE&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressSequences_bodySplitLitBuffer</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t maxDstSize, const void *seqStart, size_t seqSize, int nbSeq, const ZSTD_longOffset_e isLongOffset)</td></tr>
<tr class="separator:ac7ca65fd1b95822e8776fce6cec9b26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b6b44dd7030b2639b8a825d7f4971f"><td class="memItemLeft" align="right" valign="top"><a id="a42b6b44dd7030b2639b8a825d7f4971f"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t DONT_VECTORIZE&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressSequences_body</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t maxDstSize, const void *seqStart, size_t seqSize, int nbSeq, const ZSTD_longOffset_e isLongOffset)</td></tr>
<tr class="separator:a42b6b44dd7030b2639b8a825d7f4971f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162a85a434817b3aef5957654ef87d83"><td class="memItemLeft" align="right" valign="top"><a id="a162a85a434817b3aef5957654ef87d83"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_prefetchMatch</b> (size_t prefetchPos, <a class="el" href="structseq__t.html">seq_t</a> const sequence, const BYTE *const prefixStart, const BYTE *const dictEnd)</td></tr>
<tr class="separator:a162a85a434817b3aef5957654ef87d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c70cf3edb7534356de788255a3396c"><td class="memItemLeft" align="right" valign="top"><a id="a12c70cf3edb7534356de788255a3396c"></a>
<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZSTD_decompressSequencesLong_body</b> (<a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *dctx, void *dst, size_t maxDstSize, const void *seqStart, size_t seqSize, int nbSeq, const ZSTD_longOffset_e isLongOffset)</td></tr>
<tr class="separator:a12c70cf3edb7534356de788255a3396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705dc14081aec26178b8adf718a2e364"><td class="memItemLeft" align="right" valign="top">ZDICTLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a705dc14081aec26178b8adf718a2e364">ZDICT_trainFromBuffer</a> (void *dictBuffer, size_t dictBufferCapacity, const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples)</td></tr>
<tr class="separator:a705dc14081aec26178b8adf718a2e364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a23d9e733292199bfea09ad51ab5cc"><td class="memItemLeft" align="right" valign="top">ZDICTLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a46a23d9e733292199bfea09ad51ab5cc">ZDICT_finalizeDictionary</a> (void *dstDictBuffer, size_t maxDictSize, const void *dictContent, size_t dictContentSize, const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples, <a class="el" href="structZDICT__params__t.html">ZDICT_params_t</a> parameters)</td></tr>
<tr class="separator:a46a23d9e733292199bfea09ad51ab5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7b7d6bba8f42da1ae3227017499dd5"><td class="memItemLeft" align="right" valign="top">ZDICTLIB_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a6d7b7d6bba8f42da1ae3227017499dd5">ZDICT_getDictID</a> (const void *dictBuffer, size_t dictSize)</td></tr>
<tr class="separator:a6d7b7d6bba8f42da1ae3227017499dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5960828863504a8b7268537b41508cf"><td class="memItemLeft" align="right" valign="top"><a id="af5960828863504a8b7268537b41508cf"></a>
ZDICTLIB_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_getDictHeaderSize</b> (const void *dictBuffer, size_t dictSize)</td></tr>
<tr class="separator:af5960828863504a8b7268537b41508cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca21ecd78156f040d6fd55754552ec5"><td class="memItemLeft" align="right" valign="top"><a id="aeca21ecd78156f040d6fd55754552ec5"></a>
ZDICTLIB_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_isError</b> (size_t errorCode)</td></tr>
<tr class="separator:aeca21ecd78156f040d6fd55754552ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66ff28d790ccf9e1106c1a7d4c99d26"><td class="memItemLeft" align="right" valign="top"><a id="ab66ff28d790ccf9e1106c1a7d4c99d26"></a>
ZDICTLIB_API const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_getErrorName</b> (size_t errorCode)</td></tr>
<tr class="separator:ab66ff28d790ccf9e1106c1a7d4c99d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbe22fd624699873d08d2e65671f38d"><td class="memItemLeft" align="right" valign="top">ZDICTLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a0bbe22fd624699873d08d2e65671f38d">ZDICT_trainFromBuffer_cover</a> (void *dictBuffer, size_t dictBufferCapacity, const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples, <a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a> parameters)</td></tr>
<tr class="separator:a0bbe22fd624699873d08d2e65671f38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406f163e4ae6882df80bb1977fd32faa"><td class="memItemLeft" align="right" valign="top">ZDICTLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a406f163e4ae6882df80bb1977fd32faa">ZDICT_optimizeTrainFromBuffer_cover</a> (void *dictBuffer, size_t dictBufferCapacity, const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples, <a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a> *parameters)</td></tr>
<tr class="separator:a406f163e4ae6882df80bb1977fd32faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63856626332ea4a30258e11723bdae06"><td class="memItemLeft" align="right" valign="top">ZDICTLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a63856626332ea4a30258e11723bdae06">ZDICT_trainFromBuffer_fastCover</a> (void *dictBuffer, size_t dictBufferCapacity, const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples, <a class="el" href="structZDICT__fastCover__params__t.html">ZDICT_fastCover_params_t</a> parameters)</td></tr>
<tr class="separator:a63856626332ea4a30258e11723bdae06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6697e8cd583f6dd13203747bac8784"><td class="memItemLeft" align="right" valign="top">ZDICTLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#afc6697e8cd583f6dd13203747bac8784">ZDICT_optimizeTrainFromBuffer_fastCover</a> (void *dictBuffer, size_t dictBufferCapacity, const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples, <a class="el" href="structZDICT__fastCover__params__t.html">ZDICT_fastCover_params_t</a> *parameters)</td></tr>
<tr class="separator:afc6697e8cd583f6dd13203747bac8784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7b5f4ffc5627bac43f8675dc587ea4"><td class="memItemLeft" align="right" valign="top">ZDICTLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1b7b5f4ffc5627bac43f8675dc587ea4">ZDICT_trainFromBuffer_legacy</a> (void *dictBuffer, size_t dictBufferCapacity, const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples, <a class="el" href="structZDICT__legacy__params__t.html">ZDICT_legacy_params_t</a> parameters)</td></tr>
<tr class="separator:a1b7b5f4ffc5627bac43f8675dc587ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1110679aae05b9611674bc827497e1"><td class="memItemLeft" align="right" valign="top"><a id="add1110679aae05b9611674bc827497e1"></a>
ZDICTLIB_STATIC_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ZDICT_addEntropyTablesFromBuffer</b> (void *dictBuffer, size_t dictContentSize, size_t dictBufferCapacity, const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples)</td></tr>
<tr class="separator:add1110679aae05b9611674bc827497e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e20e2a51007d245a12b3cdff905ef6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOVER__epoch__info__t.html">COVER_epoch_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a2e20e2a51007d245a12b3cdff905ef6a">COVER_computeEpochs</a> (U32 maxDictSize, U32 nbDmers, U32 k, U32 passes)</td></tr>
<tr class="separator:a2e20e2a51007d245a12b3cdff905ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418b0fa9785bd766c31ae41e34ce3ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a418b0fa9785bd766c31ae41e34ce3ebe">COVER_warnOnSmallCorpus</a> (size_t maxDictSize, size_t nbDmers, int displayLevel)</td></tr>
<tr class="separator:a418b0fa9785bd766c31ae41e34ce3ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac36c878428b22365706e321184fa3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7aac36c878428b22365706e321184fa3">COVER_checkTotalCompressedSize</a> (const <a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a> parameters, const size_t *samplesSizes, const BYTE *samples, size_t *offsets, size_t nbTrainSamples, size_t nbSamples, BYTE *const dict, size_t dictBufferCapacity)</td></tr>
<tr class="separator:a7aac36c878428b22365706e321184fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d08abe6ce8f3b3af95b93193b46524f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a8d08abe6ce8f3b3af95b93193b46524f">COVER_sum</a> (const size_t *samplesSizes, unsigned nbSamples)</td></tr>
<tr class="separator:a8d08abe6ce8f3b3af95b93193b46524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e0964587f6d04e93bd019b9cfc6d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad0e0964587f6d04e93bd019b9cfc6d4e">COVER_best_init</a> (<a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *best)</td></tr>
<tr class="separator:ad0e0964587f6d04e93bd019b9cfc6d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc9631879075e9bc967691e50d591d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7fc9631879075e9bc967691e50d591d9">COVER_best_wait</a> (<a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *best)</td></tr>
<tr class="separator:a7fc9631879075e9bc967691e50d591d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb56a3f59a5490db6fa1b9641d1bbc92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#afb56a3f59a5490db6fa1b9641d1bbc92">COVER_best_destroy</a> (<a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *best)</td></tr>
<tr class="separator:afb56a3f59a5490db6fa1b9641d1bbc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96921521d4c290f9f3b76100f9e4b8aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a96921521d4c290f9f3b76100f9e4b8aa">COVER_best_start</a> (<a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *best)</td></tr>
<tr class="separator:a96921521d4c290f9f3b76100f9e4b8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4495a68384f7dcbb049f9880e417bcd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4495a68384f7dcbb049f9880e417bcd9">COVER_best_finish</a> (<a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *best, <a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a> parameters, <a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a> selection)</td></tr>
<tr class="separator:a4495a68384f7dcbb049f9880e417bcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a65ca984f14545558e223f36996497"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a80a65ca984f14545558e223f36996497">COVER_dictSelectionIsError</a> (<a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a> selection)</td></tr>
<tr class="separator:a80a65ca984f14545558e223f36996497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc2ca47eb799aa732a25920b6a89ed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a1bc2ca47eb799aa732a25920b6a89ed5">COVER_dictSelectionError</a> (size_t error)</td></tr>
<tr class="separator:a1bc2ca47eb799aa732a25920b6a89ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfba6966b1c889991b9e5f4b1f0b5d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a7cfba6966b1c889991b9e5f4b1f0b5d6">COVER_dictSelectionFree</a> (<a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a> selection)</td></tr>
<tr class="separator:a7cfba6966b1c889991b9e5f4b1f0b5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0260694c85528f03932ba1d9c96b23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#a4a0260694c85528f03932ba1d9c96b23">COVER_selectDict</a> (BYTE *customDictContent, size_t dictBufferCapacity, size_t dictContentSize, const BYTE *samplesBuffer, const size_t *samplesSizes, unsigned nbFinalizeSamples, size_t nbCheckSamples, size_t nbSamples, <a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a> params, size_t *offsets, size_t totalCompressedSize)</td></tr>
<tr class="separator:a4a0260694c85528f03932ba1d9c96b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad018c2c1a45780704e06793a6533355d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#ad018c2c1a45780704e06793a6533355d">divsufsort</a> (const unsigned char *T, int *SA, int n, int openMP)</td></tr>
<tr class="separator:ad018c2c1a45780704e06793a6533355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed979b095573f0ec58f304d169de5ce9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zstd_8c.html#aed979b095573f0ec58f304d169de5ce9">divbwt</a> (const unsigned char *T, unsigned char *U, int *A, int n, unsigned char *num_indexes, int *indexes, int openMP)</td></tr>
<tr class="separator:aed979b095573f0ec58f304d169de5ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8b7ab55e651ade37be93258633e1df18"><td class="memItemLeft" align="right" valign="top"><a id="a8b7ab55e651ade37be93258633e1df18"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>g_debuglevel</b> = DEBUGLEVEL</td></tr>
<tr class="separator:a8b7ab55e651ade37be93258633e1df18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4c6e161112815a16d1154fe935399b"><td class="memItemLeft" align="right" valign="top"><a id="a7f4c6e161112815a16d1154fe935399b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>g_ZSTD_threading_useless_symbol</b></td></tr>
<tr class="separator:a7f4c6e161112815a16d1154fe935399b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5020905455674b8c83c1dbc73f0d3534"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_errorcode</b></td></tr>
<tr class="separator:ga5020905455674b8c83c1dbc73f0d3534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e6127b51e114eb1f745a89f2702a473"><td class="memItemLeft" align="right" valign="top">
typedef XXH64_hash_t&#160;</td><td class="memItemRight" valign="bottom"><b>xxh_u64</b></td></tr>
<tr class="separator:ga7e6127b51e114eb1f745a89f2702a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7828b4ef2238269aa530beaebecffc69"><td class="memItemLeft" align="right" valign="top">
XXH_FORCE_INLINE xxh_u64&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_readLE64</b> (const void *ptr)</td></tr>
<tr class="separator:ga7828b4ef2238269aa530beaebecffc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d225972687c3d087ffcceb116e856d"><td class="memItemLeft" align="right" valign="top">
XXH_FORCE_INLINE xxh_u64&#160;</td><td class="memItemRight" valign="bottom"><b>XXH_readLE64_align</b> (const void *ptr, <a class="el" href="group__impl.html#gadec56fccd4f83e34902b6b09ecccfff5">XXH_alignment</a> align)</td></tr>
<tr class="separator:ga58d225972687c3d087ffcceb116e856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Single-file Zstandard library.</p>
<p>Generate using: </p><div class="fragment"><div class="line">python combine.py -r ../../lib -x legacy/zstd_legacy.h -o zstd.c zstd-in.c</div>
</div><!-- fragment --> </div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a54d2d7742701f3f112afbcd8d4f9ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d2d7742701f3f112afbcd8d4f9ccdb">&#9670;&nbsp;</a></span>__has_attribute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __has_attribute</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This header file contains macro definitions to support portability. This header is shared between C and ASM code, so it MUST only contain macro definitions. It MUST not contain any C code.</p>
<p>This header ONLY defines macros to detect platforms/feature support. </p>

</div>
</div>
<a id="aebc6aaeda475e2edd35a7c63f93b14f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc6aaeda475e2edd35a7c63f93b14f5">&#9670;&nbsp;</a></span>_FORCE_HAS_FORMAT_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FORCE_HAS_FORMAT_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                           \</div>
<div class="line">        if (0) {                                   \</div>
<div class="line">            _force_has_format_string(__VA_ARGS__); \</div>
<div class="line">        }                                          \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Ignore: this is an internal helper.</p>
<p>We want to force this function invocation to be syntactically correct, but we don't want to force runtime evaluation of its arguments. </p>

</div>
</div>
<a id="ae75e8172629eccb14017b40ee1591de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75e8172629eccb14017b40ee1591de8">&#9670;&nbsp;</a></span>BOUNDCHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOUNDCHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cParam, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                              \</div>
<div class="line">        RETURN_ERROR_IF(!ZSTD_cParam_withinBounds(cParam,val),        \</div>
<div class="line">                        parameter_outOfBound, <span class="stringliteral">&quot;Param out of bounds&quot;</span>); \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1fa81cb2c87554acff0e8913b29598f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa81cb2c87554acff0e8913b29598f5">&#9670;&nbsp;</a></span>CHECK_DBOUNDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_DBOUNDS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                \</div>
<div class="line">    RETURN_ERROR_IF(!ZSTD_dParam_withinBounds(p, v), parameter_outOfBound, <span class="stringliteral">&quot;&quot;</span>); \</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b01d485e392c08dde3559f5d5b95b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b01d485e392c08dde3559f5d5b95b7c">&#9670;&nbsp;</a></span>CHECK_V_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_V_F</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordtype">size_t</span> <span class="keyword">const</span> e = f;     \</div>
<div class="line">    do {                    \</div>
<div class="line">        if (ERR_isError(e)) \</div>
<div class="line">            return e;       \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f63459ca3ad3b8e45155fc272d19c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f63459ca3ad3b8e45155fc272d19c3b">&#9670;&nbsp;</a></span>CLAMP_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLAMP_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cParam, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">do</span> {                                                                  \</div>
<div class="line">            ZSTD_bounds <span class="keyword">const</span> bounds = <a class="code" href="zstd_8c.html#af34c6f9ee170db29838a57968716e28a">ZSTD_cParam_getBounds</a>(cParam);         \</div>
<div class="line">            if ((<span class="keywordtype">int</span>)val&lt;bounds.lowerBound) val=(type)bounds.lowerBound;      \</div>
<div class="line">            else if ((<span class="keywordtype">int</span>)val&gt;bounds.upperBound) val=(type)bounds.upperBound; \</div>
<div class="line">        } while (0)</div>
<div class="ttc" id="azstd_8c_html_af34c6f9ee170db29838a57968716e28a"><div class="ttname"><a href="zstd_8c.html#af34c6f9ee170db29838a57968716e28a">ZSTD_cParam_getBounds</a></div><div class="ttdeci">ZSTDLIB_API ZSTD_bounds ZSTD_cParam_getBounds(ZSTD_cParameter cParam)</div><div class="ttdef"><b>Definition:</b> zstd.c:23411</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8ef013382bb52ccf53195231c5f5383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ef013382bb52ccf53195231c5f5383">&#9670;&nbsp;</a></span>COVER_MAX_SAMPLES_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COVER_MAX_SAMPLES_SIZE&#160;&#160;&#160;(sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 GB))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There are 32bit indexes used to ref samples, so limit samples size to 4GB on 64bit builds. For 32bit builds we choose 1 GB. Most 32bit platforms have 2GB user-mode addressable space and we allocate a large contiguous buffer, so 1GB is already a high limit. </p>

</div>
</div>
<a id="aea2fba659546f9d0a7e51d2ca3370904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2fba659546f9d0a7e51d2ca3370904">&#9670;&nbsp;</a></span>DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                    3  <span class="comment">/* These two constants represent SIZE_MULT/COUNT_MULT load factor without using a float.</span></div>
<div class="line"><span class="comment">                                                    * Currently, that means a 0.75 load factor.</span></div>
<div class="line"><span class="comment">                                                    * So, if count * COUNT_MULT / size * SIZE_MULT != 0, then we&#39;ve exceeded</span></div>
<div class="line"><span class="comment">                                                    * the load factor of the ddict hash set.</span></div>
<div class="line"><span class="comment">                                                    */</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a5fbd7a78051c2134b21324e5c74bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5fbd7a78051c2134b21324e5c74bdc">&#9670;&nbsp;</a></span>DISPLAY <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  {                                                                            \</div>
<div class="line">    fprintf(stderr, __VA_ARGS__);                                              \</div>
<div class="line">    fflush(stderr);                                                            \</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a5fbd7a78051c2134b21324e5c74bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5fbd7a78051c2134b21324e5c74bdc">&#9670;&nbsp;</a></span>DISPLAY <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  {                                                                            \</div>
<div class="line">    fprintf(stderr, __VA_ARGS__);                                              \</div>
<div class="line">    fflush(stderr);                                                            \</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9200da68a37a9ae33332f82599d00e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9200da68a37a9ae33332f82599d00e67">&#9670;&nbsp;</a></span>DISPLAYLEVEL <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAYLEVEL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (displayLevel &gt;= l) {                                                     \</div>
<div class="line">    DISPLAY(__VA_ARGS__);                                                      \</div>
<div class="line">  } <span class="comment">/* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9200da68a37a9ae33332f82599d00e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9200da68a37a9ae33332f82599d00e67">&#9670;&nbsp;</a></span>DISPLAYLEVEL <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAYLEVEL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (displayLevel &gt;= l) {                                                     \</div>
<div class="line">    DISPLAY(__VA_ARGS__);                                                      \</div>
<div class="line">  } <span class="comment">/* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a40fa793cc466bb4f03748de2352e8e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fa793cc466bb4f03748de2352e8e8c">&#9670;&nbsp;</a></span>DISPLAYUPDATE <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAYUPDATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">do</span> {                                                       \</div>
<div class="line">            if (notificationLevel&gt;=l) {                            \</div>
<div class="line">                if (ZDICT_clockSpan(displayClock) &gt; refreshRate) { \</div>
<div class="line">                    displayClock = clock();                        \</div>
<div class="line">                    DISPLAY(__VA_ARGS__);                          \</div>
<div class="line">                }                                                  \</div>
<div class="line">                if (notificationLevel&gt;=4) fflush(stderr);          \</div>
<div class="line">            }                                                      \</div>
<div class="line">        } while (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0582ae4feec24e372a1a42811e4bfd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0582ae4feec24e372a1a42811e4bfd97">&#9670;&nbsp;</a></span>DISPLAYUPDATE <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAYUPDATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lastUpdateTime, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (displayLevel &gt;= l) {                                                     \</div>
<div class="line">    const clock_t refreshRate = CLOCKS_PER_SEC * 15 / 100;                     \</div>
<div class="line">    if ((clock() - lastUpdateTime &gt; refreshRate) || (displayLevel &gt;= 4)) {     \</div>
<div class="line">      lastUpdateTime = clock();                                                \</div>
<div class="line">      DISPLAY(__VA_ARGS__);                                                    \</div>
<div class="line">    }                                                                          \</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0582ae4feec24e372a1a42811e4bfd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0582ae4feec24e372a1a42811e4bfd97">&#9670;&nbsp;</a></span>DISPLAYUPDATE <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAYUPDATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lastUpdateTime, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (displayLevel &gt;= l) {                                                     \</div>
<div class="line">    const clock_t refreshRate = CLOCKS_PER_SEC * 15 / 100;                     \</div>
<div class="line">    if ((clock() - lastUpdateTime &gt; refreshRate) || (displayLevel &gt;= 4)) {     \</div>
<div class="line">      lastUpdateTime = clock();                                                \</div>
<div class="line">      DISPLAY(__VA_ARGS__);                                                    \</div>
<div class="line">    }                                                                          \</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9636f8b85954a677e9e429f9ba90f21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9636f8b85954a677e9e429f9ba90f21a">&#9670;&nbsp;</a></span>FASTCOVER_MAX_SAMPLES_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FASTCOVER_MAX_SAMPLES_SIZE&#160;&#160;&#160;(sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 GB))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There are 32bit indexes used to ref samples, so limit samples size to 4GB on 64bit builds. For 32bit builds we choose 1 GB. Most 32bit platforms have 2GB user-mode addressable space and we allocate a large contiguous buffer, so 1GB is already a high limit. </p>

</div>
</div>
<a id="abf752dd6259117e6d4da3b8b1fb13aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf752dd6259117e6d4da3b8b1fb13aaf">&#9670;&nbsp;</a></span>FORCE_INLINE_TEMPLATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FORCE_INLINE_TEMPLATE&#160;&#160;&#160;static INLINE_KEYWORD FORCE_INLINE_ATTR UNUSED_ATTR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FORCE_INLINE_TEMPLATE is used to define C "templates", which take constant parameters. They must be inlined for the compiler to eliminate the constant branches. </p>

</div>
</div>
<a id="a3ee8764705277539a9c911cfb62dd077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee8764705277539a9c911cfb62dd077">&#9670;&nbsp;</a></span>FORWARD_IF_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FORWARD_IF_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">err, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                                           \</div>
<div class="line">        size_t <span class="keyword">const</span> err_code = (err);                                             \</div>
<div class="line">        if (ERR_isError(err_code)) {                                               \</div>
<div class="line">            RAWLOG(3, <span class="stringliteral">&quot;%s:%d: ERROR!: forwarding error in %s: %s&quot;</span>,                 \</div>
<div class="line">                  __FILE__, __LINE__, ERR_QUOTE(err), ERR_getErrorName(err_code)); \</div>
<div class="line">            _FORCE_HAS_FORMAT_STRING(__VA_ARGS__);                                 \</div>
<div class="line">            RAWLOG(3, <span class="stringliteral">&quot;: &quot;</span> __VA_ARGS__);                                           \</div>
<div class="line">            RAWLOG(3, <span class="stringliteral">&quot;\n&quot;</span>);                                                       \</div>
<div class="line">            return err_code;                                                       \</div>
<div class="line">        }                                                                          \</div>
<div class="line">    } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment --><p>If the provided expression evaluates to an error code, returns that error code.</p>
<p>In debug modes, prints additional information. </p>

</div>
</div>
<a id="a7e8a6c61f28b45d06a787bc1627e994c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8a6c61f28b45d06a787bc1627e994c">&#9670;&nbsp;</a></span>FSE_H_FSE_STATIC_LINKING_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSE_H_FSE_STATIC_LINKING_ONLY</td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md6"></a>
Tutorial :</h2>
<p>(Note : these functions only decompress FSE-compressed blocks. If block is uncompressed, use memcpy() instead If block is a single repeated byte, use memset() instead )</p>
<p>The first step is to obtain the normalized frequencies of symbols. This can be performed by <a class="el" href="zstd_8c.html#af0aa1674b1444911966d291da574d5f0">FSE_readNCount()</a> if it was saved using <a class="el" href="zstd_8c.html#ada665be956caa74b8624b7042d289c61">FSE_writeNCount()</a>. 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValuePtr[0]+1' cells of signed short. In practice, that means it's necessary to know 'maxSymbolValue' beforehand, or size the table to handle worst case situations (typically 256). <a class="el" href="zstd_8c.html#af0aa1674b1444911966d291da574d5f0">FSE_readNCount()</a> will provide 'tableLog' and 'maxSymbolValue'. The result of <a class="el" href="zstd_8c.html#af0aa1674b1444911966d291da574d5f0">FSE_readNCount()</a> is the number of bytes read from 'rBuffer'. Note that 'rBufferSize' must be at least 4 bytes, even if useful information is less than that. If there is an error, the function will return an error code, which can be tested using FSE_isError().</p>
<p>The next step is to build the decompression tables 'FSE_DTable' from 'normalizedCounter'. This is performed by the function FSE_buildDTable(). The space required by 'FSE_DTable' must be already allocated using FSE_createDTable(). If there is an error, the function will return an error code, which can be tested using FSE_isError().</p>
<p><code>FSE_DTable</code> can then be used to decompress <code>cSrc</code>, with FSE_decompress_usingDTable(). <code>cSrcSize</code> must be strictly correct, otherwise decompression will fail. FSE_decompress_usingDTable() result will tell how many bytes were regenerated (&lt;=<code>dstCapacity</code>). If there is an error, the function will return an error code, which can be tested using FSE_isError(). (ex: dst buffer too small) </p>

</div>
</div>
<a id="a56ccde461aac2d6c8dbcc17959d9618e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ccde461aac2d6c8dbcc17959d9618e">&#9670;&nbsp;</a></span>FSE_MAX_MEMORY_USAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSE_MAX_MEMORY_USAGE&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MEMORY_USAGE : Memory usage formula : N-&gt;2^N Bytes (examples : 10 -&gt; 1KB; 12 -&gt; 4KB ; 16 -&gt; 64KB; 20 -&gt; 1MB; etc.) Increasing memory usage improves compression ratio Reduced memory usage can improve speed, due to cache effect Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache </p>

</div>
</div>
<a id="a1588af42cea714b4f3ec46d40da716c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1588af42cea714b4f3ec46d40da716c5">&#9670;&nbsp;</a></span>FSE_MAX_SYMBOL_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSE_MAX_SYMBOL_VALUE&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSE_MAX_SYMBOL_VALUE : Maximum symbol value authorized. Required for proper stack allocation </p>

</div>
</div>
<a id="a56509bc2b926bcbb48d979a907650957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56509bc2b926bcbb48d979a907650957">&#9670;&nbsp;</a></span>GEAR_ITER_ONCE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEAR_ITER_ONCE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">do</span> {                                  \</div>
<div class="line">        hash = (hash &lt;&lt; 1) + ZSTD_ldm_gearTab[data[n] &amp; 0xff]; \</div>
<div class="line">        n += 1;                                                \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a56509bc2b926bcbb48d979a907650957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56509bc2b926bcbb48d979a907650957">&#9670;&nbsp;</a></span>GEAR_ITER_ONCE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEAR_ITER_ONCE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">do</span> { \</div>
<div class="line">        hash = (hash &lt;&lt; 1) + ZSTD_ldm_gearTab[data[n] &amp; 0xff]; \</div>
<div class="line">        n += 1; \</div>
<div class="line">        if (UNLIKELY((hash &amp; mask) == 0)) { \</div>
<div class="line">            splits[*numSplits] = n; \</div>
<div class="line">            *numSplits += 1; \</div>
<div class="line">            if (*numSplits == LDM_BATCH_SIZE) \</div>
<div class="line">                goto done; \</div>
<div class="line">        } \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a64dd07beaddf4da6a68495d676a653d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dd07beaddf4da6a68495d676a653d4">&#9670;&nbsp;</a></span>GEN_ZSTD_BT_GET_ALL_MATCHES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_ZSTD_BT_GET_ALL_MATCHES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 3)  \</div>
<div class="line">    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 4)  \</div>
<div class="line">    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 5)  \</div>
<div class="line">    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 6)</div>
</div><!-- fragment -->
</div>
</div>
<a id="afc439e25ecfa944daf03ede7de7625b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc439e25ecfa944daf03ede7de7625b2">&#9670;&nbsp;</a></span>GEN_ZSTD_BT_GET_ALL_MATCHES_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_ZSTD_BT_GET_ALL_MATCHES_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> U32 ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, mls)(      \</div>
<div class="line">            ZSTD_match_t* matches,                             \</div>
<div class="line">            ZSTD_MatchState_t* ms,                             \</div>
<div class="line">            U32* nextToUpdate3,                                \</div>
<div class="line">            const BYTE* ip,                                    \</div>
<div class="line">            const BYTE* <span class="keyword">const</span> iHighLimit,                      \</div>
<div class="line">            const U32 rep[ZSTD_REP_NUM],                       \</div>
<div class="line">            U32 <span class="keyword">const</span> ll0,                                     \</div>
<div class="line">            U32 <span class="keyword">const</span> lengthToBeat)                            \</div>
<div class="line">    {                                                          \</div>
<div class="line">        return ZSTD_btGetAllMatches_internal(                  \</div>
<div class="line">                matches, ms, nextToUpdate3, ip, iHighLimit,    \</div>
<div class="line">                rep, ll0, lengthToBeat, ZSTD_##dictMode, mls); \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aacd76372f399f4a6603fe707ed1921be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd76372f399f4a6603fe707ed1921be">&#9670;&nbsp;</a></span>GEN_ZSTD_BT_SEARCH_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_ZSTD_BT_SEARCH_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ZSTD_SEARCH_FN_ATTRS <span class="keywordtype">size_t</span> <a class="code" href="zstd_8c.html#abc9888c297ee0ceeddd300eed6430b69">ZSTD_BT_SEARCH_FN</a>(dictMode, mls)(                      \</div>
<div class="line">            ZSTD_MatchState_t* ms,                                                     \</div>
<div class="line">            const BYTE* ip, <span class="keyword">const</span> BYTE* <span class="keyword">const</span> iLimit,                                  \</div>
<div class="line">            size_t* offBasePtr)                                                        \</div>
<div class="line">    {                                                                                  \</div>
<div class="line">        assert(MAX(4, MIN(6, ms-&gt;cParams.minMatch)) == mls);                           \</div>
<div class="line">        return <a class="code" href="zstd_8c.html#afd10da54840c09ebe9e65c70abf28bd5">ZSTD_BtFindBestMatch</a>(ms, ip, iLimit, offBasePtr, mls, ZSTD_##dictMode); \</div>
<div class="line">    }                                                                                  \</div>
<div class="ttc" id="azstd_8c_html_abc9888c297ee0ceeddd300eed6430b69"><div class="ttname"><a href="zstd_8c.html#abc9888c297ee0ceeddd300eed6430b69">ZSTD_BT_SEARCH_FN</a></div><div class="ttdeci">#define ZSTD_BT_SEARCH_FN(dictMode, mls)</div><div class="ttdef"><b>Definition:</b> zstd.c:34098</div></div>
<div class="ttc" id="azstd_8c_html_afd10da54840c09ebe9e65c70abf28bd5"><div class="ttname"><a href="zstd_8c.html#afd10da54840c09ebe9e65c70abf28bd5">ZSTD_BtFindBestMatch</a></div><div class="ttdeci">FORCE_INLINE_TEMPLATE ZSTD_ALLOW_POINTER_OVERFLOW_ATTR size_t ZSTD_BtFindBestMatch(ZSTD_MatchState_t *ms, const BYTE *const ip, const BYTE *const iLimit, size_t *offBasePtr, const U32 mls, const ZSTD_dictMode_e dictMode)</div><div class="ttdef"><b>Definition:</b> zstd.c:33134</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8578ad4a4640571697ce81565f288b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8578ad4a4640571697ce81565f288b5d">&#9670;&nbsp;</a></span>GEN_ZSTD_CALL_BT_SEARCH_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_ZSTD_CALL_BT_SEARCH_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">case</span> mls:                                                             \</div>
<div class="line">        return <a class="code" href="zstd_8c.html#abc9888c297ee0ceeddd300eed6430b69">ZSTD_BT_SEARCH_FN</a>(dictMode, mls)(ms, ip, iend, offsetPtr);</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e1fae60a5508aa31711503852639ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1fae60a5508aa31711503852639ae6">&#9670;&nbsp;</a></span>GEN_ZSTD_CALL_HC_SEARCH_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_ZSTD_CALL_HC_SEARCH_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">case</span> mls:                                                             \</div>
<div class="line">        return ZSTD_HC_SEARCH_FN(dictMode, mls)(ms, ip, iend, offsetPtr);</div>
</div><!-- fragment -->
</div>
</div>
<a id="a87ca772638f5266abbaadeaa52cdf14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ca772638f5266abbaadeaa52cdf14e">&#9670;&nbsp;</a></span>GEN_ZSTD_CALL_ROW_SEARCH_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_ZSTD_CALL_ROW_SEARCH_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rowLog&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">case</span> rowLog:                                                                   \</div>
<div class="line">        return ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog)(ms, ip, iend, offsetPtr);</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c25f76269d2654d626342e04c833b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c25f76269d2654d626342e04c833b26">&#9670;&nbsp;</a></span>GEN_ZSTD_HC_SEARCH_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_ZSTD_HC_SEARCH_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ZSTD_SEARCH_FN_ATTRS <span class="keywordtype">size_t</span> ZSTD_HC_SEARCH_FN(dictMode, mls)(                     \</div>
<div class="line">            ZSTD_MatchState_t* ms,                                                    \</div>
<div class="line">            const BYTE* ip, <span class="keyword">const</span> BYTE* <span class="keyword">const</span> iLimit,                                 \</div>
<div class="line">            size_t* offsetPtr)                                                        \</div>
<div class="line">    {                                                                                 \</div>
<div class="line">        assert(MAX(4, MIN(6, ms-&gt;cParams.minMatch)) == mls);                          \</div>
<div class="line">        return ZSTD_HcFindBestMatch(ms, ip, iLimit, offsetPtr, mls, ZSTD_##dictMode); \</div>
<div class="line">    }                                                                                 \</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3a6a0e7f4b947848c6c66fb93665204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a6a0e7f4b947848c6c66fb93665204">&#9670;&nbsp;</a></span>GEN_ZSTD_ROW_SEARCH_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_ZSTD_ROW_SEARCH_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rowLog&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ZSTD_SEARCH_FN_ATTRS <span class="keywordtype">size_t</span> ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog)(                     \</div>
<div class="line">            ZSTD_MatchState_t* ms,                                                             \</div>
<div class="line">            const BYTE* ip, <span class="keyword">const</span> BYTE* <span class="keyword">const</span> iLimit,                                          \</div>
<div class="line">            size_t* offsetPtr)                                                                 \</div>
<div class="line">    {                                                                                          \</div>
<div class="line">        assert(MAX(4, MIN(6, ms-&gt;cParams.minMatch)) == mls);                                   \</div>
<div class="line">        assert(MAX(4, MIN(6, ms-&gt;cParams.searchLog)) == rowLog);                               \</div>
<div class="line">        return ZSTD_RowFindBestMatch(ms, ip, iLimit, offsetPtr, mls, ZSTD_##dictMode, rowLog); \</div>
<div class="line">    }                                                                                          \</div>
</div><!-- fragment -->
</div>
</div>
<a id="a18e6fde6004400522b2ff1da3c080363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e6fde6004400522b2ff1da3c080363">&#9670;&nbsp;</a></span>HINT_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HINT_INLINE&#160;&#160;&#160;<a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HINT_INLINE is used to help the compiler generate better code. It is <em>not</em> used for "templates", so it can be tweaked based on the compilers performance.</p>
<p>gcc-4.8 and gcc-4.9 have been shown to benefit from leaving off the always_inline attribute.</p>
<p>clang up to 5.0.0 (trunk) benefit tremendously from the always_inline attribute. </p>

</div>
</div>
<a id="ac3fc7098e3af2259340c4b3aba021311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fc7098e3af2259340c4b3aba021311">&#9670;&nbsp;</a></span>HUF_4X1_DECODE_SYMBOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_4X1_DECODE_SYMBOL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_stream, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_symbol&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                        \</div>
<div class="line">        int <span class="keyword">const</span> index = (int)(bits[(_stream)] &gt;&gt; 53);         \</div>
<div class="line">        int <span class="keyword">const</span> entry = (int)dtable[index];                   \</div>
<div class="line">        bits[(_stream)] &lt;&lt;= (entry &amp; 0x3F);                     \</div>
<div class="line">        op[(_stream)][(_symbol)] = (BYTE)((entry &gt;&gt; 8) &amp; 0xFF); \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e23f0dcb7ee25c87df681de6cf77fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e23f0dcb7ee25c87df681de6cf77fbb">&#9670;&nbsp;</a></span>HUF_4X1_RELOAD_STREAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_4X1_RELOAD_STREAM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_stream</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                            \</div>
<div class="line">        int <span class="keyword">const</span> ctz = ZSTD_countTrailingZeros64(bits[(_stream)]); \</div>
<div class="line">        int <span class="keyword">const</span> nbBits = ctz &amp; 7;                                 \</div>
<div class="line">        int <span class="keyword">const</span> nbBytes = ctz &gt;&gt; 3;                               \</div>
<div class="line">        op[(_stream)] += 5;                                         \</div>
<div class="line">        ip[(_stream)] -= nbBytes;                                   \</div>
<div class="line">        bits[(_stream)] = MEM_read64(ip[(_stream)]) | 1;            \</div>
<div class="line">        bits[(_stream)] &lt;&lt;= nbBits;                                 \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6b29630c73a36ed0e5dea387e52ae1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b29630c73a36ed0e5dea387e52ae1b5">&#9670;&nbsp;</a></span>HUF_4X2_DECODE_SYMBOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_4X2_DECODE_SYMBOL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_stream, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_decode3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                              \</div>
<div class="line">        if ((_decode3) || (_stream) != 3) {                           \</div>
<div class="line">            int <span class="keyword">const</span> index = (int)(bits[(_stream)] &gt;&gt; 53);           \</div>
<div class="line">            HUF_DEltX2 <span class="keyword">const</span> entry = dtable[index];                   \</div>
<div class="line">            MEM_write16(op[(_stream)], entry.sequence); \</div>
<div class="line">            bits[(_stream)] &lt;&lt;= (entry.nbBits) &amp; 0x3F;                \</div>
<div class="line">            op[(_stream)] += (entry.length);                          \</div>
<div class="line">        }                                                             \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="afd6ea1f358be924204b8467b5fbc9548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6ea1f358be924204b8467b5fbc9548">&#9670;&nbsp;</a></span>HUF_4X2_RELOAD_STREAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_4X2_RELOAD_STREAM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_stream</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                                \</div>
<div class="line">        HUF_4X2_DECODE_SYMBOL(3, 1);                                    \</div>
<div class="line">        {                                                               \</div>
<div class="line">            int <span class="keyword">const</span> ctz = ZSTD_countTrailingZeros64(bits[(_stream)]); \</div>
<div class="line">            int <span class="keyword">const</span> nbBits = ctz &amp; 7;                                 \</div>
<div class="line">            int <span class="keyword">const</span> nbBytes = ctz &gt;&gt; 3;                               \</div>
<div class="line">            ip[(_stream)] -= nbBytes;                                   \</div>
<div class="line">            bits[(_stream)] = MEM_read64(ip[(_stream)]) | 1;            \</div>
<div class="line">            bits[(_stream)] &lt;&lt;= nbBits;                                 \</div>
<div class="line">        }                                                               \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="af6ab687170c52a99e46c97eb4146716e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ab687170c52a99e46c97eb4146716e">&#9670;&nbsp;</a></span>HUF_4X_FOR_EACH_STREAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_4X_FOR_EACH_STREAM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                          \</div>
<div class="line">        X(0);                     \</div>
<div class="line">        X(1);                     \</div>
<div class="line">        X(2);                     \</div>
<div class="line">        X(3);                     \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a14031e18cb0e5db79b926c5496ea3e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14031e18cb0e5db79b926c5496ea3e54">&#9670;&nbsp;</a></span>HUF_4X_FOR_EACH_STREAM_WITH_VAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_4X_FOR_EACH_STREAM_WITH_VAR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                        \</div>
<div class="line">        X(0, (var));                            \</div>
<div class="line">        X(1, (var));                            \</div>
<div class="line">        X(2, (var));                            \</div>
<div class="line">        X(3, (var));                            \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a10c1df14592ff8c16117056ae21c9e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c1df14592ff8c16117056ae21c9e10">&#9670;&nbsp;</a></span>HUF_BITS_IN_CONTAINER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_BITS_IN_CONTAINER&#160;&#160;&#160;(sizeof(size_t) * 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a>: Huffman uses its own <a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> implementation. There are three major differences from <a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a>:</p><ol type="1">
<li><a class="el" href="zstd_8c.html#abd3ef7f6d6f019c23b27a79c73118850">HUF_addBits()</a> takes a HUF_CElt (size_t) which is the pair (nbBits, value) in the format: format:<ul>
<li>Bits [0, 4) = nbBits</li>
<li>Bits [4, 64 - nbBits) = 0</li>
<li>Bits [64 - nbBits, 64) = value</li>
</ul>
</li>
<li>The bitContainer is built from the upper bits and right shifted. E.g. to add a new value of N bits you right shift the bitContainer by N, then or in the new value into the N upper bits.</li>
<li>The bitstream has two bit containers. You can add bits to the second container and merge them into the first container. </li>
</ol>

</div>
</div>
<a id="a1a85a93e7aec3443f516c69bc9f41afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a85a93e7aec3443f516c69bc9f41afd">&#9670;&nbsp;</a></span>HUF_BLOCKSIZE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_BLOCKSIZE_MAX&#160;&#160;&#160;(128 * 1024)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum input size for a single block compressed with HUF_compress </p>

</div>
</div>
<a id="a2783725221941583eda32cb70a03660f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2783725221941583eda32cb70a03660f">&#9670;&nbsp;</a></span>HUF_CTABLE_WORKSPACE_SIZE_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_CTABLE_WORKSPACE_SIZE_U32&#160;&#160;&#160;((4 * (HUF_SYMBOLVALUE_MAX + 1)) + 192)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HUF_buildCTable_wksp() : Same as HUF_buildCTable(), but using externally allocated scratch buffer. <code>workSpace</code> must be aligned on 4-bytes boundaries, and its size must be &gt;= HUF_CTABLE_WORKSPACE_SIZE. </p>

</div>
</div>
<a id="ab3a54d650c2e417f7a6749b7d7d74bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a54d650c2e417f7a6749b7d7d74bad">&#9670;&nbsp;</a></span>HUF_DECODE_SYMBOLX1_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_DECODE_SYMBOLX1_1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DStreamPtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                            \</div>
<div class="line">        if (MEM_64bits() || (HUF_TABLELOG_MAX&lt;=12)) \</div>
<div class="line">            HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr); \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4e793a95f36aa83bb79ce55a8af38e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e793a95f36aa83bb79ce55a8af38e6">&#9670;&nbsp;</a></span>HUF_DECODE_SYMBOLX1_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_DECODE_SYMBOLX1_2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DStreamPtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                            \</div>
<div class="line">        if (MEM_64bits())                           \</div>
<div class="line">            HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr); \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15066482875cf0319e2e6bb3a40b8068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15066482875cf0319e2e6bb3a40b8068">&#9670;&nbsp;</a></span>HUF_DECODE_SYMBOLX2_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_DECODE_SYMBOLX2_1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DStreamPtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                           \</div>
<div class="line">        if (MEM_64bits() || (HUF_TABLELOG_MAX&lt;=12))                \</div>
<div class="line">            ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog); \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="acea95c215cac5c21be278fc548db6943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea95c215cac5c21be278fc548db6943">&#9670;&nbsp;</a></span>HUF_DECODE_SYMBOLX2_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_DECODE_SYMBOLX2_2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DStreamPtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                           \</div>
<div class="line">        if (MEM_64bits())                                          \</div>
<div class="line">            ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog); \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac05bbfb5cce4b283be29cf13ab060ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05bbfb5cce4b283be29cf13ab060ef1">&#9670;&nbsp;</a></span>HUF_DECOMPRESS_WORKSPACE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_DECOMPRESS_WORKSPACE_SIZE&#160;&#160;&#160;((2 &lt;&lt; 10) + (1 &lt;&lt; 9))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The minimum workspace size for the <code>workSpace</code> used in HUF_readDTableX1_wksp() and HUF_readDTableX2_wksp().</p>
<p>The space used depends on HUF_TABLELOG_MAX, ranging from ~1500 bytes when HUF_TABLE_LOG_MAX=12 to ~1850 bytes when HUF_TABLE_LOG_MAX=15. Buffer overflow errors may potentially occur if code modifications result in a required workspace size greater than that specified in the following macro. </p>

</div>
</div>
<a id="afd87bf8b42c4c3019dc2f7a791413324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd87bf8b42c4c3019dc2f7a791413324">&#9670;&nbsp;</a></span>HUF_DGEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_DGEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keywordtype">size_t</span> fn(<span class="keywordtype">void</span>* dst, <span class="keywordtype">size_t</span> dstSize, <span class="keywordtype">void</span> <span class="keyword">const</span>* cSrc,           \</div>
<div class="line">                     <span class="keywordtype">size_t</span> cSrcSize, HUF_DTable <span class="keyword">const</span>* DTable, <span class="keywordtype">int</span> flags)  \</div>
<div class="line">    {                                                                       \</div>
<div class="line">        (void)flags;                                                        \</div>
<div class="line">        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f9d85ed12f0835a94ca738bd83eb7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9d85ed12f0835a94ca738bd83eb7ea">&#9670;&nbsp;</a></span>HUF_READ_STATS_WORKSPACE_SIZE_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUF_READ_STATS_WORKSPACE_SIZE_U32&#160;&#160;&#160;FSE_DECOMPRESS_WKSP_SIZE_U32(6, HUF_TABLELOG_MAX-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HUF_readStats_wksp() : Same as <a class="el" href="zstd_8c.html#abe44467e2590965c0dafba8df4d206c0">HUF_readStats()</a> but takes an external workspace which must be 4-byte aligned and its size must be &gt;= HUF_READ_STATS_WORKSPACE_SIZE. If the CPU has BMI2 support, pass bmi2=1, otherwise pass bmi2=0. </p>

</div>
</div>
<a id="ab2c4c67a29e924ad5c996621dddd866e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c4c67a29e924ad5c996621dddd866e">&#9670;&nbsp;</a></span>JOB_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define JOB_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                            \</div>
<div class="line">        ZSTD_PTHREAD_MUTEX_LOCK(&amp;job-&gt;job_mutex);   \</div>
<div class="line">        job-&gt;cSize = e;                             \</div>
<div class="line">        ZSTD_pthread_mutex_unlock(&amp;job-&gt;job_mutex); \</div>
<div class="line">        goto _endJob;                               \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac9f15eba9f3c2667ddc4b2a5ce7782e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f15eba9f3c2667ddc4b2a5ce7782e4">&#9670;&nbsp;</a></span>LONG_OFFSETS_MAX_EXTRA_BITS_32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LONG_OFFSETS_MAX_EXTRA_BITS_32</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (ZSTD_WINDOWLOG_MAX_32 &gt; STREAM_ACCUMULATOR_MIN_32       \</div>
<div class="line">        ? ZSTD_WINDOWLOG_MAX_32 - STREAM_ACCUMULATOR_MIN_32  \</div>
<div class="line">        : 0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeafe38fb4cdd5d62b74e339bff6ea266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafe38fb4cdd5d62b74e339bff6ea266">&#9670;&nbsp;</a></span>MERGE_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MERGE_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {\</div>
<div class="line">    if(((c) &amp; 1) ||\</div>
<div class="line">       (((c) &amp; 2) &amp;&amp; (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\</div>
<div class="line">      *(a) = ~*(a);\</div>
<div class="line">    }\</div>
<div class="line">    if(((c) &amp; 4) &amp;&amp; ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\</div>
<div class="line">      *(b) = ~*(b);\</div>
<div class="line">    }\</div>
<div class="line">  } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a64cce918a4f05f32c0950e5b26283341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cce918a4f05f32c0950e5b26283341">&#9670;&nbsp;</a></span>PREFETCH_AREA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFETCH_AREA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                 \</div>
<div class="line">        const <span class="keywordtype">char</span>* <span class="keyword">const</span> _ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)(p);       \</div>
<div class="line">        size_t <span class="keyword">const</span> _size = (size_t)(s);                \</div>
<div class="line">        size_t _pos;                                     \</div>
<div class="line">        for (_pos=0; _pos&lt;_size; _pos+=CACHELINE_SIZE) { \</div>
<div class="line">            PREFETCH_L2(_ptr + _pos);                    \</div>
<div class="line">        }                                                \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2d4f39f1cb8d10dd9b7ea6ce7badaae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4f39f1cb8d10dd9b7ea6ce7badaae1">&#9670;&nbsp;</a></span>RETURN_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RETURN_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">err, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                                     \</div>
<div class="line">        RAWLOG(3, <span class="stringliteral">&quot;%s:%d: ERROR!: unconditional check failed, returning %s&quot;</span>, \</div>
<div class="line">              __FILE__, __LINE__, ERR_QUOTE(ERROR(err)));                    \</div>
<div class="line">        _FORCE_HAS_FORMAT_STRING(__VA_ARGS__);                               \</div>
<div class="line">        RAWLOG(3, <span class="stringliteral">&quot;: &quot;</span> __VA_ARGS__);                                         \</div>
<div class="line">        RAWLOG(3, <span class="stringliteral">&quot;\n&quot;</span>);                                                     \</div>
<div class="line">        return ERROR(err);                                                   \</div>
<div class="line">    } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment --><p>Unconditionally return the specified error.</p>
<p>In debug modes, prints additional information. </p>

</div>
</div>
<a id="a5d0783e849b3fc286fe720307a952d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0783e849b3fc286fe720307a952d26">&#9670;&nbsp;</a></span>RETURN_ERROR_IF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RETURN_ERROR_IF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">err, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">        if (cond) {                                                            \</div>
<div class="line">            RAWLOG(3, <span class="stringliteral">&quot;%s:%d: ERROR!: check %s failed, returning %s&quot;</span>,          \</div>
<div class="line">                  __FILE__, __LINE__, ERR_QUOTE(cond), ERR_QUOTE(ERROR(err))); \</div>
<div class="line">            _FORCE_HAS_FORMAT_STRING(__VA_ARGS__);                             \</div>
<div class="line">            RAWLOG(3, <span class="stringliteral">&quot;: &quot;</span> __VA_ARGS__);                                       \</div>
<div class="line">            RAWLOG(3, <span class="stringliteral">&quot;\n&quot;</span>);                                                   \</div>
<div class="line">            return ERROR(err);                                                 \</div>
<div class="line">        }                                                                      \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Return the specified error if the condition evaluates to true.</p>
<p>In debug modes, prints additional information. In order to do that (particularly, printing the conditional that failed), this can't just wrap <a class="el" href="zstd_8c.html#a2d4f39f1cb8d10dd9b7ea6ce7badaae1">RETURN_ERROR()</a>. </p>

</div>
</div>
<a id="a88f1ff1ac325c41f23cc15bef5422485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f1ff1ac325c41f23cc15bef5422485">&#9670;&nbsp;</a></span>STACK_POP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STACK_POP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_d&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {\</div>
<div class="line">    assert(0 &lt;= ssize);\</div>
<div class="line">    if(ssize == 0) { <span class="keywordflow">return</span>; }\</div>
<div class="line">    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\</div>
<div class="line">    (_c) = stack[ssize].c, (_d) = stack[ssize].d;\</div>
<div class="line">  } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a087bacc2e0ad4bbb8fe7dca57662fb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087bacc2e0ad4bbb8fe7dca57662fb5a">&#9670;&nbsp;</a></span>STACK_POP5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STACK_POP5</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {\</div>
<div class="line">    assert(0 &lt;= ssize);\</div>
<div class="line">    if(ssize == 0) { <span class="keywordflow">return</span>; }\</div>
<div class="line">    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\</div>
<div class="line">    (_c) = stack[ssize].c, (_d) = stack[ssize].d, (_e) = stack[ssize].e;\</div>
<div class="line">  } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad74e4c4355110af960d47f5f8fc180c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74e4c4355110af960d47f5f8fc180c3">&#9670;&nbsp;</a></span>STACK_PUSH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STACK_PUSH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_d&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {\</div>
<div class="line">    assert(ssize &lt; STACK_SIZE);\</div>
<div class="line">    stack[ssize].a = (_a), stack[ssize].b = (_b),\</div>
<div class="line">    stack[ssize].c = (_c), stack[ssize++].d = (_d);\</div>
<div class="line">  } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f8c46c22837b2f21a9b4781f81a88bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8c46c22837b2f21a9b4781f81a88bd">&#9670;&nbsp;</a></span>STACK_PUSH5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STACK_PUSH5</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {\</div>
<div class="line">    assert(ssize &lt; STACK_SIZE);\</div>
<div class="line">    stack[ssize].a = (_a), stack[ssize].b = (_b),\</div>
<div class="line">    stack[ssize].c = (_c), stack[ssize].d = (_d), stack[ssize++].e = (_e);\</div>
<div class="line">  } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a427eb005b5e84abd606bccd3e6c0352e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427eb005b5e84abd606bccd3e6c0352e">&#9670;&nbsp;</a></span>STARTNODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STARTNODE&#160;&#160;&#160;(HUF_SYMBOLVALUE_MAX+1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HUF_buildCTable_wksp() : Same as HUF_buildCTable(), but using externally allocated scratch buffer. <code>workSpace</code> must be aligned on 4-bytes boundaries, and be at least as large as sizeof(HUF_buildCTable_wksp_tables). </p>

</div>
</div>
<a id="a59007e7f6a8ca5cc9f01099593574800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59007e7f6a8ca5cc9f01099593574800">&#9670;&nbsp;</a></span>THREADING_H_938743</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREADING_H_938743</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copyright (c) 2016 Tino Reichardt All rights reserved.</p>
<p>You can contact the author at:</p><ul>
<li>zstdmt source repository: <a href="https://github.com/mcmilk/zstdmt">https://github.com/mcmilk/zstdmt</a></li>
</ul>
<p>This source code is licensed under both the BSD-style license (found in the LICENSE file in the root directory of this source tree) and the GPLv2 (found in the COPYING file in the root directory of this source tree). You may select, at your option, one of the above-listed licenses. This file will hold wrapper for systems, which do not support pthreads Copyright (c) 2016 Tino Reichardt All rights reserved.</p>
<p>You can contact the author at:</p><ul>
<li>zstdmt source repository: <a href="https://github.com/mcmilk/zstdmt">https://github.com/mcmilk/zstdmt</a></li>
</ul>
<p>This source code is licensed under both the BSD-style license (found in the LICENSE file in the root directory of this source tree) and the GPLv2 (found in the COPYING file in the root directory of this source tree). You may select, at your option, one of the above-listed licenses. </p>

</div>
</div>
<a id="a10d26640d57defb61b302b1ad663fed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d26640d57defb61b302b1ad663fed8">&#9670;&nbsp;</a></span>WIN_CDECL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_CDECL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On MSVC qsort requires that functions passed into it use the __cdecl calling conversion(CC). This explicitly marks such functions as __cdecl so that the code will still compile if a CC other than __cdecl has been made the default. </p>

</div>
</div>
<a id="a7964be6e3a4fa10246caa18b5df4da34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7964be6e3a4fa10246caa18b5df4da34">&#9670;&nbsp;</a></span>X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">r, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  MEM_STATIC <span class="keywordtype">int</span> ZSTD_cpuid_##name(<a class="code" href="structZSTD__cpuid__t.html">ZSTD_cpuid_t</a> <span class="keyword">const</span> cpuid) {                 \</div>
<div class="line">    return ((cpuid.r) &amp; (1U &lt;&lt; bit)) != 0;                                     \</div>
<div class="line">  }</div>
<div class="ttc" id="astructZSTD__cpuid__t_html"><div class="ttname"><a href="structZSTD__cpuid__t.html">ZSTD_cpuid_t</a></div><div class="ttdef"><b>Definition:</b> zstd.c:8068</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d23c2d8237f77c0dead731a4dd9fed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d23c2d8237f77c0dead731a4dd9fed1">&#9670;&nbsp;</a></span>XXH_PROCESS1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_PROCESS1</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                             \</div>
<div class="line">    hash += (*ptr++) * <a class="code" href="group__XXH32__impl.html#gaa4ab6ba3eb0659356b8ed3b84c43e3e7">XXH_PRIME32_5</a>;                 \</div>
<div class="line">    hash = XXH_rotl32(hash, 11) * <a class="code" href="group__XXH32__impl.html#ga29fede2b86ee758448c55edf6171e11f">XXH_PRIME32_1</a>;      \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="agroup__XXH32__impl_html_ga29fede2b86ee758448c55edf6171e11f"><div class="ttname"><a href="group__XXH32__impl.html#ga29fede2b86ee758448c55edf6171e11f">XXH_PRIME32_1</a></div><div class="ttdeci">#define XXH_PRIME32_1</div><div class="ttdef"><b>Definition:</b> zstd.c:11146</div></div>
<div class="ttc" id="agroup__XXH32__impl_html_gaa4ab6ba3eb0659356b8ed3b84c43e3e7"><div class="ttname"><a href="group__XXH32__impl.html#gaa4ab6ba3eb0659356b8ed3b84c43e3e7">XXH_PRIME32_5</a></div><div class="ttdeci">#define XXH_PRIME32_5</div><div class="ttdef"><b>Definition:</b> zstd.c:11150</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a808ba6cd0cfc0911f8748996fd6d2bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808ba6cd0cfc0911f8748996fd6d2bf2">&#9670;&nbsp;</a></span>XXH_PROCESS4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXH_PROCESS4</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {                             \</div>
<div class="line">    hash += XXH_get32bits(ptr) * <a class="code" href="group__XXH32__impl.html#gacdda6ef95561d39cf2f9b7f2cd5c6693">XXH_PRIME32_3</a>;       \</div>
<div class="line">    ptr += 4;                                         \</div>
<div class="line">    hash  = XXH_rotl32(hash, 17) * <a class="code" href="group__XXH32__impl.html#ga9f43a7ed63cb15dfc49b1a42c250e511">XXH_PRIME32_4</a>;     \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="agroup__XXH32__impl_html_ga9f43a7ed63cb15dfc49b1a42c250e511"><div class="ttname"><a href="group__XXH32__impl.html#ga9f43a7ed63cb15dfc49b1a42c250e511">XXH_PRIME32_4</a></div><div class="ttdeci">#define XXH_PRIME32_4</div><div class="ttdef"><b>Definition:</b> zstd.c:11149</div></div>
<div class="ttc" id="agroup__XXH32__impl_html_gacdda6ef95561d39cf2f9b7f2cd5c6693"><div class="ttname"><a href="group__XXH32__impl.html#gacdda6ef95561d39cf2f9b7f2cd5c6693">XXH_PRIME32_3</a></div><div class="ttdeci">#define XXH_PRIME32_3</div><div class="ttdef"><b>Definition:</b> zstd.c:11148</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3edce797c3674d73fd0f9e7735c9ff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edce797c3674d73fd0f9e7735c9ff4a">&#9670;&nbsp;</a></span>ZDICT_QSORT_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZDICT_QSORT_MIN&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select the qsort() variant used by cover </p>

</div>
</div>
<a id="ae888a667f541f813c6766c53154e99cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae888a667f541f813c6766c53154e99cd">&#9670;&nbsp;</a></span>ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zstd relies on pointer overflow in its decompressor. We add this attribute to functions that rely on pointer overflow. </p>

</div>
</div>
<a id="acae0a8c39456420987044c8e361752f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae0a8c39456420987044c8e361752f2">&#9670;&nbsp;</a></span>ZSTD_ASM_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_ASM_SUPPORTED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only enable assembly for GNU C compatible compilers, because other platforms may not support GAS assembly syntax.</p>
<p>Only enable assembly for Linux / MacOS / Win32, other platforms may work, but they haven't been tested. This could likely be extended to BSD systems.</p>
<p>Disable assembly when MSAN is enabled, because MSAN requires 100% of code to be instrumented to work. </p>

</div>
</div>
<a id="aada15a7370caf4a213b66c33b685f33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada15a7370caf4a213b66c33b685f33f">&#9670;&nbsp;</a></span>ZSTD_BT_GET_ALL_MATCHES_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_BT_GET_ALL_MATCHES_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                                            \</div>
<div class="line">        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 3), \</div>
<div class="line">        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 4), \</div>
<div class="line">        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 5), \</div>
<div class="line">        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 6)  \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abc9888c297ee0ceeddd300eed6430b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9888c297ee0ceeddd300eed6430b69">&#9670;&nbsp;</a></span>ZSTD_BT_SEARCH_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_BT_SEARCH_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;ZSTD_BtFindBestMatch_##dictMode##_##mls</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate search functions templated on (dictMode, mls, rowLog). These functions are outlined for code size &amp; compilation time. <a class="el" href="zstd_8c.html#a56d83089efbda033b3ff3ac36e1e52b6">ZSTD_searchMax()</a> dispatches to the correct implementation function.</p>
<p>TODO: The start of the search function involves loading and calculating a bunch of constants from the <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a>. These computations could be done in an initialization function, and saved somewhere in the match state. Then we could pass a pointer to the saved state instead of the match state, and avoid duplicate computations.</p>
<p>TODO: Move the match re-winding into searchMax. This improves compression ratio, and unlocks further simplifications with the next TODO.</p>
<p>TODO: Try moving the repcode search into searchMax. After the re-winding and repcode search are in searchMax, there is no more logic in the match finder loop that requires knowledge about the dictMode. So we should be able to avoid force inlining it, and we can join the extDict loop with the single segment loop. It should go in searchMax instead of its own function to avoid having multiple virtual function calls per search. </p>

</div>
</div>
<a id="a63096599b11d583c749f6202e6c38f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63096599b11d583c749f6202e6c38f99">&#9670;&nbsp;</a></span>ZSTD_CHUNKSIZE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_CHUNKSIZE_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ( ((U32)-1)                  <span class="comment">/* Maximum ending current index */</span>            \</div>
<div class="line">    - ZSTD_CURRENT_MAX)          <span class="comment">/* Maximum beginning lowLimit */</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4196a5b70b307fc9336bd11a3ff68d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4196a5b70b307fc9336bd11a3ff68d2">&#9670;&nbsp;</a></span>ZSTD_COMPRESS_HEAPMODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_COMPRESS_HEAPMODE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>COMPRESS_HEAPMODE : Select how default decompression function <a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress()</a> allocates its context, on stack (0, default), or into heap (1). Note that functions with explicit context such as <a class="el" href="zstd_8c.html#a16db44e4760f1b4ac38cb50ab2464a59">ZSTD_compressCCtx()</a> are unaffected. </p>

</div>
</div>
<a id="a74205e53e7140614077873c76874d842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74205e53e7140614077873c76874d842">&#9670;&nbsp;</a></span>ZSTD_CONTENTSIZE_UNKNOWN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_CONTENTSIZE_UNKNOWN&#160;&#160;&#160;(0ULL - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9e5f5f8580da4af3bf95471bb2420bee">ZSTD_getFrameContentSize()</a> : requires v1.3.0+ <code>src</code> should point to the start of a ZSTD encoded frame. <code>srcSize</code> must be at least as large as the frame header. hint : any size &gt;= <code>ZSTD_frameHeaderSize_max</code> is large enough. </p><dl class="section return"><dt>Returns</dt><dd>: - decompressed size of <code>src</code> frame content, if known<ul>
<li>ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined</li>
<li>ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small) note 1 : a 0 return value means the frame is valid but "empty". When invoking this method on a skippable frame, it will return 0. note 2 : decompressed size is an optional field, it may not be present (typically in streaming mode). When <code>return==ZSTD_CONTENTSIZE_UNKNOWN</code>, data to decompress could be any size. In which case, it's necessary to use streaming mode to decompress data. Optionally, application can rely on some implicit limit, as <a class="el" href="zstd_8c.html#ad1667ea9aa85971c60ebca267d9540d9">ZSTD_decompress()</a> only needs an upper bound of decompressed size. (For example, data could be necessarily cut into blocks &lt;= 16 KB). note 3 : decompressed size is always present when compression is completed using single-pass functions, such as <a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress()</a>, <a class="el" href="zstd_8c.html#a16db44e4760f1b4ac38cb50ab2464a59">ZSTD_compressCCtx()</a> <a class="el" href="zstd_8c.html#a9c959b4c56ac1f67e2a7b55a41184363">ZSTD_compress_usingDict()</a> or <a class="el" href="zstd_8c.html#a380e2bdc1072dec0c666044902403497">ZSTD_compress_usingCDict()</a>. note 4 : decompressed size can be very large (64-bits value), potentially larger than what local system can handle as a single memory segment. In which case, it's necessary to use streaming mode to decompress data. note 5 : If source is untrusted, decompressed size could be wrong or intentionally modified. Always ensure return value fits within application's authorized limits. Each application can set its own limits. note 6 : This function replaces <a class="el" href="zstd_8c.html#a649e1fd37871a2dfed7833a7741735f8">ZSTD_getDecompressedSize()</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a39a1ac72ca8747f89743a0c134f085d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a1ac72ca8747f89743a0c134f085d2">&#9670;&nbsp;</a></span>ZSTD_DECOMPRESSION_MARGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_DECOMPRESSION_MARGIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">originalSize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blockSize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ((size_t)(                                              \</div>
<div class="line">        ZSTD_FRAMEHEADERSIZE_MAX                                                              <span class="comment">/* Frame header */</span> + \</div>
<div class="line">        4                                                                                         <span class="comment">/* checksum */</span> + \</div>
<div class="line">        ((originalSize) == 0 ? 0 : 3 * (((originalSize) + (blockSize) - 1) / blockSize)) <span class="comment">/* 3 bytes per block */</span> + \</div>
<div class="line">        (blockSize)                                                                    <span class="comment">/* One block of margin */</span>   \</div>
<div class="line">    ))</div>
</div><!-- fragment --><p>ZSTD_DECOMPRESS_MARGIN() : Similar to <a class="el" href="zstd_8c.html#ac079fdb80692d42f2ea5421bd83f8542">ZSTD_decompressionMargin()</a>, but instead of computing the margin from the compressed frame, compute it from the original size and the blockSizeLog. See <a class="el" href="zstd_8c.html#ac079fdb80692d42f2ea5421bd83f8542">ZSTD_decompressionMargin()</a> for details.</p>
<p>WARNING: This macro does not support multi-frame input, the input must be a single zstd frame. If you need that support use the function, or implement it yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalSize</td><td>The original uncompressed size of the data. </td></tr>
    <tr><td class="paramname">blockSize</td><td>The block size == MIN(windowSize, ZSTD_BLOCKSIZE_MAX). Unless you explicitly set the windowLog smaller than ZSTD_BLOCKSIZELOG_MAX you can just use ZSTD_BLOCKSIZE_MAX. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1f0e4ee71ec1dedd11082fa2b54e462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f0e4ee71ec1dedd11082fa2b54e462">&#9670;&nbsp;</a></span>ZSTD_DUBT_UNSORTED_MARK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_DUBT_UNSORTED_MARK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                       1   <span class="comment">/* For btlazy2 strategy, index ZSTD_DUBT_UNSORTED_MARK==1 means &quot;unsorted&quot;.</span></div>
<div class="line"><span class="comment">                                       It could be confused for a real successor at index &quot;1&quot;, if sorted as larger than its predecessor.</span></div>
<div class="line"><span class="comment">                                       It&#39;s not a big deal though : candidate will just be sorted again.</span></div>
<div class="line"><span class="comment">                                       Additionally, candidate position 1 will be lost.</span></div>
<div class="line"><span class="comment">                                       But candidate 1 cannot hide a large tree of candidates, so it&#39;s a minimal loss.</span></div>
<div class="line"><span class="comment">                                       The benefit is that ZSTD_DUBT_UNSORTED_MARK cannot be mishandled after table reuse with a different strategy.</span></div>
<div class="line"><span class="comment">                                       This constant is required by ZSTD_compressBlock_btlazy2() and ZSTD_reduceTable_internal() */</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8084640e001328f56badaf0fd91cf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8084640e001328f56badaf0fd91cf6a">&#9670;&nbsp;</a></span>ZSTD_ENABLE_ASM_X86_64_BMI2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_ENABLE_ASM_X86_64_BMI2&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether we should enable assembly for x86-64 with BMI2.</p>
<p>Enable if all of the following conditions hold:</p><ul>
<li>ASM hasn't been explicitly disabled by defining ZSTD_DISABLE_ASM</li>
<li>Assembly is supported</li>
<li>We are compiling for x86-64 and either:<ul>
<li>DYNAMIC_BMI2 is enabled</li>
<li>BMI2 is supported at compile time </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a5f6b371e82f95fae4124317352d69e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6b371e82f95fae4124317352d69e0d">&#9670;&nbsp;</a></span>ZSTD_FOR_EACH_DICT_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_FOR_EACH_DICT_MODE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    X(__VA_ARGS__, noDict)              \</div>
<div class="line">    X(__VA_ARGS__, extDict)             \</div>
<div class="line">    X(__VA_ARGS__, dictMatchState)      \</div>
<div class="line">    X(__VA_ARGS__, dedicatedDictSearch)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a356b4fbe5c2600b1098938ebe26fc993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356b4fbe5c2600b1098938ebe26fc993">&#9670;&nbsp;</a></span>ZSTD_FOR_EACH_MLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_FOR_EACH_MLS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    X(dictMode, 4)                     \</div>
<div class="line">    X(dictMode, 5)                     \</div>
<div class="line">    X(dictMode, 6)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c5d710e0606341946558473e725e738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5d710e0606341946558473e725e738">&#9670;&nbsp;</a></span>ZSTD_FOR_EACH_MLS_ROWLOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_FOR_EACH_MLS_ROWLOG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 4)      \</div>
<div class="line">    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 5)      \</div>
<div class="line">    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 6)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a5728fbd0a5968e6f6ad1204e2928c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5728fbd0a5968e6f6ad1204e2928c8">&#9670;&nbsp;</a></span>ZSTD_FOR_EACH_ROWLOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_FOR_EACH_ROWLOG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    X(dictMode, mls, 4)                        \</div>
<div class="line">    X(dictMode, mls, 5)                        \</div>
<div class="line">    X(dictMode, mls, 6)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad447810dcf165b6087b42c4aa4f1ee5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad447810dcf165b6087b42c4aa4f1ee5e">&#9670;&nbsp;</a></span>ZSTD_GEN_DFAST_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_GEN_DFAST_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keywordtype">size_t</span> ZSTD_compressBlock_doubleFast_##dictMode##_##mls(                                      \</div>
<div class="line">            <a class="code" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a>* ms, <a class="code" href="structSeqStore__t.html">SeqStore_t</a>* seqStore, U32 rep[ZSTD_REP_NUM],                          \</div>
<div class="line">            <span class="keywordtype">void</span> <span class="keyword">const</span>* src, <span class="keywordtype">size_t</span> srcSize)                                                             \</div>
<div class="line">    {                                                                                                    \</div>
<div class="line">        return ZSTD_compressBlock_doubleFast_##dictMode##_generic(ms, seqStore, rep, src, srcSize, mls); \</div>
<div class="line">    }</div>
<div class="ttc" id="astructSeqStore__t_html"><div class="ttname"><a href="structSeqStore__t.html">SeqStore_t</a></div><div class="ttdef"><b>Definition:</b> zstd.c:19282</div></div>
<div class="ttc" id="astructZSTD__MatchState__t_html"><div class="ttname"><a href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a></div><div class="ttdef"><b>Definition:</b> zstd.c:19456</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a70f6014178292642a6cecfac6903fb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f6014178292642a6cecfac6903fb9d">&#9670;&nbsp;</a></span>ZSTD_GEN_FAST_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_GEN_FAST_FN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mml, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmov&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keywordtype">size_t</span> ZSTD_compressBlock_fast_##dictMode##_##mml##_##cmov(                              \</div>
<div class="line">            <a class="code" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a>* ms, <a class="code" href="structSeqStore__t.html">SeqStore_t</a>* seqStore, U32 rep[ZSTD_REP_NUM],                    \</div>
<div class="line">            <span class="keywordtype">void</span> <span class="keyword">const</span>* src, <span class="keywordtype">size_t</span> srcSize)                                                       \</div>
<div class="line">    {                                                                                              \</div>
<div class="line">        return ZSTD_compressBlock_fast_##dictMode##_generic(ms, seqStore, rep, src, srcSize, mml, cmov); \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a430683fe90300dfdda39b13c44c7f98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430683fe90300dfdda39b13c44c7f98d">&#9670;&nbsp;</a></span>ZSTD_GEN_RECORD_FINGERPRINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_GEN_RECORD_FINGERPRINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_rate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_hSize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> FP_RECORD(_rate)(<a class="code" href="structFingerprint.html">Fingerprint</a>* fp, <span class="keyword">const</span> <span class="keywordtype">void</span>* src, <span class="keywordtype">size_t</span> srcSize) \</div>
<div class="line">    {                                                                              \</div>
<div class="line">        recordFingerprint_generic(fp, src, srcSize, _rate, _hSize);                \</div>
<div class="line">    }</div>
<div class="ttc" id="astructFingerprint_html"><div class="ttname"><a href="structFingerprint.html">Fingerprint</a></div><div class="ttdef"><b>Definition:</b> zstd.c:22335</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac570c350773632077c2d6b045b7f0be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac570c350773632077c2d6b045b7f0be4">&#9670;&nbsp;</a></span>ZSTD_HASHLOG3_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_HASHLOG3_MAX&#160;&#160;&#160;17</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_HASHLOG3_MAX : Maximum size of the hash table dedicated to find 3-bytes matches, in log format, aka 17 =&gt; 1 &lt;&lt; 17 == 128Ki positions. This structure is only used in zstd_opt. Since allocation is centralized for all strategies, it has to be known here. The actual (selected) size of the hash table is then stored in ZSTD_MatchState_t.hashLog3, so that zstd_opt.c doesn't need to know about this constant. </p>

</div>
</div>
<a id="ace94e70b03794a8b0f63343d98eb6aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace94e70b03794a8b0f63343d98eb6aed">&#9670;&nbsp;</a></span>ZSTD_HEAPMODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_HEAPMODE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HEAPMODE : Select how default decompression function <a class="el" href="zstd_8c.html#ad1667ea9aa85971c60ebca267d9540d9">ZSTD_decompress()</a> allocates its context, on stack (0), or into heap (1, default; requires malloc()). Note that functions with explicit context such as <a class="el" href="zstd_8c.html#ad65d6c1880cffdf1120e06277a2d0a5b">ZSTD_decompressDCtx()</a> are unaffected. </p>

</div>
</div>
<a id="a8dceeddd8c95c1559b57a34cc9cd32c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dceeddd8c95c1559b57a34cc9cd32c6">&#9670;&nbsp;</a></span>ZSTD_IS_DETERMINISTIC_BUILD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_IS_DETERMINISTIC_BUILD&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_IS_DETERMINISTIC_BUILD must be set to 0 if any compilation macro is active that impacts the compressed output.</p>
<p>NOTE: ZSTD_MULTITHREAD is allowed to be set or unset. </p>

</div>
</div>
<a id="ac3e1c827583b0133b085b8cfc1cdb236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e1c827583b0133b085b8cfc1cdb236">&#9670;&nbsp;</a></span>ZSTD_LAZY_DDSS_BUCKET_LOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_LAZY_DDSS_BUCKET_LOG&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dedicated Dictionary Search Structure bucket log. In the ZSTD_dedicatedDictSearch mode, the hashTable has 2 ** ZSTD_LAZY_DDSS_BUCKET_LOG entries in each bucket, rather than just one. </p>

</div>
</div>
<a id="a968d2cc21153e3377666e3bfadbcef03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968d2cc21153e3377666e3bfadbcef03">&#9670;&nbsp;</a></span>ZSTD_MAX_INPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_MAX_INPUT_SIZE&#160;&#160;&#160;((sizeof(size_t)==8) ? 0xFF00FF00FF00FF00ULL : 0xFF00FF00U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a04413eba92e4dc84ca561de847fbcd06">ZSTD_compressBound()</a> : maximum compressed size in worst case single-pass scenario. When invoking <code><a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress()</a></code>, or any other one-pass compression function, it's recommended to provide @dstCapacity &gt;= ZSTD_compressBound(srcSize) as it eliminates one potential failure scenario, aka not enough room in dst buffer to write the compressed frame. Note : <a class="el" href="zstd_8c.html#a04413eba92e4dc84ca561de847fbcd06">ZSTD_compressBound()</a> itself can fail, if @srcSize &gt;= ZSTD_MAX_INPUT_SIZE . In which case, <a class="el" href="zstd_8c.html#a04413eba92e4dc84ca561de847fbcd06">ZSTD_compressBound()</a> will return an error code which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>.</p>
<p>ZSTD_COMPRESSBOUND() : same as <a class="el" href="zstd_8c.html#a04413eba92e4dc84ca561de847fbcd06">ZSTD_compressBound()</a>, but as a macro. It can be used to produce constants, which can be useful for static allocation, for example to size a static array on stack. Will produce constant value 0 if srcSize is too large. </p>

</div>
</div>
<a id="a819c3efc2a4005aadfec6f0ef9859744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819c3efc2a4005aadfec6f0ef9859744">&#9670;&nbsp;</a></span>ZSTD_MAX_NB_BLOCK_SPLITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_MAX_NB_BLOCK_SPLITS&#160;&#160;&#160;196</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struct that contains all elements of block splitter that should be allocated in a wksp. </p>

</div>
</div>
<a id="afe07180770b02bc7cc991a73aabe0275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe07180770b02bc7cc991a73aabe0275">&#9670;&nbsp;</a></span>ZSTD_MAXWINDOWSIZE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_MAXWINDOWSIZE_DEFAULT&#160;&#160;&#160;(((U32)1 &lt;&lt; ZSTD_WINDOWLOG_LIMIT_DEFAULT) + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LEGACY_SUPPORT : if set to 1+, <a class="el" href="zstd_8c.html#ad1667ea9aa85971c60ebca267d9540d9">ZSTD_decompress()</a> can decode older formats (v0.1+)</p>
<p>MAXWINDOWSIZE_DEFAULT : maximum window size accepted by DStream <b>by default</b>. Frames requiring more memory will be rejected. It's possible to set a different limit using <a class="el" href="zstd_8c.html#ae7beb5c17c0ab64569b170dc3498aaee">ZSTD_DCtx_setMaxWindowSize()</a>. </p>

</div>
</div>
<a id="ae5ca6fc4844082acd5e6d4b14608f519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ca6fc4844082acd5e6d4b14608f519">&#9670;&nbsp;</a></span>ZSTD_NO_FORWARD_PROGRESS_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_NO_FORWARD_PROGRESS_MAX&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NO_FORWARD_PROGRESS_MAX : maximum allowed nb of calls to <a class="el" href="zstd_8c.html#a4ccda24ca50a1a35ea76a97b13edf398">ZSTD_decompressStream()</a> without any forward progress (defined as: no byte read from input, and no byte flushed to output) before triggering an error. </p>

</div>
</div>
<a id="a88ee65bfaa76923eb488b3c9744e32c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ee65bfaa76923eb488b3c9744e32c0">&#9670;&nbsp;</a></span>ZSTD_SWITCH_MLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_SWITCH_MLS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">switch</span> (mls) {                     \</div>
<div class="line">        ZSTD_FOR_EACH_MLS(X, dictMode) \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acabf5fcc28053ac45e9f1655e1248a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabf5fcc28053ac45e9f1655e1248a2f">&#9670;&nbsp;</a></span>ZSTD_SWITCH_ROWLOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_SWITCH_ROWLOG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">case</span> mls:                                                                \</div>
<div class="line">        switch (rowLog) {                                                    \</div>
<div class="line">            ZSTD_FOR_EACH_ROWLOG(GEN_ZSTD_CALL_ROW_SEARCH_FN, dictMode, mls) \</div>
<div class="line">        }                                                                    \</div>
<div class="line">        ZSTD_UNREACHABLE;                                                    \</div>
<div class="line">        break;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a588737348fea750852bb6911c5209091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588737348fea750852bb6911c5209091">&#9670;&nbsp;</a></span>ZSTD_SWITCH_SEARCH_METHOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_SWITCH_SEARCH_METHOD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dictMode</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">switch</span> (searchMethod) {                                       \</div>
<div class="line">        case search_hashChain:                                    \</div>
<div class="line">            ZSTD_SWITCH_MLS(GEN_ZSTD_CALL_HC_SEARCH_FN, dictMode) \</div>
<div class="line">            break;                                                \</div>
<div class="line">        case search_binaryTree:                                   \</div>
<div class="line">            ZSTD_SWITCH_MLS(GEN_ZSTD_CALL_BT_SEARCH_FN, dictMode) \</div>
<div class="line">            break;                                                \</div>
<div class="line">        case search_rowHash:                                      \</div>
<div class="line">            ZSTD_SWITCH_MLS(ZSTD_SWITCH_ROWLOG, dictMode)         \</div>
<div class="line">            break;                                                \</div>
<div class="line">    }                                                             \</div>
<div class="line">    ZSTD_UNREACHABLE;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a06fc5f632ee86bfcdaa096773908fb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fc5f632ee86bfcdaa096773908fb99">&#9670;&nbsp;</a></span>ZSTD_WINDOWLOG_LIMIT_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZSTD_WINDOWLOG_LIMIT_DEFAULT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                           27   <span class="comment">/* by default, the streaming decoder will refuse any frame</span></div>
<div class="line"><span class="comment">                                           * requiring larger than (1&lt;&lt;ZSTD_WINDOWLOG_LIMIT_DEFAULT) window size,</span></div>
<div class="line"><span class="comment">                                           * to preserve host&#39;s memory from unreasonable requirements.</span></div>
<div class="line"><span class="comment">                                           * This limit can be overridden using ZSTD_DCtx_setParameter(,ZSTD_d_windowLogMax,).</span></div>
<div class="line"><span class="comment">                                           * The limit does not apply for one-pass decoders (such as ZSTD_decompress()), since no additional memory is allocated */</span></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aaf2609966f31111ad988e3c226013dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2609966f31111ad988e3c226013dc2">&#9670;&nbsp;</a></span>COVER_best_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCOVER__best__s.html">COVER_best_s</a> <a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>COVER_best_t is used for two purposes:</p><ol type="1">
<li>Synchronizing threads.</li>
<li>Saving the best parameters and dictionary.</li>
</ol>
<p>All of the methods except <a class="el" href="zstd_8c.html#ad0e0964587f6d04e93bd019b9cfc6d4e">COVER_best_init()</a> are thread safe if zstd is compiled with multithreaded support. </p>

</div>
</div>
<a id="a3668acc1d146e3367f7f17ea2fb9b10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3668acc1d146e3367f7f17ea2fb9b10c">&#9670;&nbsp;</a></span>COVER_dictSelection_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCOVER__dictSelection.html">COVER_dictSelection</a> <a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struct used for the dictionary selection function. </p>

</div>
</div>
<a id="a0bcadb99c1e3d4210367ddf706e2c10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcadb99c1e3d4210367ddf706e2c10e">&#9670;&nbsp;</a></span>COVER_tryParameters_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCOVER__tryParameters__data__s.html">COVER_tryParameters_data_s</a> <a class="el" href="zstd_8c.html#a0bcadb99c1e3d4210367ddf706e2c10e">COVER_tryParameters_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters for COVER_tryParameters(). </p>

</div>
</div>
<a id="a7509ace266912c8ba8e10d3f7fc479bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7509ace266912c8ba8e10d3f7fc479bb">&#9670;&nbsp;</a></span>FASTCOVER_tryParameters_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structFASTCOVER__tryParameters__data__s.html">FASTCOVER_tryParameters_data_s</a> <a class="el" href="zstd_8c.html#a7509ace266912c8ba8e10d3f7fc479bb">FASTCOVER_tryParameters_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters for FASTCOVER_tryParameters(). </p>

</div>
</div>
<a id="a54dd08a75764e9f6058b47735da04eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dd08a75764e9f6058b47735da04eea">&#9670;&nbsp;</a></span>FSE_CTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor and Destructor of FSE_CTable. Note that FSE_CTable size depends on 'tableLog' and 'maxSymbolValue' </p>

</div>
</div>
<a id="a657f7753ec82fce04c212f38d9c58e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657f7753ec82fce04c212f38d9c58e61">&#9670;&nbsp;</a></span>POOL_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* POOL_function) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>POOL_function : The function type that can be added to a thread pool. </p>

</div>
</div>
<a id="adbb6139b5162a3a74f0d3ae0d7395268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb6139b5162a3a74f0d3ae0d7395268">&#9670;&nbsp;</a></span>ZSTD_allocFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* ZSTD_allocFunction) (void *opaque, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Custom memory allocation : These prototypes make it possible to pass your own allocation/free functions. <a class="el" href="structZSTD__customMem.html">ZSTD_customMem</a> is provided at creation time, using ZSTD_create*_advanced() variants listed below. All allocation/free operations will be completed using these custom variants instead of regular &lt;stdlib.h&gt; ones. </p>

</div>
</div>
<a id="a7591551effb218c2750f0f57ba62809a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7591551effb218c2750f0f57ba62809a">&#9670;&nbsp;</a></span>ZSTD_CStream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> <a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CCtx and CStream are now effectively same object (&gt;= v1.3.0) </p>

</div>
</div>
<a id="abc6473440df4dc8a7ce82443825c47df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6473440df4dc8a7ce82443825c47df">&#9670;&nbsp;</a></span>ZSTD_DStream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> <a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DCtx and DStream are now effectively same object (&gt;= v1.3.0) </p>

</div>
</div>
<a id="aa979b4b649aec2c11af1876dcae1590a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa979b4b649aec2c11af1876dcae1590a">&#9670;&nbsp;</a></span>ZSTD_threadPool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structPOOL__ctx__s.html">POOL_ctx_s</a> <a class="el" href="zstd_8c.html#aa979b4b649aec2c11af1876dcae1590a">ZSTD_threadPool</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread pool : These prototypes make it possible to share a thread pool among multiple compression contexts. This can limit resources for applications with multiple threads where each one uses a threaded compression mode (via ZSTD_c_nbWorkers parameter). ZSTD_createThreadPool creates a new thread pool with a given number of threads. Note that the lifetime of such pool must exist while being used. ZSTD_CCtx_refThreadPool assigns a thread pool to a context (use NULL argument value to use an internal thread pool). ZSTD_freeThreadPool frees a thread pool, accepts NULL pointer. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aebeae519ed239e8ec29b2926630400b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebeae519ed239e8ec29b2926630400b2">&#9670;&nbsp;</a></span>FSE_repeat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#aebeae519ed239e8ec29b2926630400b2">FSE_repeat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aebeae519ed239e8ec29b2926630400b2afbea521e4056e2437aae0b0bda7cedc8"></a>FSE_repeat_none&#160;</td><td class="fielddoc"><p>Cannot use the previous table </p>
</td></tr>
<tr><td class="fieldname"><a id="aebeae519ed239e8ec29b2926630400b2a08d1028515df85f72b8d6c2c1ef66c8d"></a>FSE_repeat_check&#160;</td><td class="fielddoc"><p>Can use the previous table but it must be checked </p>
</td></tr>
<tr><td class="fieldname"><a id="aebeae519ed239e8ec29b2926630400b2a0d596aacfa5c69c0da1bd28bb77b1a6a"></a>FSE_repeat_valid&#160;</td><td class="fielddoc"><p>Can use the previous table and it is assumed to be valid </p>
</td></tr>
</table>

</div>
</div>
<a id="a57bcfd05176fe8cc555106dcdd65769b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bcfd05176fe8cc555106dcdd65769b">&#9670;&nbsp;</a></span>HUF_flags_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#a57bcfd05176fe8cc555106dcdd65769b">HUF_flags_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Huffman flags bitset. For all flags, 0 is the default value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a57bcfd05176fe8cc555106dcdd65769ba34c7ca7f4fde007b74478d5fcf510c90"></a>HUF_flags_bmi2&#160;</td><td class="fielddoc"><p>If compiled with DYNAMIC_BMI2: Set flag only if the CPU supports BMI2 at runtime. Otherwise: Ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="a57bcfd05176fe8cc555106dcdd65769ba9336eacc6d681229b6e580dfcd587e6b"></a>HUF_flags_optimalDepth&#160;</td><td class="fielddoc"><p>If set: Test possible table depths to find the one that produces the smallest header + encoded size. If unset: Use heuristic to find the table depth. </p>
</td></tr>
<tr><td class="fieldname"><a id="a57bcfd05176fe8cc555106dcdd65769babb08f80995f3570dd45e23f293071691"></a>HUF_flags_preferRepeat&#160;</td><td class="fielddoc"><p>If set: If the previous table can encode the input, always reuse the previous table. If unset: If the previous table can encode the input, reuse the previous table if it results in a smaller output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a57bcfd05176fe8cc555106dcdd65769ba35997496a2eee7d1f5eb856e75f5ed7a"></a>HUF_flags_suspectUncompressible&#160;</td><td class="fielddoc"><p>If set: Sample the input and check if the sample is uncompressible, if it is then don't attempt to compress. If unset: Always histogram the entire input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a57bcfd05176fe8cc555106dcdd65769ba959109ca82c8504569a136690a8d2428"></a>HUF_flags_disableAsm&#160;</td><td class="fielddoc"><p>If set: Don't use assembly implementations If unset: Allow using assembly implementations </p>
</td></tr>
<tr><td class="fieldname"><a id="a57bcfd05176fe8cc555106dcdd65769ba605f0a6c3c944cd219214a8ab01d6a0b"></a>HUF_flags_disableFast&#160;</td><td class="fielddoc"><p>If set: Don't use the fast decoding loop, always use the fallback decoding loop. If unset: Use the fast decoding loop when possible. </p>
</td></tr>
</table>

</div>
</div>
<a id="aea428e39b157d5f4d9bc03d030708c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea428e39b157d5f4d9bc03d030708c29">&#9670;&nbsp;</a></span>HUF_repeat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29">HUF_repeat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aea428e39b157d5f4d9bc03d030708c29a8812ea6611ba5166fe7e392482d0414d"></a>HUF_repeat_none&#160;</td><td class="fielddoc"><p>Cannot use the previous table </p>
</td></tr>
<tr><td class="fieldname"><a id="aea428e39b157d5f4d9bc03d030708c29afc9ac956fe9e6db0fde5e5b20b9901ae"></a>HUF_repeat_check&#160;</td><td class="fielddoc"><p>Can use the previous table but it must be checked. Note : The previous table must have been constructed by HUF_compress{1, 4}X_repeat </p>
</td></tr>
<tr><td class="fieldname"><a id="aea428e39b157d5f4d9bc03d030708c29a3f6a33341880fd95bee8e05b671cc17a"></a>HUF_repeat_valid&#160;</td><td class="fielddoc"><p>Can use the previous table and it is assumed to be valid </p>
</td></tr>
</table>

</div>
</div>
<a id="a00047efe2f309b66658fc8b33361ab1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00047efe2f309b66658fc8b33361ab1a">&#9670;&nbsp;</a></span>ZSTD_buffered_policy_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#a00047efe2f309b66658fc8b33361ab1a">ZSTD_buffered_policy_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether this compression proceeds directly from user-provided source buffer to user-provided destination buffer (ZSTDb_not_buffered), or whether the context needs to buffer the input/output (ZSTDb_buffered). </p>

</div>
</div>
<a id="a90bda71cebae53b2942b1c0eda3112e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bda71cebae53b2942b1c0eda3112e9">&#9670;&nbsp;</a></span>ZSTD_compResetPolicy_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#a90bda71cebae53b2942b1c0eda3112e9">ZSTD_compResetPolicy_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls, for this matchState reset, whether the tables need to be cleared / prepared for the coming compression (ZSTDcrp_makeClean), or whether the tables can be left unclean (ZSTDcrp_leaveDirty), because we know that a subsequent operation will overwrite the table space anyways (e.g., copying the matchState contents in from a CDict). </p>

</div>
</div>
<a id="a1df52ae5f2538c70f0db6f9c9377f6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df52ae5f2538c70f0db6f9c9377f6c7">&#9670;&nbsp;</a></span>ZSTD_cwksp_static_alloc_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#a1df52ae5f2538c70f0db6f9c9377f6c7">ZSTD_cwksp_static_alloc_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to describe whether the workspace is statically allocated (and will not necessarily ever be freed), or if it's dynamically allocated and we can expect a well-formed caller to free this. </p>

</div>
</div>
<a id="af9b07eb9d181ba9a9085f75d52b3d839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b07eb9d181ba9a9085f75d52b3d839">&#9670;&nbsp;</a></span>ZSTD_dictLoadMethod_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af9b07eb9d181ba9a9085f75d52b3d839a59cd77cf86c004e68373a7db14539aaf"></a>ZSTD_dlm_byCopy&#160;</td><td class="fielddoc"><p>Copy dictionary content internally </p>
</td></tr>
<tr><td class="fieldname"><a id="af9b07eb9d181ba9a9085f75d52b3d839a9acc996c7124ebfde521233208203b76"></a>ZSTD_dlm_byRef&#160;</td><td class="fielddoc"><p>Reference dictionary content &ndash; the dictionary buffer must outlive its users. </p>
</td></tr>
</table>

</div>
</div>
<a id="a60ef91a46ef394adfb15fcc5404f0a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ef91a46ef394adfb15fcc5404f0a89">&#9670;&nbsp;</a></span>ZSTD_indexResetPolicy_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#a60ef91a46ef394adfb15fcc5404f0a89">ZSTD_indexResetPolicy_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls, for this matchState reset, whether indexing can continue where it left off (ZSTDirp_continue), or whether it needs to be restarted from zero (ZSTDirp_reset). </p>

</div>
</div>
<a id="a5c3e172ab79a1213e7b60a8732c2d4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3e172ab79a1213e7b60a8732c2d4c4">&#9670;&nbsp;</a></span>ZSTD_literalCompressionMode_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zstd_8c.html#a5c3e172ab79a1213e7b60a8732c2d4c4">ZSTD_literalCompressionMode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5c3e172ab79a1213e7b60a8732c2d4c4a720c11b570fcbdf1be29e85fd061ec06"></a>ZSTD_lcm_auto&#160;</td><td class="fielddoc"><p>Automatically determine the compression mode based on the compression level. Negative compression levels will be uncompressed, and positive compression levels will be compressed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5c3e172ab79a1213e7b60a8732c2d4c4a4404a781197abd21f07f1471a0951471"></a>ZSTD_lcm_huffman&#160;</td><td class="fielddoc"><p>Always attempt Huffman compression. Uncompressed literals will still be emitted if Huffman compression is not profitable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5c3e172ab79a1213e7b60a8732c2d4c4a6f9a8f0cc22507401cbb4a79f5ed5567"></a>ZSTD_lcm_uncompressed&#160;</td><td class="fielddoc"><p>Always emit uncompressed literals. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa48823f7e738bb39e6db428de599161b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48823f7e738bb39e6db428de599161b">&#9670;&nbsp;</a></span>BIT_addBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void BIT_addBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitContainerType&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aa48823f7e738bb39e6db428de599161b">BIT_addBits()</a> : can add up to 31 bits into <code>bitC</code>. Note : does not check for register overflow ! </p>

</div>
</div>
<a id="a2eff282f423dfc3aa20a57d50cf4f8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eff282f423dfc3aa20a57d50cf4f8e9">&#9670;&nbsp;</a></span>BIT_addBitsFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void BIT_addBitsFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitContainerType&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a2eff282f423dfc3aa20a57d50cf4f8e9">BIT_addBitsFast()</a> : works only if <code>value</code> is <em>clean</em>, meaning all high bits above nbBits are 0 </p>

</div>
</div>
<a id="a06b24fd9264fb4cb14e5f9aecc26acbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b24fd9264fb4cb14e5f9aecc26acbd">&#9670;&nbsp;</a></span>BIT_closeCStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t BIT_closeCStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a06b24fd9264fb4cb14e5f9aecc26acbd">BIT_closeCStream()</a> : </p><dl class="section return"><dt>Returns</dt><dd>: size of CStream, in bytes, or 0 if it could not fit into dstBuffer </dd></dl>

</div>
</div>
<a id="a8a1c18f5b36ba98fe0f9702bc74d86b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1c18f5b36ba98fe0f9702bc74d86b1">&#9670;&nbsp;</a></span>BIT_endOfDStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC unsigned BIT_endOfDStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>DStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a8a1c18f5b36ba98fe0f9702bc74d86b1">BIT_endOfDStream()</a> : </p><dl class="section return"><dt>Returns</dt><dd>: 1 if DStream has <em>exactly</em> reached its end (all bits consumed). </dd></dl>

</div>
</div>
<a id="a4c839965cf6a86f64d859153451ccab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c839965cf6a86f64d859153451ccab6">&#9670;&nbsp;</a></span>BIT_flushBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void BIT_flushBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a4c839965cf6a86f64d859153451ccab6">BIT_flushBits()</a> : assumption : bitContainer has not overflowed safe version; check for buffer overflow, and prevents it. note : does not signal buffer overflow. overflow will be revealed later on using <a class="el" href="zstd_8c.html#a06b24fd9264fb4cb14e5f9aecc26acbd">BIT_closeCStream()</a> </p>

</div>
</div>
<a id="aeedf7cf3cceebe81e04d22fd42971bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedf7cf3cceebe81e04d22fd42971bd3">&#9670;&nbsp;</a></span>BIT_flushBitsFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void BIT_flushBitsFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aeedf7cf3cceebe81e04d22fd42971bd3">BIT_flushBitsFast()</a> : assumption : bitContainer has not overflowed unsafe version; does not check buffer overflow </p>

</div>
</div>
<a id="a77907fae42615fa580281a1b5b80b629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77907fae42615fa580281a1b5b80b629">&#9670;&nbsp;</a></span>BIT_initCStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t BIT_initCStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__CStream__t.html">BIT_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a77907fae42615fa580281a1b5b80b629">BIT_initCStream()</a> : <code>dstCapacity</code> must be &gt; sizeof(size_t) </p><dl class="section return"><dt>Returns</dt><dd>: 0 if success, otherwise an error code (can be tested using ERR_isError()) </dd></dl>

</div>
</div>
<a id="a01bc56df5d3b4844fd5bf6bde7393bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bc56df5d3b4844fd5bf6bde7393bd3">&#9670;&nbsp;</a></span>BIT_initDStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t BIT_initDStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a01bc56df5d3b4844fd5bf6bde7393bd3">BIT_initDStream()</a> : Initialize a <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a>. <code>bitD</code> : a pointer to an already allocated <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> structure. <code>srcSize</code> must be the <em>exact</em> size of the bitStream, in bytes. </p><dl class="section return"><dt>Returns</dt><dd>: size of stream (== srcSize), or an errorCode if a problem is detected </dd></dl>

</div>
</div>
<a id="a031ea40777b45663d375e2a41eb5e650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031ea40777b45663d375e2a41eb5e650">&#9670;&nbsp;</a></span>BIT_lookBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> BitContainerType BIT_lookBits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>nbBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a031ea40777b45663d375e2a41eb5e650">BIT_lookBits()</a> : Provides next n bits from local register. local register is not modified. On 32-bits, maxNbBits==24. On 64-bits, maxNbBits==56. </p><dl class="section return"><dt>Returns</dt><dd>: value extracted </dd></dl>

</div>
</div>
<a id="a3e301dbc45a933652fbf9e0b5bf5072f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e301dbc45a933652fbf9e0b5bf5072f">&#9670;&nbsp;</a></span>BIT_lookBitsFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC BitContainerType BIT_lookBitsFast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>nbBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a3e301dbc45a933652fbf9e0b5bf5072f">BIT_lookBitsFast()</a> : unsafe version; only works if nbBits &gt;= 1 </p>

</div>
</div>
<a id="a84d4701e95f21414679b1363b1d2cad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d4701e95f21414679b1363b1d2cad7">&#9670;&nbsp;</a></span>BIT_readBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> BitContainerType BIT_readBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a84d4701e95f21414679b1363b1d2cad7">BIT_readBits()</a> : Read (consume) next n bits from local register and update. Pay attention to not read more than nbBits contained into local register. </p><dl class="section return"><dt>Returns</dt><dd>: extracted value. </dd></dl>

</div>
</div>
<a id="afcbadcca4d24830dedbe2ebf5894bfaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbadcca4d24830dedbe2ebf5894bfaf">&#9670;&nbsp;</a></span>BIT_readBitsFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC BitContainerType BIT_readBitsFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#afcbadcca4d24830dedbe2ebf5894bfaf">BIT_readBitsFast()</a> : unsafe version; only works if nbBits &gt;= 1 </p>

</div>
</div>
<a id="aafff1d22e07fe1b4094557b38e44a111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafff1d22e07fe1b4094557b38e44a111">&#9670;&nbsp;</a></span>BIT_reloadDStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> BIT_DStream_status BIT_reloadDStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aafff1d22e07fe1b4094557b38e44a111">BIT_reloadDStream()</a> : Refill <code>bitD</code> from buffer previously set in <a class="el" href="zstd_8c.html#a01bc56df5d3b4844fd5bf6bde7393bd3">BIT_initDStream()</a> . This function is safe, it guarantees it will not never beyond src buffer. </p><dl class="section return"><dt>Returns</dt><dd>: status of <code><a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a></code> internal register. when status == BIT_DStream_unfinished, internal register is filled with at least 25 or 57 bits </dd></dl>

</div>
</div>
<a id="aca5000ecd7f1ede095a7efa1df7e8e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5000ecd7f1ede095a7efa1df7e8e83">&#9670;&nbsp;</a></span>BIT_reloadDStream_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC BIT_DStream_status BIT_reloadDStream_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aca5000ecd7f1ede095a7efa1df7e8e83">BIT_reloadDStream_internal()</a> : Simple variant of <a class="el" href="zstd_8c.html#aafff1d22e07fe1b4094557b38e44a111">BIT_reloadDStream()</a>, with two conditions:</p><ol type="1">
<li>bitstream is valid : bitsConsumed &lt;= sizeof(bitD-&gt;bitContainer)*8</li>
<li>look window is valid after shifted down : bitD-&gt;ptr &gt;= bitD-&gt;start </li>
</ol>

</div>
</div>
<a id="ad50791a76727900102d2884fb09c3019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50791a76727900102d2884fb09c3019">&#9670;&nbsp;</a></span>BIT_reloadDStreamFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC BIT_DStream_status BIT_reloadDStreamFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBIT__DStream__t.html">BIT_DStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ad50791a76727900102d2884fb09c3019">BIT_reloadDStreamFast()</a> : Similar to <a class="el" href="zstd_8c.html#aafff1d22e07fe1b4094557b38e44a111">BIT_reloadDStream()</a>, but with two differences:</p><ol type="1">
<li>bitsConsumed &lt;= sizeof(bitD-&gt;bitContainer)*8 must hold!</li>
<li>Returns BIT_DStream_overflow when bitD-&gt;ptr &lt; bitD-&gt;limitPtr, at this point you must use <a class="el" href="zstd_8c.html#aafff1d22e07fe1b4094557b38e44a111">BIT_reloadDStream()</a> to reload. </li>
</ol>

</div>
</div>
<a id="afb56a3f59a5490db6fa1b9641d1bbc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb56a3f59a5490db6fa1b9641d1bbc92">&#9670;&nbsp;</a></span>COVER_best_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void COVER_best_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *&#160;</td>
          <td class="paramname"><em>best</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <a class="el" href="zstd_8c.html#a7fc9631879075e9bc967691e50d591d9">COVER_best_wait()</a> and then destroy the COVER_best_t. </p>

</div>
</div>
<a id="a4495a68384f7dcbb049f9880e417bcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4495a68384f7dcbb049f9880e417bcd9">&#9670;&nbsp;</a></span>COVER_best_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void COVER_best_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a>&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a>&#160;</td>
          <td class="paramname"><em>selection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when a thread finishes executing, both on error or success. Decrements liveJobs and signals any waiting threads if liveJobs == 0. If this dictionary is the best so far save it and its parameters. </p>

</div>
</div>
<a id="ad0e0964587f6d04e93bd019b9cfc6d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e0964587f6d04e93bd019b9cfc6d4e">&#9670;&nbsp;</a></span>COVER_best_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void COVER_best_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *&#160;</td>
          <td class="paramname"><em>best</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the <code>COVER_best_t</code>. </p>

</div>
</div>
<a id="a96921521d4c290f9f3b76100f9e4b8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96921521d4c290f9f3b76100f9e4b8aa">&#9670;&nbsp;</a></span>COVER_best_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void COVER_best_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *&#160;</td>
          <td class="paramname"><em>best</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when a thread is about to be launched. Increments liveJobs. </p>

</div>
</div>
<a id="a7fc9631879075e9bc967691e50d591d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc9631879075e9bc967691e50d591d9">&#9670;&nbsp;</a></span>COVER_best_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void COVER_best_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#aaf2609966f31111ad988e3c226013dc2">COVER_best_t</a> *&#160;</td>
          <td class="paramname"><em>best</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until liveJobs == 0. </p>

</div>
</div>
<a id="a7aac36c878428b22365706e321184fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aac36c878428b22365706e321184fa3">&#9670;&nbsp;</a></span>COVER_checkTotalCompressedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t COVER_checkTotalCompressedSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a>&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbTrainSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *const&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictBufferCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks total compressed size of a dictionary </p>

</div>
</div>
<a id="a2e20e2a51007d245a12b3cdff905ef6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e20e2a51007d245a12b3cdff905ef6a">&#9670;&nbsp;</a></span>COVER_computeEpochs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOVER__epoch__info__t.html">COVER_epoch_info_t</a> COVER_computeEpochs </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxDictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>nbDmers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>passes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the number of epochs and the size of each epoch. We will make sure that each epoch gets at least 10 * k bytes.</p>
<p>The COVER algorithms divide the data up into epochs of equal size and select one segment from each epoch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDictSize</td><td>The maximum allowed dictionary size. </td></tr>
    <tr><td class="paramname">nbDmers</td><td>The number of dmers we are training on. </td></tr>
    <tr><td class="paramname">k</td><td>The parameter k (segment size). </td></tr>
    <tr><td class="paramname">passes</td><td>The target number of passes over the dmer corpus. More passes means a better dictionary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bc2ca47eb799aa732a25920b6a89ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc2ca47eb799aa732a25920b6a89ed5">&#9670;&nbsp;</a></span>COVER_dictSelectionError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a> COVER_dictSelectionError </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error function for COVER_selectDict function. Returns a struct where return.totalCompressedSize is a ZSTD error. </p>

</div>
</div>
<a id="a7cfba6966b1c889991b9e5f4b1f0b5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfba6966b1c889991b9e5f4b1f0b5d6">&#9670;&nbsp;</a></span>COVER_dictSelectionFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void COVER_dictSelectionFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a>&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Always call after selectDict is called to free up used memory from newly created dictionary. </p>

</div>
</div>
<a id="a80a65ca984f14545558e223f36996497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a65ca984f14545558e223f36996497">&#9670;&nbsp;</a></span>COVER_dictSelectionIsError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned COVER_dictSelectionIsError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a>&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error function for COVER_selectDict function. Checks if the return value is an error. </p>

</div>
</div>
<a id="a4a0260694c85528f03932ba1d9c96b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0260694c85528f03932ba1d9c96b23">&#9670;&nbsp;</a></span>COVER_selectDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#a3668acc1d146e3367f7f17ea2fb9b10c">COVER_dictSelection_t</a> COVER_selectDict </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>customDictContent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictBufferCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictContentSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>samplesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbFinalizeSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbCheckSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a>&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>totalCompressedSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called to finalize the dictionary and select one based on whether or not the shrink-dict flag was enabled. If enabled the dictionary used is the smallest dictionary within a specified regression of the compressed size from the largest dictionary. </p>

</div>
</div>
<a id="a8d08abe6ce8f3b3af95b93193b46524f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d08abe6ce8f3b3af95b93193b46524f">&#9670;&nbsp;</a></span>COVER_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t COVER_sum </td>
          <td>(</td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the sample sizes. </p>

</div>
</div>
<a id="a418b0fa9785bd766c31ae41e34ce3ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418b0fa9785bd766c31ae41e34ce3ebe">&#9670;&nbsp;</a></span>COVER_warnOnSmallCorpus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void COVER_warnOnSmallCorpus </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxDictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbDmers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>displayLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Warns the user when their corpus is too small. </p>

</div>
</div>
<a id="aed979b095573f0ec58f304d169de5ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed979b095573f0ec58f304d169de5ce9">&#9670;&nbsp;</a></span>divbwt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int divbwt </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>num_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>openMP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs the burrows-wheeler transformed string of a given string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>[0..n-1] The input string. </td></tr>
    <tr><td class="paramname">U</td><td>[0..n-1] The output string. (can be T) </td></tr>
    <tr><td class="paramname">A</td><td>[0..n-1] The temporary array. (can be NULL) </td></tr>
    <tr><td class="paramname">n</td><td>The length of the given string. </td></tr>
    <tr><td class="paramname">num_indexes</td><td>The length of secondary indexes array. (can be NULL) </td></tr>
    <tr><td class="paramname">indexes</td><td>The secondary indexes array. (can be NULL) </td></tr>
    <tr><td class="paramname">openMP</td><td>enables OpenMP optimization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The primary index if no error occurred, -1 or -2 otherwise. </dd></dl>

</div>
</div>
<a id="ad018c2c1a45780704e06793a6533355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad018c2c1a45780704e06793a6533355d">&#9670;&nbsp;</a></span>divsufsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int divsufsort </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>openMP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs the suffix array of a given string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>[0..n-1] The input string. </td></tr>
    <tr><td class="paramname">SA</td><td>[0..n-1] The output array of suffixes. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the given string. </td></tr>
    <tr><td class="paramname">openMP</td><td>enables OpenMP optimization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no error occurred, -1 or -2 otherwise. </dd></dl>

</div>
</div>
<a id="a79a83bf378068974a320feded073de7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a83bf378068974a320feded073de7f">&#9670;&nbsp;</a></span>FSE_buildCTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FSE_PUBLIC_API size_t FSE_buildCTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>normalizedCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tableLog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a79a83bf378068974a320feded073de7f">FSE_buildCTable()</a>: Builds <code>ct</code>, which must be already allocated, using FSE_createCTable(). </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an errorCode, which can be tested using FSE_isError() </dd></dl>

</div>
</div>
<a id="a991b38918a59bfa6ff384fa8d91e5924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991b38918a59bfa6ff384fa8d91e5924">&#9670;&nbsp;</a></span>FSE_buildCTable_rle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_buildCTable_rle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>symbolValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>build a fake FSE_CTable, designed to compress always the same symbolValue </p>

</div>
</div>
<a id="ad5bcb1fb83cf281d2861108119597c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bcb1fb83cf281d2861108119597c7c">&#9670;&nbsp;</a></span>FSE_buildDTable_wksp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_buildDTable_wksp </td>
          <td>(</td>
          <td class="paramtype">FSE_DTable *&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>normalizedCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tableLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wkspSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as FSE_buildDTable(), using an externally allocated <code>workspace</code> produced with <code>FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxSymbolValue)</code> </p>

</div>
</div>
<a id="adcbe336004958f4bb7ba11ca3c847619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbe336004958f4bb7ba11ca3c847619">&#9670;&nbsp;</a></span>FSE_compress_usingCTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_compress_usingCTable </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#adcbe336004958f4bb7ba11ca3c847619">FSE_compress_usingCTable()</a>: Compress <code>src</code> using <code>ct</code> into <code>dst</code> which must be already allocated. </p><dl class="section return"><dt>Returns</dt><dd>: size of compressed data (&lt;= <code>dstCapacity</code>), or 0 if compressed data could not fit into <code>dst</code>, or an errorCode, which can be tested using FSE_isError() </dd></dl>

</div>
</div>
<a id="a8d20cda1c8ed62dbef7b9ce571ce274c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d20cda1c8ed62dbef7b9ce571ce274c">&#9670;&nbsp;</a></span>FSE_decompress_wksp_bmi2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_decompress_wksp_bmi2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cSrcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wkspSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bmi2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as FSE_decompress(), using an externally allocated <code>workSpace</code> produced with <code>FSE_DECOMPRESS_WKSP_SIZE_U32(maxLog, maxSymbolValue)</code>. Set bmi2 to 1 if your CPU supports BMI2 or 0 if it doesn't </p>

</div>
</div>
<a id="a7f2624e273b23c11c129813c95b589e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2624e273b23c11c129813c95b589e3">&#9670;&nbsp;</a></span>FSE_initCState2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void FSE_initCState2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFSE__CState__t.html">FSE_CState_t</a> *&#160;</td>
          <td class="paramname"><em>statePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a7f2624e273b23c11c129813c95b589e3">FSE_initCState2()</a> : Same as FSE_initCState(), but the first symbol to include (which will be the last to be read) uses the smallest state value possible, saving the cost of this symbol </p>

</div>
</div>
<a id="a48aefa84ae52038efc7922d927f998a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48aefa84ae52038efc7922d927f998a9">&#9670;&nbsp;</a></span>FSE_NCountWriteBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_NCountWriteBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tableLog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a48aefa84ae52038efc7922d927f998a9">FSE_NCountWriteBound()</a>: Provides the maximum possible size of an FSE normalized table, given 'maxSymbolValue' and 'tableLog'. Typically useful for allocation purpose. </p>

</div>
</div>
<a id="aab659fb7b05c45be429e56529249b6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab659fb7b05c45be429e56529249b6c4">&#9670;&nbsp;</a></span>FSE_normalizeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_normalizeCount </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>normalizedCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tableLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>useLowProbCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aab659fb7b05c45be429e56529249b6c4">FSE_normalizeCount()</a>: normalize counts so that sum(count[]) == Power_of_2 (2^tableLog) 'normalizedCounter' is a table of short, of minimum size (maxSymbolValue+1). useLowProbCount is a boolean parameter which trades off compressed size for faster header decoding. When it is set to 1, the compressed data will be slightly smaller. And when it is set to 0, <a class="el" href="zstd_8c.html#af0aa1674b1444911966d291da574d5f0">FSE_readNCount()</a> and FSE_buildDTable() will be faster. If you are compressing a small amount of data (&lt; 2 KB) then useLowProbCount=0 is a good default, since header deserialization makes a big speed difference. Otherwise, useLowProbCount=1 is a good default, since the speed difference is small. </p><dl class="section return"><dt>Returns</dt><dd>: tableLog, or an errorCode, which can be tested using FSE_isError() </dd></dl>

</div>
</div>
<a id="ad0fe7dfcc4c27edd4cc0f10d76ff0519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fe7dfcc4c27edd4cc0f10d76ff0519">&#9670;&nbsp;</a></span>FSE_optimalTableLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FSE_optimalTableLog </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxTableLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSE_compress() does the following:</p><ol type="1">
<li>count symbol occurrence from source[] into table count[] (see hist.h)</li>
<li>normalize counters so that sum(count[]) == Power_of_2 (2^tableLog)</li>
<li>save normalized counters to memory buffer using writeNCount()</li>
<li>build encoding table 'CTable' from normalized counters</li>
<li>encode the data stream using encoding table 'CTable'</li>
</ol>
<p>FSE_decompress() does the following:</p><ol type="1">
<li>read normalized counters with readNCount()</li>
<li>build decoding table 'DTable' from normalized counters</li>
<li>decode the data stream using decoding table 'DTable'</li>
</ol>
<p>The following API allows targeting specific sub-functions for advanced tasks. For example, it's possible to compress several blocks using the same 'CTable', or to save and provide normalized distribution using external method.</p>
<p><a class="el" href="zstd_8c.html#ad0fe7dfcc4c27edd4cc0f10d76ff0519">FSE_optimalTableLog()</a>: dynamically downsize 'tableLog' when conditions are met. It saves CPU time, by using smaller tables, while preserving or even improving compression ratio. </p><dl class="section return"><dt>Returns</dt><dd>: recommended tableLog (necessarily &lt;= 'maxTableLog') </dd></dl>

</div>
</div>
<a id="a5b48bd698b011962206908be5c233e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b48bd698b011962206908be5c233e64">&#9670;&nbsp;</a></span>FSE_optimalTableLog_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FSE_optimalTableLog_internal </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxTableLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>minus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as <a class="el" href="zstd_8c.html#ad0fe7dfcc4c27edd4cc0f10d76ff0519">FSE_optimalTableLog()</a>, which used <code>minus==2</code> </p>

</div>
</div>
<a id="af0aa1674b1444911966d291da574d5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0aa1674b1444911966d291da574d5f0">&#9670;&nbsp;</a></span>FSE_readNCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_readNCount </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>normalizedCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>maxSymbolValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>tableLogPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>rBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rBuffSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md5"></a>
Tutorial :</h2>
<p>The first step is to count all symbols. FSE_count() does this job very fast. Result will be saved into 'count', a table of unsigned int, which must be already allocated, and have 'maxSymbolValuePtr[0]+1' cells. 'src' is a table of bytes of size 'srcSize'. All values within 'src' MUST be &lt;= maxSymbolValuePtr[0] maxSymbolValuePtr[0] will be updated, with its real value (necessarily &lt;= original value) FSE_count() will return the number of occurrence of the most frequent symbol. This can be used to know if there is a single symbol within 'src', and to quickly evaluate its compressibility. If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()).</p>
<p>The next step is to normalize the frequencies. <a class="el" href="zstd_8c.html#aab659fb7b05c45be429e56529249b6c4">FSE_normalizeCount()</a> will ensure that sum of frequencies is == 2 ^'tableLog'. It also guarantees a minimum of 1 to any Symbol with frequency &gt;= 1. You can use 'tableLog'==0 to mean "use default tableLog value". If you are unsure of which tableLog value to use, you can ask <a class="el" href="zstd_8c.html#ad0fe7dfcc4c27edd4cc0f10d76ff0519">FSE_optimalTableLog()</a>, which will provide the optimal valid tableLog given sourceSize, maxSymbolValue, and a user-defined maximum (0 means "default").</p>
<p>The result of <a class="el" href="zstd_8c.html#aab659fb7b05c45be429e56529249b6c4">FSE_normalizeCount()</a> will be saved into a table, called 'normalizedCounter', which is a table of signed short. 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValue+1' cells. The return value is tableLog if everything proceeded as expected. It is 0 if there is a single symbol within distribution. If there is an error (ex: invalid tableLog value), the function will return an ErrorCode (which can be tested using FSE_isError()).</p>
<p>'normalizedCounter' can be saved in a compact manner to a memory area using <a class="el" href="zstd_8c.html#ada665be956caa74b8624b7042d289c61">FSE_writeNCount()</a>. 'buffer' must be already allocated. For guaranteed success, buffer size must be at least FSE_headerBound(). The result of the function is the number of bytes written into 'buffer'. If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError(); ex : buffer size too small).</p>
<p>'normalizedCounter' can then be used to create the compression table 'CTable'. The space required by 'CTable' must be already allocated, using FSE_createCTable(). You can then use <a class="el" href="zstd_8c.html#a79a83bf378068974a320feded073de7f">FSE_buildCTable()</a> to fill 'CTable'. If there is an error, both functions will return an ErrorCode (which can be tested using FSE_isError()).</p>
<p>'CTable' can then be used to compress 'src', with <a class="el" href="zstd_8c.html#adcbe336004958f4bb7ba11ca3c847619">FSE_compress_usingCTable()</a>. Similar to FSE_count(), the convention is that 'src' is assumed to be a table of char of size 'srcSize' The function returns the size of compressed data (without header), necessarily &lt;= <code>dstCapacity</code>. If it returns '0', compressed data could not fit into 'dst'. If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()).</p>
<p><a class="el" href="zstd_8c.html#af0aa1674b1444911966d291da574d5f0">FSE_readNCount()</a>: Read compactly saved 'normalizedCounter' from 'rBuffer'. </p><dl class="section return"><dt>Returns</dt><dd>: size read from 'rBuffer', or an errorCode, which can be tested using FSE_isError(). maxSymbolValuePtr[0] and tableLogPtr[0] will also be updated with their respective values </dd></dl>

</div>
</div>
<a id="a7d8802383ab92b90f9c3582be513e4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8802383ab92b90f9c3582be513e4d0">&#9670;&nbsp;</a></span>FSE_readNCount_bmi2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_readNCount_bmi2 </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>normalizedCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>maxSymbolValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>tableLogPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>rBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rBuffSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bmi2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a7d8802383ab92b90f9c3582be513e4d0">FSE_readNCount_bmi2()</a>: Same as <a class="el" href="zstd_8c.html#af0aa1674b1444911966d291da574d5f0">FSE_readNCount()</a> but pass bmi2=1 when your CPU supports BMI2 and 0 otherwise. </p>

</div>
</div>
<a id="aadd4435599681e40d938131f35b71208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd4435599681e40d938131f35b71208">&#9670;&nbsp;</a></span>FSE_versionNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FSE_versionNumber </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>library version number; to be used when checking dll version </p>

</div>
</div>
<a id="ada665be956caa74b8624b7042d289c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada665be956caa74b8624b7042d289c61">&#9670;&nbsp;</a></span>FSE_writeNCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FSE_writeNCount </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>normalizedCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tableLog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ada665be956caa74b8624b7042d289c61">FSE_writeNCount()</a>: Compactly save 'normalizedCounter' into 'buffer'. </p><dl class="section return"><dt>Returns</dt><dd>: size of the compressed table, or an errorCode, which can be tested using FSE_isError(). </dd></dl>

</div>
</div>
<a id="af38f3702c85ebaee0ffa8ee7ac1ffc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38f3702c85ebaee0ffa8ee7ac1ffc4b">&#9670;&nbsp;</a></span>HIST_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HIST_add </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#af38f3702c85ebaee0ffa8ee7ac1ffc4b">HIST_add()</a> : Lowest level: just add nb of occurrences of characters from @src into @count. @count is not reset. @count array is presumed large enough (i.e. 1 KB). @ This function does not need any additional stack memory. </p>

</div>
</div>
<a id="a46dbaaf72547121048940fd59d0e1727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dbaaf72547121048940fd59d0e1727">&#9670;&nbsp;</a></span>HIST_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HIST_count </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>maxSymbolValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a46dbaaf72547121048940fd59d0e1727">HIST_count()</a>: Provides the precise count of each byte within a table 'count'. 'count' is a table of unsigned int, of minimum size (*maxSymbolValuePtr+1). Updates *maxSymbolValuePtr with actual largest symbol value detected. </p><dl class="section return"><dt>Returns</dt><dd>: count of the most frequent symbol (which isn't identified). or an error code, which can be tested using <a class="el" href="zstd_8c.html#a96c2e5928da9e31f5d79543a595ee0fd">HIST_isError()</a>. note : if return == srcSize, there is only one symbol. </dd></dl>

</div>
</div>
<a id="ad90d2ab8d87fa086bed70e192ed7602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90d2ab8d87fa086bed70e192ed7602b">&#9670;&nbsp;</a></span>HIST_count_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned HIST_count_simple </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>maxSymbolValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ad90d2ab8d87fa086bed70e192ed7602b">HIST_count_simple()</a> : Same as <a class="el" href="zstd_8c.html#a786e489f8396de1fbadacb8a322e1740">HIST_countFast()</a>, this function is unsafe, and will segfault if any value within <code>src</code> is <code>&gt; *maxSymbolValuePtr</code>. It is also a bit slower for large inputs. However, it does not need any additional memory (not even on stack). </p><dl class="section return"><dt>Returns</dt><dd>: count of the most frequent symbol. Note this function doesn't produce any error (i.e. it must succeed). </dd></dl>

</div>
</div>
<a id="a46ab7952432d609b1da77ac0a3506425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ab7952432d609b1da77ac0a3506425">&#9670;&nbsp;</a></span>HIST_count_wksp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HIST_count_wksp </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>maxSymbolValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSpaceSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a46ab7952432d609b1da77ac0a3506425">HIST_count_wksp()</a> : Same as <a class="el" href="zstd_8c.html#a46dbaaf72547121048940fd59d0e1727">HIST_count()</a>, but using an externally provided scratch buffer. Benefit is this function will use very little stack space. <code>workSpace</code> is a writable buffer which must be 4-bytes aligned, <code>workSpaceSize</code> must be &gt;= HIST_WKSP_SIZE </p>

</div>
</div>
<a id="a786e489f8396de1fbadacb8a322e1740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786e489f8396de1fbadacb8a322e1740">&#9670;&nbsp;</a></span>HIST_countFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HIST_countFast </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>maxSymbolValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a786e489f8396de1fbadacb8a322e1740">HIST_countFast()</a> : same as <a class="el" href="zstd_8c.html#a46dbaaf72547121048940fd59d0e1727">HIST_count()</a>, but blindly trusts that all byte values within src are &lt;= *maxSymbolValuePtr. This function is unsafe, and will segfault if any value within <code>src</code> is <code>&gt; *maxSymbolValuePtr</code> </p>

</div>
</div>
<a id="ab1a8bb4116cae3ba238217110a833f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a8bb4116cae3ba238217110a833f03">&#9670;&nbsp;</a></span>HIST_countFast_wksp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HIST_countFast_wksp </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>maxSymbolValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSpaceSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ab1a8bb4116cae3ba238217110a833f03">HIST_countFast_wksp()</a> : Same as <a class="el" href="zstd_8c.html#a786e489f8396de1fbadacb8a322e1740">HIST_countFast()</a>, but using an externally provided scratch buffer. <code>workSpace</code> is a writable buffer which must be 4-bytes aligned, <code>workSpaceSize</code> must be &gt;= HIST_WKSP_SIZE </p>

</div>
</div>
<a id="a96c2e5928da9e31f5d79543a595ee0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c2e5928da9e31f5d79543a595ee0fd">&#9670;&nbsp;</a></span>HIST_isError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned HIST_isError </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>tells if a return value is an error code </p>

</div>
</div>
<a id="abd3ef7f6d6f019c23b27a79c73118850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3ef7f6d6f019c23b27a79c73118850">&#9670;&nbsp;</a></span>HUF_addBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void HUF_addBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HUF_CElt&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kFast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#abd3ef7f6d6f019c23b27a79c73118850">HUF_addBits()</a>: Adds the symbol stored in HUF_CElt elt to the bitstream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>The element we're adding. This is a (nbBits, value) pair. See the <a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> docs for the format. </td></tr>
    <tr><td class="paramname">idx</td><td>Insert into the bitstream at this idx. </td></tr>
    <tr><td class="paramname">kFast</td><td>This is a template parameter. If the bitstream is guaranteed to have at least 4 unused bits after this call it may be 1, otherwise it must be 0. <a class="el" href="zstd_8c.html#abd3ef7f6d6f019c23b27a79c73118850">HUF_addBits()</a> is faster when fast is set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d14775f9d3b42768c9c96dbd454f8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d14775f9d3b42768c9c96dbd454f8ad">&#9670;&nbsp;</a></span>HUF_compress1X_repeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HUF_compress1X_repeat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tableLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wkspSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HUF_CElt *&#160;</td>
          <td class="paramname"><em>hufTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29">HUF_repeat</a> *&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a8d14775f9d3b42768c9c96dbd454f8ad">HUF_compress1X_repeat()</a> : Same as HUF_compress1X_wksp(), but considers using hufTable if *repeat != HUF_repeat_none. If it uses hufTable it does not modify hufTable or repeat. If it doesn't, it sets *repeat = HUF_repeat_none, and it sets hufTable to the table used. If preferRepeat then the old table will always be used if valid. If suspectUncompressible then some sampling checks will be run to potentially skip huffman coding </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wkspSize</td><td>`workSpace` must be aligned on 4-bytes boundaries, `wkspSize` must be &gt;= HUF_WORKSPACE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3feaf945233beb32ccd701396732e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3feaf945233beb32ccd701396732e93">&#9670;&nbsp;</a></span>HUF_compress4X_repeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HUF_compress4X_repeat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSymbolValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tableLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wkspSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HUF_CElt *&#160;</td>
          <td class="paramname"><em>hufTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#aea428e39b157d5f4d9bc03d030708c29">HUF_repeat</a> *&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ad3feaf945233beb32ccd701396732e93">HUF_compress4X_repeat()</a> : Same as HUF_compress4X_wksp(), but considers using hufTable if *repeat != HUF_repeat_none. If it uses hufTable it does not modify hufTable or repeat. If it doesn't, it sets *repeat = HUF_repeat_none, and it sets hufTable to the table used. If preferRepeat then the old table will always be used if valid. If suspectUncompressible then some sampling checks will be run to potentially skip huffman coding </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wkspSize</td><td>`workSpace` must be aligned on 4-bytes boundaries, `wkspSize` must be &gt;= HUF_WORKSPACE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d59eb211fff5bdf33704f563fe93af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d59eb211fff5bdf33704f563fe93af0">&#9670;&nbsp;</a></span>HUF_compressBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HUF_compressBound </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum compressed size (worst case) </p>

</div>
</div>
<a id="a982c2fd95349e7646ef99ca4e2e256fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982c2fd95349e7646ef99ca4e2e256fa">&#9670;&nbsp;</a></span>HUF_decompress1X2_DCtx_wksp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HUF_decompress1X2_DCtx_wksp </td>
          <td>(</td>
          <td class="paramtype">HUF_DTable *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cSrcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wkspSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>double-symbols decoder </p>

</div>
</div>
<a id="ac1fc656720e8cbcbf0b7a0a938bc26fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fc656720e8cbcbf0b7a0a938bc26fb">&#9670;&nbsp;</a></span>HUF_flushBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void HUF_flushBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kFast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ac1fc656720e8cbcbf0b7a0a938bc26fb">HUF_flushBits()</a> : Flushes the bits in the bit container @ index 0.</p>
<dl class="section post"><dt>Postcondition</dt><dd>bitPos will be &lt; 8. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kFast</td><td>If kFast is set then we must know a-priori that the bit container will not overflow. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2058676a94d9959e656bd0024e7fde97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2058676a94d9959e656bd0024e7fde97">&#9670;&nbsp;</a></span>HUF_getErrorName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * HUF_getErrorName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>provides error code string (useful for debugging) </p>

</div>
</div>
<a id="a5be050c0196368a09d7c1a678ef3d5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be050c0196368a09d7c1a678ef3d5dc">&#9670;&nbsp;</a></span>HUF_getNbBitsFromCTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 HUF_getNbBitsFromCTable </td>
          <td>(</td>
          <td class="paramtype">const HUF_CElt *&#160;</td>
          <td class="paramname"><em>symbolTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>symbolValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a5be050c0196368a09d7c1a678ef3d5dc">HUF_getNbBitsFromCTable()</a> : Read nbBits from CTable symbolTable, for symbol <code>symbolValue</code> presumed &lt;= HUF_SYMBOLVALUE_MAX Note 1 : If symbolValue &gt; HUF_readCTableHeader(symbolTable).maxSymbolValue, returns 0 Note 2 : is not inlined, as HUF_CElt definition is private </p>

</div>
</div>
<a id="abd113fa90a875ceddf133a530db912bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd113fa90a875ceddf133a530db912bc">&#9670;&nbsp;</a></span>HUF_isError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned HUF_isError </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>tells if a return value is an error code </p>

</div>
</div>
<a id="a7db3be6d7198e3ef6601d8e14102f5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db3be6d7198e3ef6601d8e14102f5e8">&#9670;&nbsp;</a></span>HUF_mergeIndex1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void HUF_mergeIndex1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHUF__CStream__t.html">HUF_CStream_t</a> *&#160;</td>
          <td class="paramname"><em>bitC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a7db3be6d7198e3ef6601d8e14102f5e8">HUF_mergeIndex1()</a> : Merges the bit container @ index 1 into the bit container @ index 0 and zeros the bit container @ index 1. </p>

</div>
</div>
<a id="aec0c5354df5c8948fd993a96adf3bb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0c5354df5c8948fd993a96adf3bb29">&#9670;&nbsp;</a></span>HUF_minTableLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned HUF_minTableLog </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>symbolCardinality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HUF_compress() does the following:</p><ol type="1">
<li>count symbol occurrence from source[] into table count[] using FSE_count() (exposed within "fse.h")</li>
<li>(optional) refine tableLog using HUF_optimalTableLog()</li>
<li>build Huffman table from count using HUF_buildCTable()</li>
<li>save Huffman table to memory buffer using HUF_writeCTable()</li>
<li>encode the data stream using HUF_compress4X_usingCTable()</li>
</ol>
<p>The following API allows targeting specific sub-functions for advanced tasks. For example, it's possible to compress several blocks using the same 'CTable', or to save and regenerate 'CTable' using external methods. </p>

</div>
</div>
<a id="ae84c68f7351a48d41314ccf7343fd00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84c68f7351a48d41314ccf7343fd00f">&#9670;&nbsp;</a></span>HUF_readCTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HUF_readCTable </td>
          <td>(</td>
          <td class="paramtype">HUF_CElt *&#160;</td>
          <td class="paramname"><em>CTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>maxSymbolValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>hasZeroWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ae84c68f7351a48d41314ccf7343fd00f">HUF_readCTable()</a> : Loading a CTable saved with HUF_writeCTable() </p>

</div>
</div>
<a id="ac3488ca1538a51b4c89f28fbcd493939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3488ca1538a51b4c89f28fbcd493939">&#9670;&nbsp;</a></span>HUF_readCTableHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHUF__CTableHeader.html">HUF_CTableHeader</a> HUF_readCTableHeader </td>
          <td>(</td>
          <td class="paramtype">HUF_CElt const *&#160;</td>
          <td class="paramname"><em>ctable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ac3488ca1538a51b4c89f28fbcd493939">HUF_readCTableHeader()</a> : </p><dl class="section return"><dt>Returns</dt><dd>The header from the CTable specifying the tableLog and the maxSymbolValue. </dd></dl>

</div>
</div>
<a id="abe44467e2590965c0dafba8df4d206c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe44467e2590965c0dafba8df4d206c0">&#9670;&nbsp;</a></span>HUF_readStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HUF_readStats </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>huffWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hwSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>rankStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>nbSymbolsPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>tableLogPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#abe44467e2590965c0dafba8df4d206c0">HUF_readStats()</a> : Read compact Huffman tree, saved by HUF_writeCTable(). <code>huffWeight</code> is destination buffer. </p><dl class="section return"><dt>Returns</dt><dd>: size read from <code>src</code> , or an error Code . Note : Needed by <a class="el" href="zstd_8c.html#ae84c68f7351a48d41314ccf7343fd00f">HUF_readCTable()</a> and HUF_readDTableXn() .</dd></dl>
<p><a class="el" href="zstd_8c.html#abe44467e2590965c0dafba8df4d206c0">HUF_readStats()</a> : Read compact Huffman tree, saved by HUF_writeCTable(). <code>huffWeight</code> is destination buffer. <code>rankStats</code> is assumed to be a table of at least HUF_TABLELOG_MAX U32. </p><dl class="section return"><dt>Returns</dt><dd>: size read from <code>src</code> , or an error Code . Note : Needed by <a class="el" href="zstd_8c.html#ae84c68f7351a48d41314ccf7343fd00f">HUF_readCTable()</a> and HUF_readDTableX?() . </dd></dl>

</div>
</div>
<a id="a319db2a71decf1639479172cc19c7e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319db2a71decf1639479172cc19c7e6b">&#9670;&nbsp;</a></span>HUF_selectDecoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 HUF_selectDecoder </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a319db2a71decf1639479172cc19c7e6b">HUF_selectDecoder()</a> : Tells which decoder is likely to decode faster, based on a set of pre-computed metrics. </p><dl class="section return"><dt>Returns</dt><dd>: 0==HUF_decompress4X1, 1==HUF_decompress4X2 . Assumption : 0 &lt; dstSize &lt;= 128 KB </dd></dl>

</div>
</div>
<a id="a9e76d52639b0b67a406728d425ba32d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e76d52639b0b67a406728d425ba32d8">&#9670;&nbsp;</a></span>POOL_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void POOL_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a657f7753ec82fce04c212f38d9c58e61">POOL_function</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9e76d52639b0b67a406728d425ba32d8">POOL_add()</a> : Add the job <code>function(opaque)</code> to the thread pool. <code>ctx</code> must be valid. Possibly blocks until there is room in the queue. Note : The function may be executed asynchronously, therefore, <code>opaque</code> must live until function has been completed. </p>

</div>
</div>
<a id="a05016dd101d21fdc429f76c78cdbb236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05016dd101d21fdc429f76c78cdbb236">&#9670;&nbsp;</a></span>POOL_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> * POOL_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>queueSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a05016dd101d21fdc429f76c78cdbb236">POOL_create()</a> : Create a thread pool with at most <code>numThreads</code> threads. <code>numThreads</code> must be at least 1. The maximum number of queued jobs before blocking is <code>queueSize</code>. </p><dl class="section return"><dt>Returns</dt><dd>: POOL_ctx pointer on success, else NULL. </dd></dl>

</div>
</div>
<a id="aa4303d0084a4b529708500c2eb4ed341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4303d0084a4b529708500c2eb4ed341">&#9670;&nbsp;</a></span>POOL_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void POOL_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aa4303d0084a4b529708500c2eb4ed341">POOL_free()</a> : Free a thread pool returned by <a class="el" href="zstd_8c.html#a05016dd101d21fdc429f76c78cdbb236">POOL_create()</a>. </p>

</div>
</div>
<a id="ad822a2ce1a25429021571168b81a0fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad822a2ce1a25429021571168b81a0fb8">&#9670;&nbsp;</a></span>POOL_joinJobs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void POOL_joinJobs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ad822a2ce1a25429021571168b81a0fb8">POOL_joinJobs()</a> : Waits for all queued jobs to finish executing. </p>

</div>
</div>
<a id="a39fdba7fe95ecb80063409162667b017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fdba7fe95ecb80063409162667b017">&#9670;&nbsp;</a></span>POOL_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int POOL_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a39fdba7fe95ecb80063409162667b017">POOL_resize()</a> : Expands or shrinks pool's number of threads. This is more efficient than releasing + creating a new context, since it tries to preserve and reuse existing threads. <code>numThreads</code> must be at least 1. </p><dl class="section return"><dt>Returns</dt><dd>: 0 when resize was successful, !0 (typically 1) if there is an error. note : only numThreads can be resized, queueSize remains unchanged. </dd></dl>

</div>
</div>
<a id="aa35eac29d884213562eb548b072404bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35eac29d884213562eb548b072404bd">&#9670;&nbsp;</a></span>POOL_sizeof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t POOL_sizeof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aa35eac29d884213562eb548b072404bd">POOL_sizeof()</a> : </p><dl class="section return"><dt>Returns</dt><dd>threadpool memory usage note : compatible with NULL (returns 0 in this case) </dd></dl>

</div>
</div>
<a id="afcee4187d26bc6387494caf7fb3b59cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcee4187d26bc6387494caf7fb3b59cd">&#9670;&nbsp;</a></span>POOL_tryAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int POOL_tryAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPOOL__ctx__s.html">POOL_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a657f7753ec82fce04c212f38d9c58e61">POOL_function</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#afcee4187d26bc6387494caf7fb3b59cd">POOL_tryAdd()</a> : Add the job <code>function(opaque)</code> to thread pool <em>if</em> a queue slot is available. Returns immediately even if not (does not block). </p><dl class="section return"><dt>Returns</dt><dd>: 1 if successful, 0 if not. </dd></dl>

</div>
</div>
<a id="a46a23d9e733292199bfea09ad51ab5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a23d9e733292199bfea09ad51ab5cc">&#9670;&nbsp;</a></span>ZDICT_finalizeDictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZDICT_finalizeDictionary </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstDictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxDictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dictContent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictContentSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>samplesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZDICT__params__t.html">ZDICT_params_t</a>&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a46a23d9e733292199bfea09ad51ab5cc">ZDICT_finalizeDictionary()</a>: Given a custom content as a basis for dictionary, and a set of samples, finalize dictionary by adding headers and statistics according to the zstd dictionary format.</p>
<p>Samples must be stored concatenated in a flat buffer <code>samplesBuffer</code>, supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample in order. The samples are used to construct the statistics, so they should be representative of what you will compress with this dictionary.</p>
<p>The compression level can be set in <code>parameters</code>. You should pass the compression level you expect to use in production. The statistics for each compression level differ, so tuning the dictionary for the compression level can help quite a bit.</p>
<p>You can set an explicit dictionary ID in <code>parameters</code>, or allow us to pick a random dictionary ID for you, but we can't guarantee no collisions.</p>
<p>The dstDictBuffer and the dictContent may overlap, and the content will be appended to the end of the header. If the header + the content doesn't fit in maxDictSize the beginning of the content is truncated to make room, since it is presumed that the most profitable content is at the end of the dictionary, since that is the cheapest to reference.</p>
<p><code>maxDictSize</code> must be &gt;= max(dictContentSize, ZDICT_DICTSIZE_MIN).</p>
<dl class="section return"><dt>Returns</dt><dd>: size of dictionary stored into <code>dstDictBuffer</code> (&lt;= <code>maxDictSize</code>), or an error code, which can be tested by ZDICT_isError(). Note: <a class="el" href="zstd_8c.html#a46a23d9e733292199bfea09ad51ab5cc">ZDICT_finalizeDictionary()</a> will push notifications into stderr if instructed to, using notificationLevel&gt;0. NOTE: This function currently may fail in several edge cases including:<ul>
<li>Not enough samples</li>
<li>Samples are uncompressible</li>
<li>Samples are all exactly the same </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6d7b7d6bba8f42da1ae3227017499dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7b7d6bba8f42da1ae3227017499dd5">&#9670;&nbsp;</a></span>ZDICT_getDictID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZDICT_getDictID </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>extracts dictID; </p><dl class="section return"><dt>Returns</dt><dd>zero if error (not a valid dictionary) </dd></dl>

</div>
</div>
<a id="a406f163e4ae6882df80bb1977fd32faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406f163e4ae6882df80bb1977fd32faa">&#9670;&nbsp;</a></span>ZDICT_optimizeTrainFromBuffer_cover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ZDICTLIB_STATIC_API size_t ZDICT_optimizeTrainFromBuffer_cover </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictBufferCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>samplesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a406f163e4ae6882df80bb1977fd32faa">ZDICT_optimizeTrainFromBuffer_cover()</a>: The same requirements as above hold for all the parameters except <code>parameters</code>. This function tries many parameter combinations and picks the best parameters. <code>*parameters</code> is filled with the best parameters found, dictionary constructed with those parameters is stored in <code>dictBuffer</code>.</p>
<p>All of the parameters d, k, steps are optional. If d is non-zero then we don't check multiple values of d, otherwise we check d = {6, 8}. if steps is zero it defaults to its default value. If k is non-zero then we don't check multiple values of k, otherwise we check steps values in [50, 2000].</p>
<dl class="section return"><dt>Returns</dt><dd>: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>) or an error code, which can be tested with ZDICT_isError(). On success <code>*parameters</code> contains the parameters selected. See <a class="el" href="zstd_8c.html#a705dc14081aec26178b8adf718a2e364">ZDICT_trainFromBuffer()</a> for details on failure modes. Note: <a class="el" href="zstd_8c.html#a406f163e4ae6882df80bb1977fd32faa">ZDICT_optimizeTrainFromBuffer_cover()</a> requires about 8 bytes of memory for each input byte and additionally another 5 bytes of memory for each byte of memory for each thread. </dd></dl>

</div>
</div>
<a id="afc6697e8cd583f6dd13203747bac8784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6697e8cd583f6dd13203747bac8784">&#9670;&nbsp;</a></span>ZDICT_optimizeTrainFromBuffer_fastCover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ZDICTLIB_STATIC_API size_t ZDICT_optimizeTrainFromBuffer_fastCover </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictBufferCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>samplesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZDICT__fastCover__params__t.html">ZDICT_fastCover_params_t</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#afc6697e8cd583f6dd13203747bac8784">ZDICT_optimizeTrainFromBuffer_fastCover()</a>: The same requirements as above hold for all the parameters except <code>parameters</code>. This function tries many parameter combinations (specifically, k and d combinations) and picks the best parameters. <code>*parameters</code> is filled with the best parameters found, dictionary constructed with those parameters is stored in <code>dictBuffer</code>. All of the parameters d, k, steps, f, and accel are optional. If d is non-zero then we don't check multiple values of d, otherwise we check d = {6, 8}. if steps is zero it defaults to its default value. If k is non-zero then we don't check multiple values of k, otherwise we check steps values in [50, 2000]. If f is zero, default value of 20 is used. If accel is zero, default value of 1 is used.</p>
<dl class="section return"><dt>Returns</dt><dd>: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>) or an error code, which can be tested with ZDICT_isError(). On success <code>*parameters</code> contains the parameters selected. See <a class="el" href="zstd_8c.html#a705dc14081aec26178b8adf718a2e364">ZDICT_trainFromBuffer()</a> for details on failure modes. Note: <a class="el" href="zstd_8c.html#afc6697e8cd583f6dd13203747bac8784">ZDICT_optimizeTrainFromBuffer_fastCover()</a> requires about 6 * 2^f bytes of memory for each thread. </dd></dl>

</div>
</div>
<a id="a705dc14081aec26178b8adf718a2e364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705dc14081aec26178b8adf718a2e364">&#9670;&nbsp;</a></span>ZDICT_trainFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZDICT_trainFromBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictBufferCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>samplesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a705dc14081aec26178b8adf718a2e364">ZDICT_trainFromBuffer()</a>: Train a dictionary from an array of samples. Redirect towards <a class="el" href="zstd_8c.html#afc6697e8cd583f6dd13203747bac8784">ZDICT_optimizeTrainFromBuffer_fastCover()</a> single-threaded, with d=8, steps=4, f=20, and accel=1. Samples must be stored concatenated in a single flat buffer <code>samplesBuffer</code>, supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample, in order. The resulting dictionary will be saved into <code>dictBuffer</code>. </p><dl class="section return"><dt>Returns</dt><dd>: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>) or an error code, which can be tested with ZDICT_isError(). Note: Dictionary training will fail if there are not enough samples to construct a dictionary, or if most of the samples are too small (&lt; 8 bytes being the lower limit). If dictionary training fails, you should use zstd without a dictionary, as the dictionary would've been ineffective anyways. If you believe your samples would benefit from a dictionary please open an issue with details, and we can look into it. Note: <a class="el" href="zstd_8c.html#a705dc14081aec26178b8adf718a2e364">ZDICT_trainFromBuffer()</a>'s memory usage is about 6 MB. Tips: In general, a reasonable dictionary has a size of ~ 100 KB. It's possible to select smaller or larger size, just by specifying <code>dictBufferCapacity</code>. In general, it's recommended to provide a few thousands samples, though this can vary a lot. It's recommended that total size of all samples be about ~x100 times the target size of dictionary. </dd></dl>

</div>
</div>
<a id="a0bbe22fd624699873d08d2e65671f38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbe22fd624699873d08d2e65671f38d">&#9670;&nbsp;</a></span>ZDICT_trainFromBuffer_cover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ZDICTLIB_STATIC_API size_t ZDICT_trainFromBuffer_cover </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictBufferCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>samplesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZDICT__cover__params__t.html">ZDICT_cover_params_t</a>&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a0bbe22fd624699873d08d2e65671f38d">ZDICT_trainFromBuffer_cover()</a>: Train a dictionary from an array of samples using the COVER algorithm. Samples must be stored concatenated in a single flat buffer <code>samplesBuffer</code>, supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample, in order. The resulting dictionary will be saved into <code>dictBuffer</code>. </p><dl class="section return"><dt>Returns</dt><dd>: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>) or an error code, which can be tested with ZDICT_isError(). See <a class="el" href="zstd_8c.html#a705dc14081aec26178b8adf718a2e364">ZDICT_trainFromBuffer()</a> for details on failure modes. Note: <a class="el" href="zstd_8c.html#a0bbe22fd624699873d08d2e65671f38d">ZDICT_trainFromBuffer_cover()</a> requires about 9 bytes of memory for each input byte. Tips: In general, a reasonable dictionary has a size of ~ 100 KB. It's possible to select smaller or larger size, just by specifying <code>dictBufferCapacity</code>. In general, it's recommended to provide a few thousands samples, though this can vary a lot. It's recommended that total size of all samples be about ~x100 times the target size of dictionary. </dd></dl>

</div>
</div>
<a id="a63856626332ea4a30258e11723bdae06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63856626332ea4a30258e11723bdae06">&#9670;&nbsp;</a></span>ZDICT_trainFromBuffer_fastCover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ZDICTLIB_STATIC_API size_t ZDICT_trainFromBuffer_fastCover </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictBufferCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>samplesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZDICT__fastCover__params__t.html">ZDICT_fastCover_params_t</a>&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a63856626332ea4a30258e11723bdae06">ZDICT_trainFromBuffer_fastCover()</a>: Train a dictionary from an array of samples using a modified version of COVER algorithm. Samples must be stored concatenated in a single flat buffer <code>samplesBuffer</code>, supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample, in order. d and k are required. All other parameters are optional, will use default values if not provided The resulting dictionary will be saved into <code>dictBuffer</code>. </p><dl class="section return"><dt>Returns</dt><dd>: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>) or an error code, which can be tested with ZDICT_isError(). See <a class="el" href="zstd_8c.html#a705dc14081aec26178b8adf718a2e364">ZDICT_trainFromBuffer()</a> for details on failure modes. Note: <a class="el" href="zstd_8c.html#a63856626332ea4a30258e11723bdae06">ZDICT_trainFromBuffer_fastCover()</a> requires 6 * 2^f bytes of memory. Tips: In general, a reasonable dictionary has a size of ~ 100 KB. It's possible to select smaller or larger size, just by specifying <code>dictBufferCapacity</code>. In general, it's recommended to provide a few thousands samples, though this can vary a lot. It's recommended that total size of all samples be about ~x100 times the target size of dictionary. </dd></dl>

</div>
</div>
<a id="a1b7b5f4ffc5627bac43f8675dc587ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7b5f4ffc5627bac43f8675dc587ea4">&#9670;&nbsp;</a></span>ZDICT_trainFromBuffer_legacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZDICT_trainFromBuffer_legacy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictBufferCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>samplesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>samplesSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZDICT__legacy__params__t.html">ZDICT_legacy_params_t</a>&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a1b7b5f4ffc5627bac43f8675dc587ea4">ZDICT_trainFromBuffer_legacy()</a>: Train a dictionary from an array of samples. Samples must be stored concatenated in a single flat buffer <code>samplesBuffer</code>, supplied with an array of sizes <code>samplesSizes</code>, providing the size of each sample, in order. The resulting dictionary will be saved into <code>dictBuffer</code>. <code>parameters</code> is optional and can be provided with values set to 0 to mean "default". </p><dl class="section return"><dt>Returns</dt><dd>: size of dictionary stored into <code>dictBuffer</code> (&lt;= <code>dictBufferCapacity</code>) or an error code, which can be tested with ZDICT_isError(). See <a class="el" href="zstd_8c.html#a705dc14081aec26178b8adf718a2e364">ZDICT_trainFromBuffer()</a> for details on failure modes. Tips: In general, a reasonable dictionary has a size of ~ 100 KB. It's possible to select smaller or larger size, just by specifying <code>dictBufferCapacity</code>. In general, it's recommended to provide a few thousands samples, though this can vary a lot. It's recommended that total size of all samples be about ~x100 times the target size of dictionary. Note: <a class="el" href="zstd_8c.html#a1b7b5f4ffc5627bac43f8675dc587ea4">ZDICT_trainFromBuffer_legacy()</a> will send notifications into stderr if instructed to, using notificationLevel&gt;0. </dd></dl>

</div>
</div>
<a id="a788dffccbc0311102d8967c19ef9ab00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788dffccbc0311102d8967c19ef9ab00">&#9670;&nbsp;</a></span>ZSTD_adjustCParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> ZSTD_adjustCParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td>
          <td class="paramname"><em>cPar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a788dffccbc0311102d8967c19ef9ab00">ZSTD_adjustCParams()</a> : optimize params for a given <code>srcSize</code> and <code>dictSize</code>. <code>srcSize</code> can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN. <code>dictSize</code> must be <code>0</code> when there is no dictionary. cPar can be invalid : all parameters will be clamped within valid range in the </p><dl class="section return"><dt>Returns</dt><dd>struct. This function never fails (wide contract) </dd></dl>

</div>
</div>
<a id="afd10da54840c09ebe9e65c70abf28bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd10da54840c09ebe9e65c70abf28bd5">&#9670;&nbsp;</a></span>ZSTD_BtFindBestMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t ZSTD_BtFindBestMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *const&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *const&#160;</td>
          <td class="paramname"><em>iLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offBasePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U32&#160;</td>
          <td class="paramname"><em>mls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ZSTD_dictMode_e&#160;</td>
          <td class="paramname"><em>dictMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#afd10da54840c09ebe9e65c70abf28bd5">ZSTD_BtFindBestMatch()</a> : Tree updater, providing best match </p>

</div>
</div>
<a id="a21d0135361a97baeba2bedde58c1acca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d0135361a97baeba2bedde58c1acca">&#9670;&nbsp;</a></span>ZSTD_buildBlockEntropyStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_buildBlockEntropyStats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSeqStore__t.html">SeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>seqStorePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__entropyCTables__t.html">ZSTD_entropyCTables_t</a> *&#160;</td>
          <td class="paramname"><em>prevEntropy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__entropyCTables__t.html">ZSTD_entropyCTables_t</a> *&#160;</td>
          <td class="paramname"><em>nextEntropy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>cctxParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__entropyCTablesMetadata__t.html">ZSTD_entropyCTablesMetadata_t</a> *&#160;</td>
          <td class="paramname"><em>entropyMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wkspSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a21d0135361a97baeba2bedde58c1acca">ZSTD_buildBlockEntropyStats()</a> : Builds entropy for the block. </p><dl class="section return"><dt>Returns</dt><dd>: 0 on success or error code</dd></dl>
<p><a class="el" href="zstd_8c.html#a21d0135361a97baeba2bedde58c1acca">ZSTD_buildBlockEntropyStats()</a> : Builds entropy for the block. Requires workspace size ENTROPY_WORKSPACE_SIZE </p><dl class="section return"><dt>Returns</dt><dd>: 0 on success, or an error code Note : also employed in superblock </dd></dl>

</div>
</div>
<a id="ab714f666f79d800d7e9f41334bb46c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab714f666f79d800d7e9f41334bb46c40">&#9670;&nbsp;</a></span>ZSTD_CCtx_getParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_getParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_cParameter&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ab714f666f79d800d7e9f41334bb46c40">ZSTD_CCtx_getParameter()</a> : Get the requested compression parameter value, selected by enum ZSTD_cParameter, and store it into int* value. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a9f03e49aafdf252d4e9a10fdee0db68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f03e49aafdf252d4e9a10fdee0db68b">&#9670;&nbsp;</a></span>ZSTD_CCtx_loadDictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_loadDictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9f03e49aafdf252d4e9a10fdee0db68b">ZSTD_CCtx_loadDictionary()</a> : Requires v1.4.0+ Create an internal CDict from <code>dict</code> buffer. Decompression will have to use same dictionary. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary, meaning "return to no-dictionary mode". Note 1 : Dictionary is sticky, it will be used for all future compressed frames, until parameters are reset, a new dictionary is loaded, or the dictionary is explicitly invalidated by loading a NULL dictionary. Note 2 : Loading a dictionary involves building tables. It's also a CPU consuming operation, with non-negligible impact on latency. Tables are dependent on compression parameters, and for this reason, compression parameters can no longer be changed after loading a dictionary. Note 3 :<code>dict</code> content will be copied internally. Use experimental <a class="el" href="zstd_8c.html#a62e1c921172c34cfaaad95ffc265d519">ZSTD_CCtx_loadDictionary_byReference()</a> to reference content instead. In such a case, dictionary buffer must outlive its users. Note 4 : Use <a class="el" href="zstd_8c.html#ae8c3c12ac624808016b5d8d0fb88bf84">ZSTD_CCtx_loadDictionary_advanced()</a> to precisely select how dictionary content must be interpreted. Note 5 : This method does not benefit from LDM (long distance mode). If you want to employ LDM on some large dictionary content, prefer employing <a class="el" href="zstd_8c.html#a178ca3471ba2633b712683b3d6bea5f2">ZSTD_CCtx_refPrefix()</a> described below. </dd></dl>

</div>
</div>
<a id="ae8c3c12ac624808016b5d8d0fb88bf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c3c12ac624808016b5d8d0fb88bf84">&#9670;&nbsp;</a></span>ZSTD_CCtx_loadDictionary_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_loadDictionary_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a>&#160;</td>
          <td class="paramname"><em>dictLoadMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dictContentType_e&#160;</td>
          <td class="paramname"><em>dictContentType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ae8c3c12ac624808016b5d8d0fb88bf84">ZSTD_CCtx_loadDictionary_advanced()</a> : Same as <a class="el" href="zstd_8c.html#a9f03e49aafdf252d4e9a10fdee0db68b">ZSTD_CCtx_loadDictionary()</a>, but gives finer control over how to load the dictionary (by copy ? by reference ?) and how to interpret it (automatic ? force raw mode ? full mode only ?) </p>

</div>
</div>
<a id="a62e1c921172c34cfaaad95ffc265d519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e1c921172c34cfaaad95ffc265d519">&#9670;&nbsp;</a></span>ZSTD_CCtx_loadDictionary_byReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_loadDictionary_byReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a62e1c921172c34cfaaad95ffc265d519">ZSTD_CCtx_loadDictionary_byReference()</a> : Same as <a class="el" href="zstd_8c.html#a9f03e49aafdf252d4e9a10fdee0db68b">ZSTD_CCtx_loadDictionary()</a>, but dictionary content is referenced, instead of being copied into CCtx. It saves some memory, but also requires that <code>dict</code> outlives its usage within <code>cctx</code> </p>

</div>
</div>
<a id="a6ae3427f20d2276510d9a69db51e7d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3427f20d2276510d9a69db51e7d85">&#9670;&nbsp;</a></span>ZSTD_CCtx_refCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_refCDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a6ae3427f20d2276510d9a69db51e7d85">ZSTD_CCtx_refCDict()</a> : Requires v1.4.0+ Reference a prepared dictionary, to be used for all future compressed frames. Note that compression parameters are enforced from within CDict, and supersede any compression parameter previously set within CCtx. The parameters ignored are labelled as "superseded-by-cdict" in the ZSTD_cParameter enum docs. The ignored parameters will be used again if the CCtx is returned to no-dictionary mode. The dictionary will remain valid for future compressed frames using same CCtx. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). Special : Referencing a NULL CDict means "return to no-dictionary mode". Note 1 : Currently, only one dictionary can be managed. Referencing a new dictionary effectively "discards" any previous one. Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx. </dd></dl>

</div>
</div>
<a id="a178ca3471ba2633b712683b3d6bea5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178ca3471ba2633b712683b3d6bea5f2">&#9670;&nbsp;</a></span>ZSTD_CCtx_refPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_refPrefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prefixSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a178ca3471ba2633b712683b3d6bea5f2">ZSTD_CCtx_refPrefix()</a> : Requires v1.4.0+ Reference a prefix (single-usage dictionary) for next compressed frame. A prefix is <b>only used once</b>. Tables are discarded at end of frame (ZSTD_e_end). Decompression will need same prefix to properly regenerate data. Compressing with a prefix is similar in outcome as performing a diff and compressing it, but performs much faster, especially during decompression (compression speed is tunable with compression level). This method is compatible with LDM (long distance mode). </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary Note 1 : Prefix buffer is referenced. It <b>must</b> outlive compression. Its content must remain unmodified during compression. Note 2 : If the intention is to diff some large src data blob with some prior version of itself, ensure that the window size is large enough to contain the entire source. See ZSTD_c_windowLog. Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters. It's a CPU consuming operation, with non-negligible impact on latency. If there is a need to use the same prefix multiple times, consider loadDictionary instead. Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent). Use experimental <a class="el" href="zstd_8c.html#ae9de20b252b866996cd926c918c9504e">ZSTD_CCtx_refPrefix_advanced()</a> to alter dictionary interpretation. </dd></dl>

</div>
</div>
<a id="ae9de20b252b866996cd926c918c9504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9de20b252b866996cd926c918c9504e">&#9670;&nbsp;</a></span>ZSTD_CCtx_refPrefix_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_refPrefix_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prefixSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dictContentType_e&#160;</td>
          <td class="paramname"><em>dictContentType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ae9de20b252b866996cd926c918c9504e">ZSTD_CCtx_refPrefix_advanced()</a> : Same as <a class="el" href="zstd_8c.html#a178ca3471ba2633b712683b3d6bea5f2">ZSTD_CCtx_refPrefix()</a>, but gives finer control over how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?) </p>

</div>
</div>
<a id="a64d7fa5aa19fa8325eec5670b1d7cf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d7fa5aa19fa8325eec5670b1d7cf05">&#9670;&nbsp;</a></span>ZSTD_CCtx_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_ResetDirective&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a64d7fa5aa19fa8325eec5670b1d7cf05">ZSTD_CCtx_reset()</a> : There are 2 different things that can be reset, independently or jointly :</p><ul>
<li>The session : will stop compressing current frame, and make CCtx ready to start a new one. Useful after an error, or to interrupt any ongoing compression. Any internal data not yet flushed is cancelled. Compression parameters and dictionary remain unchanged. They will be used to compress next frame. Resetting session never fails.</li>
<li>The parameters : changes all parameters back to "default". This also removes any reference to any dictionary or external sequence producer. Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing) otherwise the reset fails, and function returns an error value (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>)</li>
<li>Both : similar to resetting the session, followed by resetting parameters.</li>
</ul>
<p><a class="el" href="zstd_8c.html#a64d7fa5aa19fa8325eec5670b1d7cf05">ZSTD_CCtx_reset()</a> : Also dumps dictionary </p>

</div>
</div>
<a id="af05dc78925b27575799a234510c7d943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05dc78925b27575799a234510c7d943">&#9670;&nbsp;</a></span>ZSTD_CCtx_setCParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_setCParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td>
          <td class="paramname"><em>cparams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#af05dc78925b27575799a234510c7d943">ZSTD_CCtx_setCParams()</a> : Set all parameters provided within <code>cparams</code> into the working <code>cctx</code>. Note : if modifying parameters during compression (MT mode only), note that changes to the .windowLog parameter will be ignored. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, or an error code (can be checked with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). On failure, no parameters are updated. </dd></dl>

</div>
</div>
<a id="a32c2840a792656d0505b3e3ab0349067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c2840a792656d0505b3e3ab0349067">&#9670;&nbsp;</a></span>ZSTD_CCtx_setFParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_setFParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a>&#160;</td>
          <td class="paramname"><em>fparams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a32c2840a792656d0505b3e3ab0349067">ZSTD_CCtx_setFParams()</a> : Set all parameters provided within <code>fparams</code> into the working <code>cctx</code>. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, or an error code (can be checked with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a0122876033842c653406f9239ff64508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0122876033842c653406f9239ff64508">&#9670;&nbsp;</a></span>ZSTD_CCtx_setParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_setParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_cParameter&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a0122876033842c653406f9239ff64508">ZSTD_CCtx_setParameter()</a> : Set one compression parameter, selected by enum ZSTD_cParameter. All parameters have valid bounds. Bounds can be queried using <a class="el" href="zstd_8c.html#af34c6f9ee170db29838a57968716e28a">ZSTD_cParam_getBounds()</a>. Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter). Setting a parameter is generally only possible during frame initialization (before starting compression). Exception : when using multi-threading mode (nbWorkers &gt;= 1), the following parameters can be updated <em>during</em> compression (within same frame): =&gt; compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy. new parameters will be active for next job only (after a flush()). </p><dl class="section return"><dt>Returns</dt><dd>: an error code (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a9f72c1097785403f80e261846cdb50b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f72c1097785403f80e261846cdb50b0">&#9670;&nbsp;</a></span>ZSTD_CCtx_setParametersUsingCCtxParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_setParametersUsingCCtxParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9f72c1097785403f80e261846cdb50b0">ZSTD_CCtx_setParametersUsingCCtxParams()</a> : Apply a set of ZSTD_CCtx_params to the compression context. This can be done even after compression is started, if nbWorkers==0, this will have no impact until a new compression is started. if nbWorkers&gt;=1, new parameters will be picked up at next job, with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated).</p>
<p><a class="el" href="zstd_8c.html#a9f72c1097785403f80e261846cdb50b0">ZSTD_CCtx_setParametersUsingCCtxParams()</a> : just applies <code>params</code> into <code>cctx</code> no action is performed, parameters are merely stored. If ZSTDMT is enabled, parameters are pushed to cctx-&gt;mtctx. This is possible even if a compression is ongoing. In which case, new parameters will be applied on the fly, starting with next compression job. </p>

</div>
</div>
<a id="aaa0e49ff9f3cb87838b1361847c4bc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0e49ff9f3cb87838b1361847c4bc81">&#9670;&nbsp;</a></span>ZSTD_CCtx_setParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_setParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aaa0e49ff9f3cb87838b1361847c4bc81">ZSTD_CCtx_setParams()</a> : Set all parameters provided within <code>params</code> into the working <code>cctx</code>. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, or an error code (can be checked with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a8e0795af794521da3907efa8fe850ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0795af794521da3907efa8fe850ed4">&#9670;&nbsp;</a></span>ZSTD_CCtx_setPledgedSrcSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtx_setPledgedSrcSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a8e0795af794521da3907efa8fe850ed4">ZSTD_CCtx_setPledgedSrcSize()</a> : Total input data size to be compressed as a single frame. Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag. This value will also be controlled at end of frame, and trigger an error if not respected. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame. In order to mean "unknown content size", pass constant ZSTD_CONTENTSIZE_UNKNOWN. ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame. Note 2 : pledgedSrcSize is only valid once, for the next frame. It's discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN. Note 3 : Whenever all input data is provided and consumed in a single round, for example with <a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a>, or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end), this value is automatically overridden by srcSize instead. </dd></dl>

</div>
</div>
<a id="a2479336b82724682dafbc8e0ab99bcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2479336b82724682dafbc8e0ab99bcd0">&#9670;&nbsp;</a></span>ZSTD_CCtx_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZSTD_CCtx_trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>extraCSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a2479336b82724682dafbc8e0ab99bcd0">ZSTD_CCtx_trace()</a> : Trace the end of a compression call. </p>

</div>
</div>
<a id="ad5c342690d88fe4d7a0ce195503eddb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c342690d88fe4d7a0ce195503eddb9">&#9670;&nbsp;</a></span>ZSTD_CCtxParams_getParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtxParams_getParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_cParameter&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ad5c342690d88fe4d7a0ce195503eddb9">ZSTD_CCtxParams_getParameter()</a> : Similar to ZSTD_CCtx_getParameter. Get the requested value of one compression parameter, selected by enum ZSTD_cParameter. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a5f42ebe0ca87800289f2c83f6f529e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f42ebe0ca87800289f2c83f6f529e9d">&#9670;&nbsp;</a></span>ZSTD_CCtxParams_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtxParams_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>cctxParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a5f42ebe0ca87800289f2c83f6f529e9d">ZSTD_CCtxParams_init()</a> : Initializes the compression parameters of cctxParams according to compression level. All other parameters are reset to their default values. </p>

</div>
</div>
<a id="afd0b5ad81ba3800d9cab1081a2e3b370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0b5ad81ba3800d9cab1081a2e3b370">&#9670;&nbsp;</a></span>ZSTD_CCtxParams_init_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtxParams_init_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>cctxParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#afd0b5ad81ba3800d9cab1081a2e3b370">ZSTD_CCtxParams_init_advanced()</a> : Initializes the compression and frame parameters of cctxParams according to params. All other parameters are reset to their default values. </p>

</div>
</div>
<a id="a8c553672fcaa18286712cc650a2b8b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c553672fcaa18286712cc650a2b8b93">&#9670;&nbsp;</a></span>ZSTD_CCtxParams_registerSequenceProducer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZSTD_CCtxParams_registerSequenceProducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sequenceProducerState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_sequenceProducer_F&#160;</td>
          <td class="paramname"><em>sequenceProducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a8c553672fcaa18286712cc650a2b8b93">ZSTD_CCtxParams_registerSequenceProducer()</a> : Same as <a class="el" href="zstd_8c.html#a82b046dad80364659876af1447f09f63">ZSTD_registerSequenceProducer()</a>, but operates on ZSTD_CCtx_params. This is used for accurate size estimation with ZSTD_estimateCCtxSize_usingCCtxParams(), which is needed when creating a ZSTD_CCtx with <a class="el" href="zstd_8c.html#a546bc4b164b95226389a530c50782860">ZSTD_initStaticCCtx()</a>.</p>
<p>If you are using the external sequence producer API in a scenario where <a class="el" href="zstd_8c.html#a546bc4b164b95226389a530c50782860">ZSTD_initStaticCCtx()</a> is required, then this function is for you. Otherwise, you probably don't need it.</p>
<p>See tests/zstreamtest.c for example usage. </p>

</div>
</div>
<a id="ae0b30080999e29979948d5ef79396f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b30080999e29979948d5ef79396f5f">&#9670;&nbsp;</a></span>ZSTD_CCtxParams_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtxParams_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ae0b30080999e29979948d5ef79396f5f">ZSTD_CCtxParams_reset()</a> : Reset params to default values. </p>

</div>
</div>
<a id="a1d05d6678c081447914362b2fd2ef7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d05d6678c081447914362b2fd2ef7ea">&#9670;&nbsp;</a></span>ZSTD_CCtxParams_setParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CCtxParams_setParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_cParameter&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a1d05d6678c081447914362b2fd2ef7ea">ZSTD_CCtxParams_setParameter()</a> : Requires v1.4.0+ Similar to ZSTD_CCtx_setParameter. Set one compression parameter, selected by enum ZSTD_cParameter. Parameters must be applied to a ZSTD_CCtx using <a class="el" href="zstd_8c.html#a9f72c1097785403f80e261846cdb50b0">ZSTD_CCtx_setParametersUsingCCtxParams()</a>. </p><dl class="section return"><dt>Returns</dt><dd>: a code representing success or failure (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a4057190c93c37f887735a7e1c152ddc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4057190c93c37f887735a7e1c152ddc5">&#9670;&nbsp;</a></span>ZSTD_checkContinuity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> void ZSTD_checkContinuity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a4057190c93c37f887735a7e1c152ddc5">ZSTD_checkContinuity()</a> : check if next <code>dst</code> follows previous position, where decompression ended. If yes, do nothing (continue on current segment). If not, classify previous segment as "external dictionary", and start a new segment. This function cannot fail. </p>

</div>
</div>
<a id="a4886f5f0746fa3fa8087093f68268c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4886f5f0746fa3fa8087093f68268c83">&#9670;&nbsp;</a></span>ZSTD_checkCParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_checkCParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td>
          <td class="paramname"><em>cParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a4886f5f0746fa3fa8087093f68268c83">ZSTD_checkCParams()</a> : Ensure param values remain within authorized range. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, or an error code (can be checked with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>)</dd></dl>
<p><a class="el" href="zstd_8c.html#a4886f5f0746fa3fa8087093f68268c83">ZSTD_checkCParams()</a> : control CParam values remain within authorized range. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code if one value is beyond authorized range </dd></dl>

</div>
</div>
<a id="ac10ee027998fbfbedc71961633791955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10ee027998fbfbedc71961633791955">&#9670;&nbsp;</a></span>ZSTD_compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compress </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress()</a> : Compresses <code>src</code> content as a single zstd compressed frame into already allocated <code>dst</code>. NOTE: Providing <code>dstCapacity &gt;= ZSTD_compressBound(srcSize)</code> guarantees that zstd will have enough space to successfully compress the data. </p><dl class="section return"><dt>Returns</dt><dd>: compressed size written into <code>dst</code> (&lt;= `dstCapacity), or an error code if it fails (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a48377b8080ba9ebc5651db59d4a63f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48377b8080ba9ebc5651db59d4a63f3f">&#9670;&nbsp;</a></span>ZSTD_compress2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compress2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a> : Behave the same as <a class="el" href="zstd_8c.html#a16db44e4760f1b4ac38cb50ab2464a59">ZSTD_compressCCtx()</a>, but compression parameters are set using the advanced API. (note that this entry point doesn't even expose a compression level parameter). <a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a> always starts a new frame. Should cctx hold data from a previously unfinished frame, everything about it is forgotten.</p><ul>
<li>Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()</li>
<li>The function is always blocking, returns when compression is completed. NOTE: Providing <code>dstCapacity &gt;= ZSTD_compressBound(srcSize)</code> guarantees that zstd will have enough space to successfully compress the data, though it is possible it fails for other reasons. <dl class="section return"><dt>Returns</dt><dd>: compressed size written into <code>dst</code> (&lt;= `dstCapacity), or an error code if it fails (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>
</li>
</ul>

</div>
</div>
<a id="abb07ba1ea20a71939fc9b3c87f6050ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb07ba1ea20a71939fc9b3c87f6050ad">&#9670;&nbsp;</a></span>ZSTD_compress_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compress_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#abb07ba1ea20a71939fc9b3c87f6050ad">ZSTD_compress_advanced()</a> : Note : this function is now DEPRECATED. It can be replaced by <a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a>, in combination with <a class="el" href="zstd_8c.html#a0122876033842c653406f9239ff64508">ZSTD_CCtx_setParameter()</a> and other parameter setters. This prototype will generate compilation warnings. </p>

</div>
</div>
<a id="a380e2bdc1072dec0c666044902403497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380e2bdc1072dec0c666044902403497">&#9670;&nbsp;</a></span>ZSTD_compress_usingCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compress_usingCDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a380e2bdc1072dec0c666044902403497">ZSTD_compress_usingCDict()</a> : Compression using a digested Dictionary. Recommended when same dictionary is used multiple times. Note : compression level is <em>decided at dictionary creation time</em>, and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)</p>
<p><a class="el" href="zstd_8c.html#a380e2bdc1072dec0c666044902403497">ZSTD_compress_usingCDict()</a> : Compression using a digested Dictionary. Faster startup than <a class="el" href="zstd_8c.html#a9c959b4c56ac1f67e2a7b55a41184363">ZSTD_compress_usingDict()</a>, recommended when same dictionary is used multiple times. Note that compression parameters are decided at CDict creation time while frame parameters are hardcoded </p>

</div>
</div>
<a id="af6ead21650381561d00d2aaccb4e0b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ead21650381561d00d2aaccb4e0b35">&#9670;&nbsp;</a></span>ZSTD_compress_usingCDict_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compress_usingCDict_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a>&#160;</td>
          <td class="paramname"><em>fParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#af6ead21650381561d00d2aaccb4e0b35">ZSTD_compress_usingCDict_advanced()</a> : Note : this function is now DEPRECATED. It can be replaced by <a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a>, in combination with <a class="el" href="zstd_8c.html#a9f03e49aafdf252d4e9a10fdee0db68b">ZSTD_CCtx_loadDictionary()</a> and other parameter setters. This prototype will generate compilation warnings.</p>
<p><a class="el" href="zstd_8c.html#af6ead21650381561d00d2aaccb4e0b35">ZSTD_compress_usingCDict_advanced()</a>: This function is DEPRECATED. </p>

</div>
</div>
<a id="a9c959b4c56ac1f67e2a7b55a41184363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c959b4c56ac1f67e2a7b55a41184363">&#9670;&nbsp;</a></span>ZSTD_compress_usingDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compress_usingDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9c959b4c56ac1f67e2a7b55a41184363">ZSTD_compress_usingDict()</a> : Compression at an explicit compression level using a Dictionary. A dictionary can be any arbitrary data segment (also called a prefix), or a buffer with specified information (see zdict.h). Note : This function loads the dictionary, resulting in significant startup delay. It's intended for a dictionary used only once. Note 2 : When <code>dict == NULL || dictSize &lt; 8</code> no dictionary is used. </p>

</div>
</div>
<a id="a2358ee3d278050504ecc5b10ce412659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2358ee3d278050504ecc5b10ce412659">&#9670;&nbsp;</a></span>ZSTD_compressBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer-less streaming compression (synchronous mode)</p>
<p>A ZSTD_CCtx object is required to track streaming operations. Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource. ZSTD_CCtx object can be reused multiple times within successive compression operations.</p>
<p>Start by initializing a context. Use <a class="el" href="zstd_8c.html#a2358ee3d278050504ecc5b10ce412659">ZSTD_compressBegin()</a>, or ZSTD_compressBegin_usingDict() for dictionary compression.</p>
<p>Then, consume your input using ZSTD_compressContinue(). There are some important considerations to keep in mind when using this advanced function :</p><ul>
<li>ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only.</li>
<li>Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks.</li>
<li>Caller must ensure there is enough space in <code>dst</code> to store compressed data under worst case scenario. Worst case evaluation is provided by <a class="el" href="zstd_8c.html#a04413eba92e4dc84ca561de847fbcd06">ZSTD_compressBound()</a>. ZSTD_compressContinue() doesn't guarantee recover after a failed compression.</li>
<li>ZSTD_compressContinue() presumes prior input <em><b>is still accessible and unmodified</b></em> (up to maximum distance size, see WindowLog). It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)</li>
<li>ZSTD_compressContinue() detects that prior input has been overwritten when <code>src</code> buffer overlaps. In which case, it will "discard" the relevant memory section from its history.</li>
</ul>
<p>Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum. It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame. Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders.</p>
<p><code>ZSTD_CCtx</code> object can be reused (<a class="el" href="zstd_8c.html#a2358ee3d278050504ecc5b10ce412659">ZSTD_compressBegin()</a>) to compress again. </p>

</div>
</div>
<a id="a9cea029a0bb52342323fb0cec22d35b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cea029a0bb52342323fb0cec22d35b0">&#9670;&nbsp;</a></span>ZSTD_compressBegin_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressBegin_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a>&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pledgedSrcSize : If srcSize is not known at init time, use ZSTD_CONTENTSIZE_UNKNOWN</p>
<p><a class="el" href="zstd_8c.html#a9cea029a0bb52342323fb0cec22d35b0">ZSTD_compressBegin_advanced()</a> : </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code </dd></dl>

</div>
</div>
<a id="a25f4b4d57189368d6467e6681b0bc90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f4b4d57189368d6467e6681b0bc90d">&#9670;&nbsp;</a></span>ZSTD_compressBegin_usingCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressBegin_usingCDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>note: fails if cdict==NULL </p>

</div>
</div>
<a id="a90708241a9dd80d0ed983f4671f1649b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90708241a9dd80d0ed983f4671f1649b">&#9670;&nbsp;</a></span>ZSTD_compressBlock_fast_noDict_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> size_t ZSTD_compressBlock_fast_noDict_generic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSeqStore__t.html">SeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>seqStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>rep</em>[ZSTD_REP_NUM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 const&#160;</td>
          <td class="paramname"><em>mls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>useCmov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you squint hard enough (and ignore repcodes), the search operation at any given position is broken into 4 stages:</p>
<ol type="1">
<li>Hash (map position to hash value via input read)</li>
<li>Lookup (map hash val to index via hashtable read)</li>
<li>Load (map index to value at that position via input read)</li>
<li>Compare</li>
</ol>
<p>Each of these steps involves a memory read at an address which is computed from the previous step. This means these steps must be sequenced and their latencies are cumulative.</p>
<p>Rather than do 1-&gt;2-&gt;3-&gt;4 sequentially for a single position before moving onto the next, this implementation interleaves these operations across the next few positions:</p>
<p>R = Repcode Read &amp; Compare H = Hash T = Table Lookup M = Match Read &amp; Compare</p>
<p>Pos | Time --&gt; -&mdash;+----------------&mdash; N | ... M N+1 | ... TM N+2 | R H T M N+3 | H TM N+4 | R H T M N+5 | H ... N+6 | R ...</p>
<p>This is very much analogous to the pipelining of execution in a CPU. And just like a CPU, we have to dump the pipeline when we find a match (i.e., take a branch).</p>
<p>When this happens, we throw away our current state, and do the following prep to re-enter the loop:</p>
<p>Pos | Time --&gt; -&mdash;+----------------&mdash; N | H T N+1 | H</p>
<p>This is also the work we do at the beginning to enter the loop initially. </p>

</div>
</div>
<a id="a5f1c3b7591d8f246da5805d86947daea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1c3b7591d8f246da5805d86947daea">&#9670;&nbsp;</a></span>ZSTD_compressBlock_greedy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressBlock_greedy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSeqStore__t.html">SeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>seqStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>rep</em>[ZSTD_REP_NUM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>used in ZSTD_reduceIndex(). preemptively increase value of ZSTD_DUBT_UNSORTED_MARK </p>

</div>
</div>
<a id="a04413eba92e4dc84ca561de847fbcd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04413eba92e4dc84ca561de847fbcd06">&#9670;&nbsp;</a></span>ZSTD_compressBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressBound </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum compressed size in worst case single-pass scenario </p>

</div>
</div>
<a id="a16db44e4760f1b4ac38cb50ab2464a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16db44e4760f1b4ac38cb50ab2464a59">&#9670;&nbsp;</a></span>ZSTD_compressCCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressCCtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a16db44e4760f1b4ac38cb50ab2464a59">ZSTD_compressCCtx()</a> : Same as <a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress()</a>, using an explicit ZSTD_CCtx. Important : in order to mirror <code><a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress()</a></code> behavior, this function compresses at the requested compression level, <b>ignoring any other advanced parameter</b> . If any advanced parameter was set using the advanced API, they will all be reset. Only @compressionLevel remains. </p>

</div>
</div>
<a id="a3ea6e28236d8dc969c6296ab7896926c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea6e28236d8dc969c6296ab7896926c">&#9670;&nbsp;</a></span>ZSTD_compressSequences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressSequences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *&#160;</td>
          <td class="paramname"><em>inSeqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inSeqsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a3ea6e28236d8dc969c6296ab7896926c">ZSTD_compressSequences()</a> : Compress an array of <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a>, associated with @src buffer, into dst. @src contains the entire input (not just the literals). If @srcSize &gt; sum(sequence.length), the remaining bytes are considered all literals If a dictionary is included, then the cctx should reference the dict (see: <a class="el" href="zstd_8c.html#a6ae3427f20d2276510d9a69db51e7d85">ZSTD_CCtx_refCDict()</a>, <a class="el" href="zstd_8c.html#a9f03e49aafdf252d4e9a10fdee0db68b">ZSTD_CCtx_loadDictionary()</a>, etc.). The entire source is compressed into a single frame.</p>
<p>The compression behavior changes based on cctx params. In particular: If ZSTD_c_blockDelimiters == ZSTD_sf_noBlockDelimiters, the array of <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> is expected to contain no block delimiters (defined in <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a>). Block boundaries are roughly determined based on the block size derived from the cctx, and sequences may be split. This is the default setting.</p>
<p>If ZSTD_c_blockDelimiters == ZSTD_sf_explicitBlockDelimiters, the array of <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> is expected to contain valid block delimiters (defined in <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a>). Behavior is undefined if no block delimiters are provided.</p>
<p>When ZSTD_c_blockDelimiters == ZSTD_sf_explicitBlockDelimiters, it's possible to decide generating repcodes using the advanced parameter ZSTD_c_repcodeResolution. Repcodes will improve compression ratio, though the benefit can vary greatly depending on Sequences. On the other hand, repcode resolution is an expensive operation. By default, it's disabled at low (&lt;10) compression levels, and enabled above the threshold (&gt;=10). ZSTD_c_repcodeResolution makes it possible to directly manage this processing in either direction.</p>
<p>If ZSTD_c_validateSequences == 0, this function blindly accepts the Sequences provided. Invalid Sequences cause undefined behavior. If ZSTD_c_validateSequences == 1, then the function will detect invalid Sequences (see doc/zstd_compression_format.md for specifics regarding offset/matchlength requirements) and then bail out and return an error.</p>
<p>In addition to the two adjustable experimental params, there are other important cctx params.</p><ul>
<li>ZSTD_c_minMatch MUST be set as less than or equal to the smallest match generated by the match finder. It has a minimum value of ZSTD_MINMATCH_MIN.</li>
<li>ZSTD_c_compressionLevel accordingly adjusts the strength of the entropy coder, as it would in typical compression.</li>
<li>ZSTD_c_windowLog affects offset validation: this function will return an error at higher debug levels if a provided offset is larger than what the spec allows for a given window log and dictionary (if present). See: doc/zstd_compression_format.md</li>
</ul>
<p>Note: Repcodes are, as of now, always re-calculated within this function, ZSTD_Sequence.rep is effectively unused. Dev Note: Once ability to ingest repcodes become available, the explicit block delims mode must respect those repcodes exactly, and cannot emit an RLE block that disagrees with the repcode history. </p><dl class="section return"><dt>Returns</dt><dd>: final compressed size, or a ZSTD error code. </dd></dl>

</div>
</div>
<a id="ab88e972599baf04b649a83026907b484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88e972599baf04b649a83026907b484">&#9670;&nbsp;</a></span>ZSTD_compressSequencesAndLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressSequencesAndLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *&#160;</td>
          <td class="paramname"><em>inSeqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbSequences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>literals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>litSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>litBufCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>decompressedSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ab88e972599baf04b649a83026907b484">ZSTD_compressSequencesAndLiterals()</a> : This is a variant of <a class="el" href="zstd_8c.html#a3ea6e28236d8dc969c6296ab7896926c">ZSTD_compressSequences()</a> which, instead of receiving (src,srcSize) as input parameter, receives (literals,litSize), aka all the literals, already extracted and laid out into a single continuous buffer. This can be useful if the process generating the sequences also happens to generate the buffer of literals, thus skipping an extraction + caching stage. It's a speed optimization, useful when the right conditions are met, but it also features the following limitations:</p><ul>
<li>Only supports explicit delimiter mode</li>
<li>Currently does not support Sequences validation (so input Sequences are trusted)</li>
<li>Not compatible with frame checksum, which must be disabled</li>
<li>If any block is incompressible, will fail and return an error</li>
<li>@litSize must be == sum of all .litLength fields in @inSeqs. Any discrepancy will generate an error.</li>
<li>@litBufCapacity is the size of the underlying buffer into which literals are written, starting at address @literals. @litBufCapacity must be at least 8 bytes larger than @litSize.</li>
<li>@decompressedSize must be correct, and correspond to the sum of all Sequences. Any discrepancy will generate an error. <dl class="section return"><dt>Returns</dt><dd>: final compressed size, or a ZSTD error code. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a0585b3bc8b65251e1bf8efcf8ca7382d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0585b3bc8b65251e1bf8efcf8ca7382d">&#9670;&nbsp;</a></span>ZSTD_compressStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer</a> *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue). NOTE: The return value is different. <a class="el" href="zstd_8c.html#a0585b3bc8b65251e1bf8efcf8ca7382d">ZSTD_compressStream()</a> returns a hint for the next read size (if non-zero and not an error). <a class="el" href="zstd_8c.html#a5f92b06ea0440baf0763ce7104db86a5">ZSTD_compressStream2()</a> returns the minimum nb of bytes left to flush (if non-zero and not an error). </p>

</div>
</div>
<a id="a5f92b06ea0440baf0763ce7104db86a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f92b06ea0440baf0763ce7104db86a5">&#9670;&nbsp;</a></span>ZSTD_compressStream2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressStream2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_EndDirective&#160;</td>
          <td class="paramname"><em>endOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a5f92b06ea0440baf0763ce7104db86a5">ZSTD_compressStream2()</a> : Requires v1.4.0+ Behaves about the same as ZSTD_compressStream, with additional control on end directive.</p><ul>
<li>Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()</li>
<li>Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)</li>
<li>output-&gt;pos must be &lt;= dstCapacity, input-&gt;pos must be &lt;= srcSize</li>
<li>output-&gt;pos and input-&gt;pos will be updated. They are guaranteed to remain below their respective limit.</li>
<li>endOp must be a valid directive</li>
<li>When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.</li>
<li>When nbWorkers&gt;=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available, and then immediately returns, just indicating that there is some data remaining to be flushed. The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.</li>
<li>Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to <a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a> which is always blocking.</li>
<li><dl class="section return"><dt>Returns</dt><dd>provides a minimum amount of data remaining to be flushed from internal buffers or an error code, which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>. if </dd>
<dd>
!= 0, flush is not fully completed, there is still some data left within internal buffers. This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers. For ZSTD_e_end, </dd>
<dd>
== 0 when internal buffers are fully flushed and frame is completed.</dd></dl>
</li>
<li>after a ZSTD_e_end directive, if internal buffer is not fully flushed (<dl class="section return"><dt>Returns</dt><dd>!= 0), only ZSTD_e_end or ZSTD_e_flush operations are allowed. Before starting a new compression job, or changing compression parameters, it is required to fully flush internal buffers.</dd></dl>
</li>
<li>note: if an operation ends with an error, it may leave @cctx in an undefined state. Therefore, it's UB to invoke <a class="el" href="zstd_8c.html#a5f92b06ea0440baf0763ce7104db86a5">ZSTD_compressStream2()</a> of <a class="el" href="zstd_8c.html#a0585b3bc8b65251e1bf8efcf8ca7382d">ZSTD_compressStream()</a> on such a state. In order to be re-employed after an error, a state must be reset, which can be done explicitly (<a class="el" href="zstd_8c.html#a64d7fa5aa19fa8325eec5670b1d7cf05">ZSTD_CCtx_reset()</a>), or is sometimes implied by methods starting a new compression job (<a class="el" href="zstd_8c.html#a6b60144bc8895bcbc214bb6209529039">ZSTD_initCStream()</a>, <a class="el" href="zstd_8c.html#a16db44e4760f1b4ac38cb50ab2464a59">ZSTD_compressCCtx()</a>) </li>
</ul>

</div>
</div>
<a id="a06f77cdd326d5d47edbb3d0d66c1f719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f77cdd326d5d47edbb3d0d66c1f719">&#9670;&nbsp;</a></span>ZSTD_compressStream2_simpleArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_compressStream2_simpleArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dstPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_EndDirective&#160;</td>
          <td class="paramname"><em>endOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a06f77cdd326d5d47edbb3d0d66c1f719">ZSTD_compressStream2_simpleArgs()</a> : Same as <a class="el" href="zstd_8c.html#a5f92b06ea0440baf0763ce7104db86a5">ZSTD_compressStream2()</a>, but using only integral types as arguments. This variant might be helpful for binders from dynamic languages which have troubles handling structures containing memory pointers. </p>

</div>
</div>
<a id="a8ac1086436297ae878a8d658547dbe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac1086436297ae878a8d658547dbe58">&#9670;&nbsp;</a></span>ZSTD_copyCCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_copyCCtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>dstCCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>srcCCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>note: if pledgedSrcSize is not known, use ZSTD_CONTENTSIZE_UNKNOWN</p>
<p><a class="el" href="zstd_8c.html#a8ac1086436297ae878a8d658547dbe58">ZSTD_copyCCtx()</a> : Duplicate an existing context <code>srcCCtx</code> into another one <code>dstCCtx</code>. Only works during stage ZSTDcs_init (i.e. after creation, but before first call to ZSTD_compressContinue()). pledgedSrcSize==0 means "unknown". </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code </dd></dl>

</div>
</div>
<a id="a57701da2b1d85e5caef04c0f7a825609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57701da2b1d85e5caef04c0f7a825609">&#9670;&nbsp;</a></span>ZSTD_count_2segments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t ZSTD_count_2segments </td>
          <td>(</td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>iEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>mEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>iStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a57701da2b1d85e5caef04c0f7a825609">ZSTD_count_2segments()</a> : can count match length with <code>ip</code> &amp; <code>match</code> in 2 different segments. convention : on reaching mEnd, match count continue starting from iStart </p>

</div>
</div>
<a id="af34c6f9ee170db29838a57968716e28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34c6f9ee170db29838a57968716e28a">&#9670;&nbsp;</a></span>ZSTD_cParam_getBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__bounds.html">ZSTD_bounds</a> ZSTD_cParam_getBounds </td>
          <td>(</td>
          <td class="paramtype">ZSTD_cParameter&#160;</td>
          <td class="paramname"><em>cParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#af34c6f9ee170db29838a57968716e28a">ZSTD_cParam_getBounds()</a> : All parameters must belong to an interval with lower and upper bounds, otherwise they will either trigger an error or be automatically clamped. </p><dl class="section return"><dt>Returns</dt><dd>: a structure, <a class="el" href="structZSTD__bounds.html">ZSTD_bounds</a>, which contains<ul>
<li>an error status field, which must be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a></li>
<li>lower and upper bounds, both inclusive </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4ec7e4f9d0a247be967793eedbe00673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec7e4f9d0a247be967793eedbe00673">&#9670;&nbsp;</a></span>ZSTD_cpuSupportsBmi2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC int ZSTD_cpuSupportsBmi2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true iff the CPU supports dynamic BMI2 dispatch. </dd></dl>

</div>
</div>
<a id="a6105f6c1c1da52b3baf3a103fc3a8e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6105f6c1c1da52b3baf3a103fc3a8e49">&#9670;&nbsp;</a></span>ZSTD_createCCtxParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> * ZSTD_createCCtxParams </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_CCtx_params : Quick howto :</p><ul>
<li><a class="el" href="zstd_8c.html#a6105f6c1c1da52b3baf3a103fc3a8e49">ZSTD_createCCtxParams()</a> : Create a ZSTD_CCtx_params structure</li>
<li><a class="el" href="zstd_8c.html#a1d05d6678c081447914362b2fd2ef7ea">ZSTD_CCtxParams_setParameter()</a> : Push parameters one by one into an existing ZSTD_CCtx_params structure. This is similar to <a class="el" href="zstd_8c.html#a0122876033842c653406f9239ff64508">ZSTD_CCtx_setParameter()</a>.</li>
<li><a class="el" href="zstd_8c.html#a9f72c1097785403f80e261846cdb50b0">ZSTD_CCtx_setParametersUsingCCtxParams()</a> : Apply parameters to an existing CCtx. These parameters will be applied to all subsequent frames.</li>
<li><a class="el" href="zstd_8c.html#a5f92b06ea0440baf0763ce7104db86a5">ZSTD_compressStream2()</a> : Do compression using the CCtx.</li>
<li>ZSTD_freeCCtxParams() : Free the memory, accept NULL pointer.</li>
</ul>
<p>This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams() for static allocation of CCtx for single-threaded compression. </p>

</div>
</div>
<a id="aab922a70d7520918a7d8def0dd138412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab922a70d7520918a7d8def0dd138412">&#9670;&nbsp;</a></span>ZSTD_createCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> * ZSTD_createCDict </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aab922a70d7520918a7d8def0dd138412">ZSTD_createCDict()</a> : When compressing multiple messages or blocks using the same dictionary, it's recommended to digest the dictionary only once, since it's a costly operation. <a class="el" href="zstd_8c.html#aab922a70d7520918a7d8def0dd138412">ZSTD_createCDict()</a> will create a state from digesting a dictionary. The resulting state can be used for future compression operations with very limited startup cost. ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only. @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict. Note 1 : Consider experimental function <code><a class="el" href="zstd_8c.html#a166359d0f6b1e6cfa6e1c51431e652a7">ZSTD_createCDict_byReference()</a></code> if you prefer to not duplicate @dictBuffer content. Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer, in which case the only thing that it transports is the @compressionLevel. This can be useful in a pipeline featuring <a class="el" href="zstd_8c.html#a380e2bdc1072dec0c666044902403497">ZSTD_compress_usingCDict()</a> exclusively, expecting a ZSTD_CDict parameter with any data, including those without a known dictionary. </p>

</div>
</div>
<a id="a166359d0f6b1e6cfa6e1c51431e652a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166359d0f6b1e6cfa6e1c51431e652a7">&#9670;&nbsp;</a></span>ZSTD_createCDict_byReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> * ZSTD_createCDict_byReference </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a166359d0f6b1e6cfa6e1c51431e652a7">ZSTD_createCDict_byReference()</a> : Create a digested dictionary for compression Dictionary content is just referenced, not duplicated. As a consequence, <code>dictBuffer</code> <b>must</b> outlive CDict, and its content must remain unmodified throughout the lifetime of CDict. note: equivalent to ZSTD_createCDict_advanced(), with dictLoadMethod==ZSTD_dlm_byRef </p>

</div>
</div>
<a id="a4f3598dadc58ed1b40f84c85f6da72a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3598dadc58ed1b40f84c85f6da72a2">&#9670;&nbsp;</a></span>ZSTD_createDDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> * ZSTD_createDDict </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a4f3598dadc58ed1b40f84c85f6da72a2">ZSTD_createDDict()</a> : Create a digested dictionary, ready to start decompression operation without startup delay. dictBuffer can be released after DDict creation, as its content is copied inside DDict.</p>
<p><a class="el" href="zstd_8c.html#a4f3598dadc58ed1b40f84c85f6da72a2">ZSTD_createDDict()</a> : Create a digested dictionary, to start decompression without startup delay. <code>dict</code> content is copied inside DDict. Consequently, <code>dict</code> can be released after <code>ZSTD_DDict</code> creation </p>

</div>
</div>
<a id="a8df88e8b7d1663f64b4bdee696299ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df88e8b7d1663f64b4bdee696299ac1">&#9670;&nbsp;</a></span>ZSTD_createDDict_byReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> * ZSTD_createDDict_byReference </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dictBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a8df88e8b7d1663f64b4bdee696299ac1">ZSTD_createDDict_byReference()</a> : Create a digested dictionary, ready to start decompression operation without startup delay. Dictionary content is referenced, and therefore stays in dictBuffer. It is important that dictBuffer outlives DDict, it must remain read accessible throughout the lifetime of DDict</p>
<p><a class="el" href="zstd_8c.html#a8df88e8b7d1663f64b4bdee696299ac1">ZSTD_createDDict_byReference()</a> : Create a digested dictionary, to start decompression without startup delay. Dictionary content is simply referenced, it will be accessed during decompression. Warning : dictBuffer must outlive DDict (DDict must be freed before dictBuffer) </p>

</div>
</div>
<a id="a13cf8e1c619a5e19173ae8a0a29d99ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cf8e1c619a5e19173ae8a0a29d99ed">&#9670;&nbsp;</a></span>ZSTD_crossEntropyCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_crossEntropyCost </td>
          <td>(</td>
          <td class="paramtype">short const *&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>accuracyLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned const *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned const&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the cost in bits of encoding the distribution in count using the table described by norm. The max symbol support by norm is assumed &gt;= max. norm must be valid for every symbol with non-zero probability in count. </p>

</div>
</div>
<a id="a6bc1679273a9856ec0da228b33648039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc1679273a9856ec0da228b33648039">&#9670;&nbsp;</a></span>ZSTD_CStreamInSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CStreamInSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recommended size for input buffer </p>

</div>
</div>
<a id="ab3aa028d0ca4b708d0647952499edeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aa028d0ca4b708d0647952499edeb0">&#9670;&nbsp;</a></span>ZSTD_CStreamOutSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_CStreamOutSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block. </p>

</div>
</div>
<a id="af5c7428a6eec1a205b646f4133fe097f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c7428a6eec1a205b646f4133fe097f">&#9670;&nbsp;</a></span>ZSTD_cwksp_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t ZSTD_cwksp_align </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align must be a power of 2. </p>

</div>
</div>
<a id="aa0a28334c5a4c55877e288328c54fa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a28334c5a4c55877e288328c54fa37">&#9670;&nbsp;</a></span>ZSTD_cwksp_aligned64_alloc_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t ZSTD_cwksp_aligned64_alloc_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an adjusted alloc size that is the nearest larger multiple of 64 bytes. Used to determine the number of bytes required for a given "aligned". </p>

</div>
</div>
<a id="ab886033561bea9f8fa032aaae25b284e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab886033561bea9f8fa032aaae25b284e">&#9670;&nbsp;</a></span>ZSTD_cwksp_alloc_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t ZSTD_cwksp_alloc_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this to determine how much space in the workspace we will consume to allocate this object. (Normally it should be exactly the size of the object, but under special conditions, like ASAN, where we pad each object, it might be larger.)</p>
<p>Since tables aren't currently redzoned, you don't need to call through this to figure out how much space you need for the matchState tables. Everything else is though.</p>
<p>Do not use for sizing aligned buffers. Instead, use <a class="el" href="zstd_8c.html#aa0a28334c5a4c55877e288328c54fa37">ZSTD_cwksp_aligned64_alloc_size()</a>. </p>

</div>
</div>
<a id="a44833bd0cfaac545a4eccd464dbed6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44833bd0cfaac545a4eccd464dbed6ee">&#9670;&nbsp;</a></span>ZSTD_cwksp_bytes_to_align_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t ZSTD_cwksp_bytes_to_align_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>alignBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of additional bytes required to align a pointer to the given number of bytes. alignBytes must be a power of two. </p>

</div>
</div>
<a id="a3fe429aca2f2a9063b08a2372dd82e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe429aca2f2a9063b08a2372dd82e58">&#9670;&nbsp;</a></span>ZSTD_cwksp_clean_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void ZSTD_cwksp_clean_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zero the part of the allocated tables not already marked clean. </p>

</div>
</div>
<a id="a8f4481557c43ba23a4ca8be832b0b765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4481557c43ba23a4ca8be832b0b765">&#9670;&nbsp;</a></span>ZSTD_cwksp_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void ZSTD_cwksp_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalidates all buffer, aligned, and table allocations. Object allocations remain valid. </p>

</div>
</div>
<a id="a48ddee198a3d51f146cf9cb0e3c259c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ddee198a3d51f146cf9cb0e3c259c9">&#9670;&nbsp;</a></span>ZSTD_cwksp_clear_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void ZSTD_cwksp_clear_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalidates table allocations. All other allocations remain valid. </p>

</div>
</div>
<a id="aaede5bc13074b11c101505128283c810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaede5bc13074b11c101505128283c810">&#9670;&nbsp;</a></span>ZSTD_cwksp_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void ZSTD_cwksp_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a1df52ae5f2538c70f0db6f9c9377f6c7">ZSTD_cwksp_static_alloc_e</a>&#160;</td>
          <td class="paramname"><em>isStatic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The provided workspace takes ownership of the buffer [start, start+size). Any existing values in the workspace are ignored (the previously managed buffer, if present, must be separately freed). </p>

</div>
</div>
<a id="acc69eacbcc3d83f39715edfb69653a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc69eacbcc3d83f39715edfb69653a7c">&#9670;&nbsp;</a></span>ZSTD_cwksp_initialAllocStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void * ZSTD_cwksp_initialAllocStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the initial value for allocStart which is used to determine the position from which we can allocate from the end of the workspace. </p>

</div>
</div>
<a id="a29f8b87655edbfd16eef8f1ab70d2b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f8b87655edbfd16eef8f1ab70d2b2b">&#9670;&nbsp;</a></span>ZSTD_cwksp_internal_advance_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t ZSTD_cwksp_internal_advance_phase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_cwksp_alloc_phase_e&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cwksp to the next phase, and does any necessary allocations. cwksp initialization must necessarily go through each phase in order. Returns a 0 on success, or zstd error </p>

</div>
</div>
<a id="a2134dd2d9a727e3215a0c80b5b9df0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2134dd2d9a727e3215a0c80b5b9df0b7">&#9670;&nbsp;</a></span>ZSTD_cwksp_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void ZSTD_cwksp_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the management of a workspace from one cwksp to another. The src cwksp is left in an invalid state (src must be re-init()'ed before it's used again). </p>

</div>
</div>
<a id="a54a1b7fd981681509a8d79affbbb7294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a1b7fd981681509a8d79affbbb7294">&#9670;&nbsp;</a></span>ZSTD_cwksp_owns_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC int ZSTD_cwksp_owns_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether this object/buffer/etc was allocated in this workspace. </p>

</div>
</div>
<a id="ad94ed00041b94ff70bde142fe3017543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94ed00041b94ff70bde142fe3017543">&#9670;&nbsp;</a></span>ZSTD_cwksp_reserve_aligned64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void* ZSTD_cwksp_reserve_aligned64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves and returns memory sized on and aligned on ZSTD_CWKSP_ALIGNMENT_BYTES (64 bytes). </p>

</div>
</div>
<a id="a3845a2db282659f4f05d5346fc54856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3845a2db282659f4f05d5346fc54856e">&#9670;&nbsp;</a></span>ZSTD_cwksp_reserve_aligned_init_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void* ZSTD_cwksp_reserve_aligned_init_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves and returns memory sized on and aligned on ZSTD_CWKSP_ALIGNMENT_BYTES (64 bytes). This memory has been initialized at least once in the past. This doesn't mean it has been initialized this time, and it might contain data from previous operations. The main usage is for algorithms that might need read access into uninitialized memory. The algorithm must maintain safety under these conditions and must make sure it doesn't leak any of the past data (directly or in side channels). </p>

</div>
</div>
<a id="a9e326d108fc103d7e1fee18839e782ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e326d108fc103d7e1fee18839e782ef">&#9670;&nbsp;</a></span>ZSTD_cwksp_reserve_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC BYTE* ZSTD_cwksp_reserve_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves and returns unaligned memory. </p>

</div>
</div>
<a id="ac3f9aca41390497f2dec429797d17395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f9aca41390497f2dec429797d17395">&#9670;&nbsp;</a></span>ZSTD_cwksp_reserve_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void* ZSTD_cwksp_reserve_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_cwksp_alloc_phase_e&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function. Do not use directly. </p>

</div>
</div>
<a id="aacd4d6f76057094c6ce936e815dd609c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd4d6f76057094c6ce936e815dd609c">&#9670;&nbsp;</a></span>ZSTD_cwksp_reserve_internal_buffer_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void* ZSTD_cwksp_reserve_internal_buffer_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function. Do not use directly. Reserves the given number of bytes within the aligned/buffer segment of the wksp, which counts from the end of the wksp (as opposed to the object/table segment).</p>
<p>Returns a pointer to the beginning of that space. </p>

</div>
</div>
<a id="a71b8fbd1feebad4abde04d20531a9a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b8fbd1feebad4abde04d20531a9a97">&#9670;&nbsp;</a></span>ZSTD_cwksp_reserve_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void* ZSTD_cwksp_reserve_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aligned on sizeof(void*). Note : should happen only once, at workspace first initialization </p>

</div>
</div>
<a id="ae6ef4ae1942bd067061b33f27d015574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ef4ae1942bd067061b33f27d015574">&#9670;&nbsp;</a></span>ZSTD_cwksp_reserve_object_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void* ZSTD_cwksp_reserve_object_aligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>with alignment control Note : should happen only once, at workspace first initialization </p>

</div>
</div>
<a id="a01ba21778f86bacfea78d3f50b910ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ba21778f86bacfea78d3f50b910ce0">&#9670;&nbsp;</a></span>ZSTD_cwksp_reserve_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void* ZSTD_cwksp_reserve_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__cwksp.html">ZSTD_cwksp</a> *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aligned on 64 bytes. These buffers have the special property that their values remain constrained, allowing us to reuse them without memset()-ing them. </p>

</div>
</div>
<a id="a712ad2c6986cfb21f049a8227e87b8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712ad2c6986cfb21f049a8227e87b8cb">&#9670;&nbsp;</a></span>ZSTD_cwksp_slack_space_required()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC size_t ZSTD_cwksp_slack_space_required </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the amount of additional space the cwksp must allocate for internal purposes (currently only alignment). </p>

</div>
</div>
<a id="aba07604a85fd9f1d3cc0ce6c76bd6f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba07604a85fd9f1d3cc0ce6c76bd6f0d">&#9670;&nbsp;</a></span>ZSTD_cycleLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 ZSTD_cycleLog </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>hashLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_strategy&#160;</td>
          <td class="paramname"><em>strat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aba07604a85fd9f1d3cc0ce6c76bd6f0d">ZSTD_cycleLog()</a> : condition for correct operation : hashLog &gt; 1 </p>

</div>
</div>
<a id="a0fdc640dacd339aeea1dcd84b3c7f4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdc640dacd339aeea1dcd84b3c7f4a0">&#9670;&nbsp;</a></span>ZSTD_DCtx_getParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_getParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dParameter&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a0fdc640dacd339aeea1dcd84b3c7f4a0">ZSTD_DCtx_getParameter()</a> : Get the requested decompression parameter value, selected by enum ZSTD_dParameter, and store it into int* value. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a37bcbfbf1f53a0a76b766e4b7a125e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bcbfbf1f53a0a76b766e4b7a125e17">&#9670;&nbsp;</a></span>ZSTD_DCtx_loadDictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_loadDictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a37bcbfbf1f53a0a76b766e4b7a125e17">ZSTD_DCtx_loadDictionary()</a> : Requires v1.4.0+ Create an internal DDict from dict buffer, to be used to decompress all future frames. The dictionary remains valid for all future frames, until explicitly invalidated, or a new dictionary is loaded. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary, meaning "return to no-dictionary mode". Note 1 : Loading a dictionary involves building tables, which has a non-negligible impact on CPU usage and latency. It's recommended to "load once, use many times", to amortize the cost Note 2 :<code>dict</code> content will be copied internally, so <code>dict</code> can be released after loading. Use <a class="el" href="zstd_8c.html#a2444c8710a8e1edebc1a322ad4eb4553">ZSTD_DCtx_loadDictionary_byReference()</a> to reference dictionary content instead. Note 3 : Use <a class="el" href="zstd_8c.html#a0c12ba2f1a31fbffd29b18db1937a8eb">ZSTD_DCtx_loadDictionary_advanced()</a> to take control of how dictionary content is loaded and interpreted. </dd></dl>

</div>
</div>
<a id="a0c12ba2f1a31fbffd29b18db1937a8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c12ba2f1a31fbffd29b18db1937a8eb">&#9670;&nbsp;</a></span>ZSTD_DCtx_loadDictionary_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_loadDictionary_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a>&#160;</td>
          <td class="paramname"><em>dictLoadMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dictContentType_e&#160;</td>
          <td class="paramname"><em>dictContentType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a0c12ba2f1a31fbffd29b18db1937a8eb">ZSTD_DCtx_loadDictionary_advanced()</a> : Same as <a class="el" href="zstd_8c.html#a37bcbfbf1f53a0a76b766e4b7a125e17">ZSTD_DCtx_loadDictionary()</a>, but gives direct control over how to load the dictionary (by copy ? by reference ?) and how to interpret it (automatic ? force raw mode ? full mode only ?). </p>

</div>
</div>
<a id="a2444c8710a8e1edebc1a322ad4eb4553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2444c8710a8e1edebc1a322ad4eb4553">&#9670;&nbsp;</a></span>ZSTD_DCtx_loadDictionary_byReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_loadDictionary_byReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a2444c8710a8e1edebc1a322ad4eb4553">ZSTD_DCtx_loadDictionary_byReference()</a> : Same as <a class="el" href="zstd_8c.html#a37bcbfbf1f53a0a76b766e4b7a125e17">ZSTD_DCtx_loadDictionary()</a>, but references <code>dict</code> content instead of copying it into <code>dctx</code>. This saves memory if <code>dict</code> remains around., However, it's imperative that <code>dict</code> remains accessible (and unmodified) while being used, so it must outlive decompression. </p>

</div>
</div>
<a id="aa204feb870502bcdf04f232f6aa1ee58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa204feb870502bcdf04f232f6aa1ee58">&#9670;&nbsp;</a></span>ZSTD_DCtx_refDDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_refDDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td>
          <td class="paramname"><em>ddict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aa204feb870502bcdf04f232f6aa1ee58">ZSTD_DCtx_refDDict()</a> : Requires v1.4.0+ Reference a prepared dictionary, to be used to decompress next frames. The dictionary remains active for decompression of future frames using same DCtx.</p>
<p>If called with ZSTD_d_refMultipleDDicts enabled, repeated calls of this function will store the DDict references in a table, and the DDict used for decompression will be determined at decompression time, as per the dict ID in the frame. The memory for the table is allocated on the first call to refDDict, and can be freed with ZSTD_freeDCtx().</p>
<p>If called with ZSTD_d_refMultipleDDicts disabled (the default), only one dictionary will be managed, and referencing a dictionary effectively "discards" any previous one.</p>
<dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). Special: referencing a NULL DDict means "return to no-dictionary mode". Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx. </dd></dl>

</div>
</div>
<a id="a46706743c1bb9d7e6158635719f53caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46706743c1bb9d7e6158635719f53caa">&#9670;&nbsp;</a></span>ZSTD_DCtx_refPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_refPrefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prefixSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a46706743c1bb9d7e6158635719f53caa">ZSTD_DCtx_refPrefix()</a> : Requires v1.4.0+ Reference a prefix (single-usage dictionary) to decompress next frame. This is the reverse operation of <a class="el" href="zstd_8c.html#a178ca3471ba2633b712683b3d6bea5f2">ZSTD_CCtx_refPrefix()</a>, and must use the same prefix as the one used during compression. Prefix is <b>only used once</b>. Reference is discarded at end of frame. End of frame is reached when <a class="el" href="zstd_8c.html#a4ccda24ca50a1a35ea76a97b13edf398">ZSTD_decompressStream()</a> returns 0. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary Note 2 : Prefix buffer is referenced. It <b>must</b> outlive decompression. Prefix buffer must remain unmodified up to the end of frame, reached when <a class="el" href="zstd_8c.html#a4ccda24ca50a1a35ea76a97b13edf398">ZSTD_decompressStream()</a> returns 0. Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent). Use <a class="el" href="zstd_8c.html#ae9de20b252b866996cd926c918c9504e">ZSTD_CCtx_refPrefix_advanced()</a> to alter dictMode (Experimental section) Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost. A full dictionary is more costly, as it requires building tables. </dd></dl>

</div>
</div>
<a id="a7f18b59b255826da90bc7403a11b60be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f18b59b255826da90bc7403a11b60be">&#9670;&nbsp;</a></span>ZSTD_DCtx_refPrefix_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_refPrefix_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prefixSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dictContentType_e&#160;</td>
          <td class="paramname"><em>dictContentType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a7f18b59b255826da90bc7403a11b60be">ZSTD_DCtx_refPrefix_advanced()</a> : Same as <a class="el" href="zstd_8c.html#a46706743c1bb9d7e6158635719f53caa">ZSTD_DCtx_refPrefix()</a>, but gives finer control over how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?) </p>

</div>
</div>
<a id="a614f5b2e6aa19d66eb91223ff23c99ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614f5b2e6aa19d66eb91223ff23c99ed">&#9670;&nbsp;</a></span>ZSTD_DCtx_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_ResetDirective&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a614f5b2e6aa19d66eb91223ff23c99ed">ZSTD_DCtx_reset()</a> : Return a DCtx to clean state. Session and parameters can be reset jointly or separately. Parameters can only be reset when no active frame is being decompressed. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code, which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a> </dd></dl>

</div>
</div>
<a id="a95a62a9595a445da5dabaf411235127e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a62a9595a445da5dabaf411235127e">&#9670;&nbsp;</a></span>ZSTD_DCtx_setFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_setFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_format_e&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a95a62a9595a445da5dabaf411235127e">ZSTD_DCtx_setFormat()</a> : This function is REDUNDANT. Prefer <a class="el" href="zstd_8c.html#a4870b907a873b40e469f01127ba0232b">ZSTD_DCtx_setParameter()</a>. Instruct the decoder context about what kind of data to decode next. This instruction is mandatory to decode data without a fully-formed header, such ZSTD_f_zstd1_magicless for example. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="ae7beb5c17c0ab64569b170dc3498aaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7beb5c17c0ab64569b170dc3498aaee">&#9670;&nbsp;</a></span>ZSTD_DCtx_setMaxWindowSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_setMaxWindowSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxWindowSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ae7beb5c17c0ab64569b170dc3498aaee">ZSTD_DCtx_setMaxWindowSize()</a> : Refuses allocating internal buffers for frames requiring a window size larger than provided limit. This protects a decoder context from reserving too much memory for itself (potential attack scenario). This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode. By default, a decompression context accepts all window sizes &lt;= (1 &lt;&lt; ZSTD_WINDOWLOG_LIMIT_DEFAULT) </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a4870b907a873b40e469f01127ba0232b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4870b907a873b40e469f01127ba0232b">&#9670;&nbsp;</a></span>ZSTD_DCtx_setParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DCtx_setParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dParameter&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a4870b907a873b40e469f01127ba0232b">ZSTD_DCtx_setParameter()</a> : Set one compression parameter, selected by enum ZSTD_dParameter. All parameters have valid bounds. Bounds can be queried using <a class="el" href="zstd_8c.html#a102dc10a9332b4dcb3da3d0e5f1bfb5d">ZSTD_dParam_getBounds()</a>. Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter). Setting a parameter is only possible during frame initialization (before starting decompression). </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="a9823b75f8714fe6107131aaf9367e6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9823b75f8714fe6107131aaf9367e6ef">&#9670;&nbsp;</a></span>ZSTD_decodeSeqHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decodeSeqHeaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nbSeqPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9823b75f8714fe6107131aaf9367e6ef">ZSTD_decodeSeqHeaders()</a> : decode sequence header from src </p>

</div>
</div>
<a id="a9b5f39b04f25f22e9299d7f1baf82efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5f39b04f25f22e9299d7f1baf82efc">&#9670;&nbsp;</a></span>ZSTD_decodeSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> <a class="el" href="structseq__t.html">seq_t</a> ZSTD_decodeSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseqState__t.html">seqState_t</a> *&#160;</td>
          <td class="paramname"><em>seqState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ZSTD_longOffset_e&#160;</td>
          <td class="paramname"><em>longOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>isLastSeq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9b5f39b04f25f22e9299d7f1baf82efc">ZSTD_decodeSequence()</a>: <code>longOffsets</code> : tells the decoder to reload more bit while decoding large offsets only used in 32-bit mode </p><dl class="section return"><dt>Returns</dt><dd>: Sequence (litL + matchL + offset) </dd></dl>

</div>
</div>
<a id="a0fb290eb615bc723cfc4877d3d116dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb290eb615bc723cfc4877d3d116dd7">&#9670;&nbsp;</a></span>ZSTD_decodingBufferSize_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decodingBufferSize_min </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>windowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>frameContentSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer-less streaming decompression (synchronous mode)</p>
<p>A ZSTD_DCtx object is required to track streaming operations. Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it. A ZSTD_DCtx object can be reused multiple times.</p>
<p>First typical operation is to retrieve frame parameters, using <a class="el" href="zstd_8c.html#aff97a2bf22193cbc22660738a34b09e6">ZSTD_getFrameHeader()</a>. Frame header is extracted from the beginning of compressed frame, so providing only the frame's beginning is enough. Data fragment must be large enough to ensure successful decoding. <code>ZSTD_frameHeaderSize_max</code> bytes is guaranteed to always be large enough. result : 0 : successful decoding, the <code>ZSTD_frameHeader</code> structure is correctly filled. &gt;0 : <code>srcSize</code> is too small, please provide at least result bytes on next attempt. errorCode, which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>.</p>
<p>It fills a <a class="el" href="structZSTD__FrameHeader.html">ZSTD_FrameHeader</a> structure with important information to correctly decode the frame, such as the dictionary ID, content size, or maximum back-reference distance (<code>windowSize</code>). Note that these values could be wrong, either because of data corruption, or because a 3rd party deliberately spoofs false information. As a consequence, check that values remain within valid application range. For example, do not allocate memory blindly, check that <code>windowSize</code> is within expectation. Each application can set its own limits, depending on local restrictions. For extended interoperability, it is recommended to support <code>windowSize</code> of at least 8 MB.</p>
<p><a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> needs previous data blocks during decompression, up to <code>windowSize</code> bytes. <a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> is very sensitive to contiguity, if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place, or that previous contiguous segment is large enough to properly handle maximum back-reference distance. There are multiple ways to guarantee this condition.</p>
<p>The most memory efficient way is to use a round buffer of sufficient size. Sufficient size is determined by invoking <a class="el" href="zstd_8c.html#a0fb290eb615bc723cfc4877d3d116dd7">ZSTD_decodingBufferSize_min()</a>, which can return an error code if required value is too large for current system (in 32-bits mode). In a round buffer methodology, <a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> decompresses each block next to previous one, up to the moment there is not enough room left in the buffer to guarantee decoding another full block, which maximum size is provided in <code>ZSTD_frameHeader</code> structure, field <code>blockSizeMax</code>. At which point, decoding can resume from the beginning of the buffer. Note that already decoded data stored in the buffer should be flushed before being overwritten.</p>
<p>There are alternatives possible, for example using two or more buffers of size <code>windowSize</code> each, though they consume more memory.</p>
<p>Finally, if you control the compression process, you can also ignore all buffer size rules, as long as the encoder and decoder progress in "lock-step", aka use exactly the same buffer sizes, break contiguity at the same place, etc.</p>
<p>Once buffers are setup, start decompression, with ZSTD_decompressBegin(). If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().</p>
<p>Then use ZSTD_nextSrcSizeToDecompress() and <a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> alternatively. ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to <a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a>. <a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> requires this <em>exact</em> amount of bytes, or it will fail.</p>
<p>result of <a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> is the number of bytes regenerated within 'dst' (necessarily &lt;= dstCapacity). It can be zero : it just means <a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> has decoded some metadata item. It can also be an error code, which can be tested with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>.</p>
<p>A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero. Context can then be reset to start a new decompression.</p>
<p>Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType(). This information is not required to properly decode a frame.</p>
<p>== Special case : skippable frames ==</p>
<p>Skippable frames allow integration of user-defined data into a flow of concatenated frames. Skippable frames will be ignored (skipped) by decompressor. The format of skippable frames is as follows : a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits c) Frame Content - any content (User Data) of length equal to Frame Size For skippable frames <a class="el" href="zstd_8c.html#aff97a2bf22193cbc22660738a34b09e6">ZSTD_getFrameHeader()</a> returns zfhPtr-&gt;frameType==ZSTD_skippableFrame. For skippable frames <a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> always returns 0 : it only skips the content. when frame content size is not known, pass in frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN </p>

</div>
</div>
<a id="ad1667ea9aa85971c60ebca267d9540d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1667ea9aa85971c60ebca267d9540d9">&#9670;&nbsp;</a></span>ZSTD_decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decompress </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>compressedSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ad1667ea9aa85971c60ebca267d9540d9">ZSTD_decompress()</a> : <code>compressedSize</code> : must be the <em>exact</em> size of some number of compressed and/or skippable frames. Multiple compressed frames can be decompressed at once with this method. The result will be the concatenation of all decompressed frames, back to back. <code>dstCapacity</code> is an upper bound of originalSize to regenerate. First frame's decompressed size can be extracted using <a class="el" href="zstd_8c.html#a9e5f5f8580da4af3bf95471bb2420bee">ZSTD_getFrameContentSize()</a>. If maximum upper bound isn't known, prefer using streaming mode to decompress data. </p><dl class="section return"><dt>Returns</dt><dd>: the number of bytes decompressed into <code>dst</code> (&lt;= <code>dstCapacity</code>), or an errorCode if it fails (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>). </dd></dl>

</div>
</div>
<a id="ae313caadb1f107f1902ee7b5e1fd20a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae313caadb1f107f1902ee7b5e1fd20a0">&#9670;&nbsp;</a></span>ZSTD_decompress_usingDDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decompress_usingDDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td>
          <td class="paramname"><em>ddict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ae313caadb1f107f1902ee7b5e1fd20a0">ZSTD_decompress_usingDDict()</a> : Decompression using a digested Dictionary. Recommended when same dictionary is used multiple times.</p>
<p><a class="el" href="zstd_8c.html#ae313caadb1f107f1902ee7b5e1fd20a0">ZSTD_decompress_usingDDict()</a> : Decompression using a pre-digested Dictionary Use dictionary without significant overhead. </p>

</div>
</div>
<a id="a618de4daf5319f07706ab01385292416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618de4daf5319f07706ab01385292416">&#9670;&nbsp;</a></span>ZSTD_decompress_usingDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decompress_usingDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a618de4daf5319f07706ab01385292416">ZSTD_decompress_usingDict()</a> : Decompression using a known Dictionary. Dictionary must be identical to the one used during compression. Note : This function loads the dictionary, resulting in significant startup delay. It's intended for a dictionary used only once. Note : When <code>dict == NULL || dictSize &lt; 8</code> no dictionary is used. </p>

</div>
</div>
<a id="adb06c2696dff08081184a1d5944a3946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb06c2696dff08081184a1d5944a3946">&#9670;&nbsp;</a></span>ZSTD_decompressBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long ZSTD_decompressBound </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#adb06c2696dff08081184a1d5944a3946">ZSTD_decompressBound()</a> : <code>src</code> should point to the start of a series of ZSTD encoded and/or skippable frames <code>srcSize</code> must be the <em>exact</em> size of this series (i.e. there should be a frame boundary at <code>src + srcSize</code>) </p><dl class="section return"><dt>Returns</dt><dd>: - upper-bound for the decompressed size of all data in all successive frames<ul>
<li>if an error occurred: ZSTD_CONTENTSIZE_ERROR</li>
</ul>
</dd></dl>
<p>note 1 : an error can occur if <code>src</code> contains an invalid or incorrectly formatted frame. note 2 : the upper-bound is exact when the decompressed size field is available in every ZSTD encoded frame of <code>src</code>. in this case, <code>ZSTD_findDecompressedSize</code> and <code>ZSTD_decompressBound</code> return the same value. note 3 : when the decompressed size field isn't available, the upper-bound for that frame is calculated by: upper-bound = # blocks * min(128 KB, Window_Size)</p>
<p><a class="el" href="zstd_8c.html#adb06c2696dff08081184a1d5944a3946">ZSTD_decompressBound()</a> : compatible with legacy mode <code>src</code> must point to the start of a ZSTD frame or a skippable frame <code>srcSize</code> must be at least as large as the frame contained </p><dl class="section return"><dt>Returns</dt><dd>: the maximum decompressed size of the compressed source </dd></dl>

</div>
</div>
<a id="aebff1bb57c32239b35f2b5fd4c391159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebff1bb57c32239b35f2b5fd4c391159">&#9670;&nbsp;</a></span>ZSTD_decompressContinue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decompressContinue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aebff1bb57c32239b35f2b5fd4c391159">ZSTD_decompressContinue()</a> : srcSize : must be the exact nb of bytes expected (see ZSTD_nextSrcSizeToDecompress()) </p><dl class="section return"><dt>Returns</dt><dd>: nb of bytes generated into <code>dst</code> (necessarily &lt;= `dstCapacity) or an error code, which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a> </dd></dl>

</div>
</div>
<a id="ad65d6c1880cffdf1120e06277a2d0a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65d6c1880cffdf1120e06277a2d0a5b">&#9670;&nbsp;</a></span>ZSTD_decompressDCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decompressDCtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ad65d6c1880cffdf1120e06277a2d0a5b">ZSTD_decompressDCtx()</a> : Same as <a class="el" href="zstd_8c.html#ad1667ea9aa85971c60ebca267d9540d9">ZSTD_decompress()</a>, requires an allocated ZSTD_DCtx. Compatible with sticky parameters (see below). </p>

</div>
</div>
<a id="ac079fdb80692d42f2ea5421bd83f8542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac079fdb80692d42f2ea5421bd83f8542">&#9670;&nbsp;</a></span>ZSTD_decompressionMargin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decompressionMargin </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ac079fdb80692d42f2ea5421bd83f8542">ZSTD_decompressionMargin()</a> : Zstd supports in-place decompression, where the input and output buffers overlap. In this case, the output buffer must be at least (Margin + Output_Size) bytes large, and the input buffer must be at the end of the output buffer.</p>
<p>_______________________ Output Buffer ________________________ | | | ____ Input Buffer ____| | | | v v v |------------------------------------&mdash;|--------&mdash;|-------&mdash;| ^ ^ ^ |___________________ Output_Size ___________________|_ Margin _|</p>
<p>NOTE: See also <a class="el" href="zstd_8c.html#a39a1ac72ca8747f89743a0c134f085d2">ZSTD_DECOMPRESSION_MARGIN()</a>. NOTE: This applies only to single-pass decompression through <a class="el" href="zstd_8c.html#ad1667ea9aa85971c60ebca267d9540d9">ZSTD_decompress()</a> or <a class="el" href="zstd_8c.html#ad65d6c1880cffdf1120e06277a2d0a5b">ZSTD_decompressDCtx()</a>. NOTE: This function supports multi-frame input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The compressed frame(s) </td></tr>
    <tr><td class="paramname">srcSize</td><td>The size of the compressed frame(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decompression margin or an error that can be checked with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>. </dd></dl>

</div>
</div>
<a id="a4ccda24ca50a1a35ea76a97b13edf398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccda24ca50a1a35ea76a97b13edf398">&#9670;&nbsp;</a></span>ZSTD_decompressStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decompressStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *&#160;</td>
          <td class="paramname"><em>zds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer</a> *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a4ccda24ca50a1a35ea76a97b13edf398">ZSTD_decompressStream()</a> : Streaming decompression function. Call repetitively to consume full input updating it as necessary. Function will update both input and output <code>pos</code> fields exposing current state via these fields:</p><ul>
<li><code>input.pos &lt; input.size</code>, some input remaining and caller should provide remaining input on the next call.</li>
<li><code>output.pos &lt; output.size</code>, decoder flushed internal output buffer.</li>
<li><code>output.pos == output.size</code>, unflushed data potentially present in the internal buffers, check <a class="el" href="zstd_8c.html#a4ccda24ca50a1a35ea76a97b13edf398">ZSTD_decompressStream()</a> <dl class="section return"><dt>Returns</dt><dd>value, if &gt; 0, invoke it again to flush remaining data to output. Note : with no additional input, amount of data flushed &lt;= ZSTD_BLOCKSIZE_MAX.</dd>
<dd>
: 0 when a frame is completely decoded and fully flushed, or an error code, which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>, or any other value &gt; 0, which means there is some decoding or flushing to do to complete current frame.</dd></dl>
Note: when an operation returns with an error code, the @zds state may be left in undefined state. It's UB to invoke <code><a class="el" href="zstd_8c.html#a4ccda24ca50a1a35ea76a97b13edf398">ZSTD_decompressStream()</a></code> on such a state. In order to re-use such a state, it must be first reset, which can be done explicitly (<code><a class="el" href="zstd_8c.html#a614f5b2e6aa19d66eb91223ff23c99ed">ZSTD_DCtx_reset()</a></code>), or is implied for operations starting some new decompression job (<code>ZSTD_initDStream</code>, <code><a class="el" href="zstd_8c.html#ad65d6c1880cffdf1120e06277a2d0a5b">ZSTD_decompressDCtx()</a></code>, <code><a class="el" href="zstd_8c.html#a618de4daf5319f07706ab01385292416">ZSTD_decompress_usingDict()</a></code>) </li>
</ul>

</div>
</div>
<a id="acf891757361cebbc29be37c8228202d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf891757361cebbc29be37c8228202d4">&#9670;&nbsp;</a></span>ZSTD_decompressStream_simpleArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_decompressStream_simpleArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dstPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>srcPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#acf891757361cebbc29be37c8228202d4">ZSTD_decompressStream_simpleArgs()</a> : Same as <a class="el" href="zstd_8c.html#a4ccda24ca50a1a35ea76a97b13edf398">ZSTD_decompressStream()</a>, but using only integral types as arguments. This can be helpful for binders from dynamic languages which have troubles handling structures containing memory pointers. </p>

</div>
</div>
<a id="a5f19080983172493738f0075a51e7fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f19080983172493738f0075a51e7fba">&#9670;&nbsp;</a></span>ZSTD_defaultCLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ZSTD_defaultCLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>default compression level, specified by ZSTD_CLEVEL_DEFAULT, requires v1.5.0+ </p>

</div>
</div>
<a id="a102dc10a9332b4dcb3da3d0e5f1bfb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102dc10a9332b4dcb3da3d0e5f1bfb5d">&#9670;&nbsp;</a></span>ZSTD_dParam_getBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__bounds.html">ZSTD_bounds</a> ZSTD_dParam_getBounds </td>
          <td>(</td>
          <td class="paramtype">ZSTD_dParameter&#160;</td>
          <td class="paramname"><em>dParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a102dc10a9332b4dcb3da3d0e5f1bfb5d">ZSTD_dParam_getBounds()</a> : All parameters must belong to an interval with lower and upper bounds, otherwise they will either trigger an error or be automatically clamped. </p><dl class="section return"><dt>Returns</dt><dd>: a structure, <a class="el" href="structZSTD__bounds.html">ZSTD_bounds</a>, which contains<ul>
<li>an error status field, which must be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a></li>
<li>both lower and upper bounds, inclusive </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab4b2f64ffe93385932276d5776ae44c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b2f64ffe93385932276d5776ae44c2">&#9670;&nbsp;</a></span>ZSTD_DStreamInSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DStreamInSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recommended size for input buffer </p>

</div>
</div>
<a id="a9a8b9180d51fed828bdddf1fc970cc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8b9180d51fed828bdddf1fc970cc58">&#9670;&nbsp;</a></span>ZSTD_DStreamOutSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_DStreamOutSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. </p>

</div>
</div>
<a id="a1032e49a27beea5475f2bf91f3294116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1032e49a27beea5475f2bf91f3294116">&#9670;&nbsp;</a></span>ZSTD_endStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_endStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to ZSTD_compressStream2(zcs, output, &amp;emptyInput, ZSTD_e_end). </p>

</div>
</div>
<a id="aa2fc7a8d35315185605a25fd8c7d7b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fc7a8d35315185605a25fd8c7d7b51">&#9670;&nbsp;</a></span>ZSTD_estimateCCtxSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_estimateCCtxSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCompressionLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_estimate*() : These functions make it possible to estimate memory usage of a future {D,C}Ctx, before its creation. This is useful in combination with ZSTD_initStatic(), which makes it possible to employ a static buffer for ZSTD_CCtx* state.</p>
<p><a class="el" href="zstd_8c.html#aa2fc7a8d35315185605a25fd8c7d7b51">ZSTD_estimateCCtxSize()</a> will provide a memory budget large enough to compress data of any size using one-shot compression <a class="el" href="zstd_8c.html#a16db44e4760f1b4ac38cb50ab2464a59">ZSTD_compressCCtx()</a> or <a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a> associated with any compression level up to max specified one. The estimate will assume the input may be arbitrarily large, which is the worst case.</p>
<p>Note that the size estimation is specific for one-shot compression, it is not valid for streaming (see ZSTD_estimateCStreamSize*()) nor other potential ways of using a ZSTD_CCtx* state.</p>
<p>When srcSize can be bound by a known and rather "small" value, this knowledge can be used to provide a tighter budget estimation because the ZSTD_CCtx* state will need less memory for small inputs. This tighter estimation can be provided by employing more advanced functions ZSTD_estimateCCtxSize_usingCParams(), which can be used in tandem with <a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams()</a>, and ZSTD_estimateCCtxSize_usingCCtxParams(), which can be used in tandem with <a class="el" href="zstd_8c.html#a1d05d6678c081447914362b2fd2ef7ea">ZSTD_CCtxParams_setParameter()</a>. Both can be used to estimate memory using custom compression parameters and arbitrary srcSize limits.</p>
<p>Note : only single-threaded compression is supported. ZSTD_estimateCCtxSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is &gt;= 1. </p>

</div>
</div>
<a id="af5a1d21490a08200ea600cae0fb3e350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a1d21490a08200ea600cae0fb3e350">&#9670;&nbsp;</a></span>ZSTD_estimateCDictSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_estimateCDictSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_estimate?DictSize() : <a class="el" href="zstd_8c.html#af5a1d21490a08200ea600cae0fb3e350">ZSTD_estimateCDictSize()</a> will bet that src size is relatively "small", and content is copied, like <a class="el" href="zstd_8c.html#aab922a70d7520918a7d8def0dd138412">ZSTD_createCDict()</a>. <a class="el" href="zstd_8c.html#a5c84a6149f417966cf33b72f074b010d">ZSTD_estimateCDictSize_advanced()</a> makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced(). Note : dictionaries created by reference (<code>ZSTD_dlm_byRef</code>) are logically smaller. </p>

</div>
</div>
<a id="a5c84a6149f417966cf33b72f074b010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c84a6149f417966cf33b72f074b010d">&#9670;&nbsp;</a></span>ZSTD_estimateCDictSize_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_estimateCDictSize_advanced </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td>
          <td class="paramname"><em>cParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a>&#160;</td>
          <td class="paramname"><em>dictLoadMethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a5c84a6149f417966cf33b72f074b010d">ZSTD_estimateCDictSize_advanced()</a> : Estimate amount of memory that will be needed to create a dictionary with following arguments </p>

</div>
</div>
<a id="a742e99e45f0994e0771caa9e9922363e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742e99e45f0994e0771caa9e9922363e">&#9670;&nbsp;</a></span>ZSTD_estimateCStreamSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_estimateCStreamSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCompressionLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a742e99e45f0994e0771caa9e9922363e">ZSTD_estimateCStreamSize()</a> : <a class="el" href="zstd_8c.html#a742e99e45f0994e0771caa9e9922363e">ZSTD_estimateCStreamSize()</a> will provide a memory budget large enough for streaming compression using any compression level up to the max specified one. It will also consider src size to be arbitrarily "large", which is a worst case scenario. If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation. ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with <a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams()</a> to create cParams from compressionLevel. ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with <a class="el" href="zstd_8c.html#a1d05d6678c081447914362b2fd2ef7ea">ZSTD_CCtxParams_setParameter()</a>. Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is &gt;= 1. Note : CStream size estimation is only correct for single-threaded compression. ZSTD_estimateCStreamSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is &gt;= 1. Note 2 : ZSTD_estimateCStreamSize* functions are not compatible with the Block-Level Sequence Producer API at this time. Size estimates assume that no external sequence producer is registered.</p>
<p>ZSTD_DStream memory budget depends on frame's window Size. This information can be passed manually, using ZSTD_estimateDStreamSize, or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame(); Any frame requesting a window size larger than max specified one will be rejected. Note : if streaming is init with function ZSTD_init?Stream_usingDict(), an internal ?Dict will be created, which additional size is not estimated here. In this case, get total size by adding ZSTD_estimate?DictSize </p>

</div>
</div>
<a id="a58508bbc810517a70a002961b9aa855c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58508bbc810517a70a002961b9aa855c">&#9670;&nbsp;</a></span>ZSTD_estimateDDictSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_estimateDDictSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a>&#160;</td>
          <td class="paramname"><em>dictLoadMethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a58508bbc810517a70a002961b9aa855c">ZSTD_estimateDDictSize()</a> : Estimate amount of memory that will be needed to create a dictionary for decompression. Note : dictionary created by reference using ZSTD_dlm_byRef are smaller </p>

</div>
</div>
<a id="ab1783c67ba35d176f3dc849ca64e03e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1783c67ba35d176f3dc849ca64e03e4">&#9670;&nbsp;</a></span>ZSTD_findDecompressedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long ZSTD_findDecompressedSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ab1783c67ba35d176f3dc849ca64e03e4">ZSTD_findDecompressedSize()</a> : <code>src</code> should point to the start of a series of ZSTD encoded and/or skippable frames <code>srcSize</code> must be the <em>exact</em> size of this series (i.e. there should be a frame boundary at <code>src + srcSize</code>) </p><dl class="section return"><dt>Returns</dt><dd>: - decompressed size of all data in all successive frames<ul>
<li>if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN</li>
<li>if an error occurred: ZSTD_CONTENTSIZE_ERROR</li>
</ul>
</dd></dl>
<p>note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode. When <code>return==ZSTD_CONTENTSIZE_UNKNOWN</code>, data to decompress could be any size. In which case, it's necessary to use streaming mode to decompress data. note 2 : decompressed size is always present when compression is done with <a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress()</a> note 3 : decompressed size can be very large (64-bits value), potentially larger than what local system can handle as a single memory segment. In which case, it's necessary to use streaming mode to decompress data. note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified. Always ensure result fits within application's authorized limits. Each application can set its own limits. note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to read each contained frame header. This is fast as most of the data is skipped, however it does mean that all frame data must be present and valid.</p>
<p><a class="el" href="zstd_8c.html#ab1783c67ba35d176f3dc849ca64e03e4">ZSTD_findDecompressedSize()</a> : <code>srcSize</code> must be the exact length of some number of ZSTD compressed and/or skippable frames note: compatible with legacy mode </p><dl class="section return"><dt>Returns</dt><dd>: decompressed size of the frames contained </dd></dl>

</div>
</div>
<a id="abd57094fdf6ff305bc2bab286cade7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd57094fdf6ff305bc2bab286cade7cc">&#9670;&nbsp;</a></span>ZSTD_findFrameCompressedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_findFrameCompressedSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#abd57094fdf6ff305bc2bab286cade7cc">ZSTD_findFrameCompressedSize()</a> : Requires v1.4.0+ <code>src</code> should point to the start of a ZSTD frame or skippable frame. <code>srcSize</code> must be &gt;= first frame size </p><dl class="section return"><dt>Returns</dt><dd>: the compressed size of the first frame starting at <code>src</code>, suitable to pass as <code>srcSize</code> to <code>ZSTD_decompress</code> or similar, or an error code if input is invalid Note 1: this method is called _find*() because it's not enough to read the header, it may have to scan through the frame's content, to reach its end. Note 2: this method also works with Skippable Frames. In which case, it returns the size of the complete skippable frame, which is always equal to its content size + 8 bytes for headers.</dd></dl>
<p><a class="el" href="zstd_8c.html#abd57094fdf6ff305bc2bab286cade7cc">ZSTD_findFrameCompressedSize()</a> : See docs in <a class="el" href="zstd_8h_source.html">zstd.h</a> Note: compatible with legacy mode </p>

</div>
</div>
<a id="a526a86c539c8ed7f06a8400dccc458dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526a86c539c8ed7f06a8400dccc458dd">&#9670;&nbsp;</a></span>ZSTD_flushStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_flushStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to ZSTD_compressStream2(zcs, output, &amp;emptyInput, ZSTD_e_flush).</p>
<p><a class="el" href="zstd_8c.html#a526a86c539c8ed7f06a8400dccc458dd">ZSTD_flushStream()</a> : </p><dl class="section return"><dt>Returns</dt><dd>: amount of data remaining to flush </dd></dl>

</div>
</div>
<a id="a9da67395f18e3c94c2808cc4e7cc12a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da67395f18e3c94c2808cc4e7cc12a4">&#9670;&nbsp;</a></span>ZSTD_frameHeaderSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_frameHeaderSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9da67395f18e3c94c2808cc4e7cc12a4">ZSTD_frameHeaderSize()</a> : srcSize must be large enough, aka &gt;= ZSTD_FRAMEHEADERSIZE_PREFIX. </p><dl class="section return"><dt>Returns</dt><dd>: size of the Frame Header, or an error code (if srcSize is too small)</dd></dl>
<p><a class="el" href="zstd_8c.html#a9da67395f18e3c94c2808cc4e7cc12a4">ZSTD_frameHeaderSize()</a> : srcSize must be &gt;= ZSTD_frameHeaderSize_prefix. </p><dl class="section return"><dt>Returns</dt><dd>: size of the Frame Header, or an error code (if srcSize is too small) </dd></dl>

</div>
</div>
<a id="a163bfbf4f7ece81967178ebc86f17667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163bfbf4f7ece81967178ebc86f17667">&#9670;&nbsp;</a></span>ZSTD_freeCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_freeCDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>CDict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a163bfbf4f7ece81967178ebc86f17667">ZSTD_freeCDict()</a> : Function frees memory allocated by <a class="el" href="zstd_8c.html#aab922a70d7520918a7d8def0dd138412">ZSTD_createCDict()</a>. If a NULL pointer is passed, no operation is performed. </p>

</div>
</div>
<a id="a652594c16c4a53519a22ceac780a1158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652594c16c4a53519a22ceac780a1158">&#9670;&nbsp;</a></span>ZSTD_freeDDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_freeDDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td>
          <td class="paramname"><em>ddict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a652594c16c4a53519a22ceac780a1158">ZSTD_freeDDict()</a> : Function frees memory allocated with <a class="el" href="zstd_8c.html#a4f3598dadc58ed1b40f84c85f6da72a2">ZSTD_createDDict()</a> If a NULL pointer is passed, no operation is performed. </p>

</div>
</div>
<a id="ace25de051ef535d3ffc9868001417d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace25de051ef535d3ffc9868001417d3b">&#9670;&nbsp;</a></span>ZSTD_fseBitCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_fseBitCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a54dd08a75764e9f6058b47735da04eea">FSE_CTable</a> const *&#160;</td>
          <td class="paramname"><em>ctable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned const *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned const&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the cost in bits of encoding the distribution in count using ctable. Returns an error if ctable cannot represent all the symbols in count. </p>

</div>
</div>
<a id="a73fe7ad6ed4c7b4c9fbde2472650dd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fe7ad6ed4c7b4c9fbde2472650dd0e">&#9670;&nbsp;</a></span>ZSTD_generateSequences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_generateSequences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>zc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *&#160;</td>
          <td class="paramname"><em>outSeqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outSeqsCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a73fe7ad6ed4c7b4c9fbde2472650dd0e">ZSTD_generateSequences()</a> : WARNING: This function is meant for debugging and informational purposes ONLY! Its implementation is flawed, and it will be deleted in a future version. It is not guaranteed to succeed, as there are several cases where it will give up and fail. You should NOT use this function in production code.</p>
<p>This function is deprecated, and will be removed in a future version.</p>
<p>Generate sequences using <a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a>, given a source buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zc</td><td>The compression context to be used for <a class="el" href="zstd_8c.html#a48377b8080ba9ebc5651db59d4a63f3f">ZSTD_compress2()</a>. Set any compression parameters you need on this context. </td></tr>
    <tr><td class="paramname">outSeqs</td><td>The output sequences buffer of size <code>outSeqsSize</code> </td></tr>
    <tr><td class="paramname">outSeqsCapacity</td><td>The size of the output sequences buffer. ZSTD_sequenceBound(srcSize) is an upper bound on the number of sequences that can be generated. </td></tr>
    <tr><td class="paramname">src</td><td>The source buffer to generate sequences from of size <code>srcSize</code>. </td></tr>
    <tr><td class="paramname">srcSize</td><td>The size of the source buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Each block will end with a dummy sequence with offset == 0, matchLength == 0, and litLength == length of last literals. litLength may be == 0, and if so, then the sequence of (of: 0 ml: 0 ll: 0) simply acts as a block delimiter.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of sequences generated, necessarily less than ZSTD_sequenceBound(srcSize), or an error code that can be checked with <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>. </dd></dl>

</div>
</div>
<a id="a1254a7c7cfebe755e7ab7339894fedcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1254a7c7cfebe755e7ab7339894fedcb">&#9670;&nbsp;</a></span>ZSTD_getBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_getBlockSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block level API (DEPRECATED) <br  />
</p>
<p>This API is deprecated in favor of the regular compression API. You can get the frame header down to 2 bytes by setting:</p><ul>
<li>ZSTD_c_format = ZSTD_f_zstd1_magicless</li>
<li>ZSTD_c_contentSizeFlag = 0</li>
<li>ZSTD_c_checksumFlag = 0</li>
<li>ZSTD_c_dictIDFlag = 0</li>
</ul>
<p>This API is not as well tested as our normal API, so we recommend not using it. We will be removing it in a future version. If the normal API doesn't provide the functionality you need, please open a GitHub issue.</p>
<p>Block functions produce and decode raw zstd blocks, without frame metadata. Frame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (&lt; 100 bytes). But users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes.</p>
<p>A few rules to respect :</p><ul>
<li>Compressing and decompressing require a context structure<ul>
<li>Use ZSTD_createCCtx() and ZSTD_createDCtx()</li>
</ul>
</li>
<li>It is necessary to init context before starting<ul>
<li>compression : any ZSTD_compressBegin*() variant, including with dictionary</li>
<li>decompression : any ZSTD_decompressBegin*() variant, including with dictionary</li>
</ul>
</li>
<li>Block size is limited, it must be &lt;= <a class="el" href="zstd_8c.html#a1254a7c7cfebe755e7ab7339894fedcb">ZSTD_getBlockSize()</a> &lt;= ZSTD_BLOCKSIZE_MAX == 128 KB<ul>
<li>If input is larger than a block size, it's necessary to split input data into multiple blocks</li>
<li>For inputs larger than a single block, consider using regular <a class="el" href="zstd_8c.html#ac10ee027998fbfbedc71961633791955">ZSTD_compress()</a> instead. Frame metadata is not that costly, and quickly becomes negligible as source size grows larger than a block.</li>
</ul>
</li>
<li>When a block is considered not compressible enough, ZSTD_compressBlock() result will be 0 (zero) ! ===&gt; In which case, nothing is produced into <code>dst</code> !<ul>
<li>User <b>must</b> test for such outcome and deal directly with uncompressed data</li>
<li>A block cannot be declared incompressible if ZSTD_compressBlock() return value was != 0. Doing so would mess up with statistics history, leading to potential data corruption.</li>
<li>ZSTD_decompressBlock() <em>doesn't accept uncompressed data as input</em> !!</li>
<li>In case of multiple successive blocks, should some of them be uncompressed, decoder must be informed of their existence in order to follow proper history. Use <a class="el" href="zstd_8c.html#ad324c6f4cfa62ee290f487baba56a87f">ZSTD_insertBlock()</a> for such a case. </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ae6d9ed5da5bfdf578587adfbff628914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d9ed5da5bfdf578587adfbff628914">&#9670;&nbsp;</a></span>ZSTD_getcBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_getcBlockSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblockProperties__t.html">blockProperties_t</a> *&#160;</td>
          <td class="paramname"><em>bpPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ae6d9ed5da5bfdf578587adfbff628914">ZSTD_getcBlockSize()</a> : Provides the size of compressed block from block header <code>src</code> </p>

</div>
</div>
<a id="ae0ff760b75dc576f1cd0d2f9b2aab232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ff760b75dc576f1cd0d2f9b2aab232">&#9670;&nbsp;</a></span>ZSTD_getCParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> ZSTD_getCParams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>srcSizeHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams()</a> : </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> structure for a selected compression level and estimated srcSize. <code>estimatedSrcSize</code> value is optional, select 0 if not known</dd></dl>
<p><a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams()</a> : </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> structure for a selected compression level, srcSize and dictSize. Size values are optional, provide 0 if not known or unused </dd></dl>

</div>
</div>
<a id="af7224903a99baeada3c87a06b38a4b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7224903a99baeada3c87a06b38a4b97">&#9670;&nbsp;</a></span>ZSTD_getCParamsFromCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> ZSTD_getCParamsFromCDict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#af7224903a99baeada3c87a06b38a4b97">ZSTD_getCParamsFromCDict()</a> : as the name implies </p>

</div>
</div>
<a id="a649e1fd37871a2dfed7833a7741735f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649e1fd37871a2dfed7833a7741735f8">&#9670;&nbsp;</a></span>ZSTD_getDecompressedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long ZSTD_getDecompressedSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a649e1fd37871a2dfed7833a7741735f8">ZSTD_getDecompressedSize()</a> (obsolete): This function is now obsolete, in favor of <a class="el" href="zstd_8c.html#a9e5f5f8580da4af3bf95471bb2420bee">ZSTD_getFrameContentSize()</a>. Both functions work the same way, but <a class="el" href="zstd_8c.html#a649e1fd37871a2dfed7833a7741735f8">ZSTD_getDecompressedSize()</a> blends "empty", "unknown" and "error" results to the same return value (0), while <a class="el" href="zstd_8c.html#a9e5f5f8580da4af3bf95471bb2420bee">ZSTD_getFrameContentSize()</a> gives them separate return values. </p><dl class="section return"><dt>Returns</dt><dd>: decompressed size of <code>src</code> frame content <em>if known and not empty</em>, 0 otherwise.</dd></dl>
<p><a class="el" href="zstd_8c.html#a649e1fd37871a2dfed7833a7741735f8">ZSTD_getDecompressedSize()</a> : compatible with legacy mode </p><dl class="section return"><dt>Returns</dt><dd>: decompressed size if known, 0 otherwise note : 0 can mean any of the following :<ul>
<li>frame content is empty</li>
<li>decompressed size field is not present in frame header</li>
<li>frame header unknown / not supported</li>
<li>frame header not complete (<code>srcSize</code> too small) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a71788eb03810e9b989c90534d6edb9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71788eb03810e9b989c90534d6edb9f0">&#9670;&nbsp;</a></span>ZSTD_getDictID_fromCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZSTD_getDictID_fromCDict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a71788eb03810e9b989c90534d6edb9f0">ZSTD_getDictID_fromCDict()</a> : Requires v1.5.0+ Provides the dictID of the dictionary loaded into <code>cdict</code>. If </p><dl class="section return"><dt>Returns</dt><dd>== 0, the dictionary is not conformant to Zstandard specification, or empty. Non-conformant dictionaries can still be loaded, but as content-only dictionaries.</dd></dl>
<p><a class="el" href="zstd_8c.html#a71788eb03810e9b989c90534d6edb9f0">ZSTD_getDictID_fromCDict()</a> : Provides the dictID of the dictionary loaded into <code>cdict</code>. If </p><dl class="section return"><dt>Returns</dt><dd>== 0, the dictionary is not conformant to Zstandard specification, or empty. Non-conformant dictionaries can still be loaded, but as content-only dictionaries. </dd></dl>

</div>
</div>
<a id="a220ae369de09fde1ed3b71dd270ed6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220ae369de09fde1ed3b71dd270ed6a6">&#9670;&nbsp;</a></span>ZSTD_getDictID_fromDDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZSTD_getDictID_fromDDict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td>
          <td class="paramname"><em>ddict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a220ae369de09fde1ed3b71dd270ed6a6">ZSTD_getDictID_fromDDict()</a> : Requires v1.4.0+ Provides the dictID of the dictionary loaded into <code>ddict</code>. If </p><dl class="section return"><dt>Returns</dt><dd>== 0, the dictionary is not conformant to Zstandard specification, or empty. Non-conformant dictionaries can still be loaded, but as content-only dictionaries.</dd></dl>
<p><a class="el" href="zstd_8c.html#a220ae369de09fde1ed3b71dd270ed6a6">ZSTD_getDictID_fromDDict()</a> : Provides the dictID of the dictionary loaded into <code>ddict</code>. If </p><dl class="section return"><dt>Returns</dt><dd>== 0, the dictionary is not conformant to Zstandard specification, or empty. Non-conformant dictionaries can still be loaded, but as content-only dictionaries. </dd></dl>

</div>
</div>
<a id="a9edd273c98a72589bca72c7d66334748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edd273c98a72589bca72c7d66334748">&#9670;&nbsp;</a></span>ZSTD_getDictID_fromDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZSTD_getDictID_fromDict </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9edd273c98a72589bca72c7d66334748">ZSTD_getDictID_fromDict()</a> : Requires v1.4.0+ Provides the dictID stored within dictionary. if </p><dl class="section return"><dt>Returns</dt><dd>== 0, the dictionary is not conformant with Zstandard specification. It can still be loaded, but as a content-only dictionary.</dd></dl>
<p><a class="el" href="zstd_8c.html#a9edd273c98a72589bca72c7d66334748">ZSTD_getDictID_fromDict()</a> : Provides the dictID stored within dictionary. if </p><dl class="section return"><dt>Returns</dt><dd>== 0, the dictionary is not conformant with Zstandard specification. It can still be loaded, but as a content-only dictionary. </dd></dl>

</div>
</div>
<a id="a87e949ff08af79fcbe990465a055aaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e949ff08af79fcbe990465a055aaa5">&#9670;&nbsp;</a></span>ZSTD_getDictID_fromFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZSTD_getDictID_fromFrame </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a87e949ff08af79fcbe990465a055aaa5">ZSTD_getDictID_fromFrame()</a> : Requires v1.4.0+ Provides the dictID required to decompressed the frame stored within <code>src</code>. If </p><dl class="section return"><dt>Returns</dt><dd>== 0, the dictID could not be decoded. This could for one of the following reasons :<ul>
<li>The frame does not require a dictionary to be decoded (most common case).</li>
<li>The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden piece of information. Note : this use case also happens when using a non-conformant dictionary.</li>
<li><code>srcSize</code> is too small, and as a result, the frame header could not be decoded (only possible if <code>srcSize &lt; ZSTD_FRAMEHEADERSIZE_MAX</code>).</li>
<li>This is not a Zstandard frame. When identifying the exact failure cause, it's possible to use <a class="el" href="zstd_8c.html#aff97a2bf22193cbc22660738a34b09e6">ZSTD_getFrameHeader()</a>, which will provide a more precise error code.</li>
</ul>
</dd></dl>
<p><a class="el" href="zstd_8c.html#a87e949ff08af79fcbe990465a055aaa5">ZSTD_getDictID_fromFrame()</a> : Provides the dictID required to decompress frame stored within <code>src</code>. If </p><dl class="section return"><dt>Returns</dt><dd>== 0, the dictID could not be decoded. This could for one of the following reasons :<ul>
<li>The frame does not require a dictionary (most common case).</li>
<li>The frame was built with dictID intentionally removed. Needed dictionary is a hidden piece of information. Note : this use case also happens when using a non-conformant dictionary.</li>
<li><code>srcSize</code> is too small, and as a result, frame header could not be decoded. Note : possible if <code>srcSize &lt; ZSTD_FRAMEHEADERSIZE_MAX</code>.</li>
<li>This is not a Zstandard frame. When identifying the exact failure cause, it's possible to use <a class="el" href="zstd_8c.html#aff97a2bf22193cbc22660738a34b09e6">ZSTD_getFrameHeader()</a>, which will provide a more precise error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aef04aa44c49420ae1fd65a855f7c25fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef04aa44c49420ae1fd65a855f7c25fc">&#9670;&nbsp;</a></span>ZSTD_getErrorCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ZSTD_ErrorCode ZSTD_getErrorCode </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_getError() : convert a <code>size_t</code> function result into a proper ZSTD_errorCode enum </p>

</div>
</div>
<a id="a7bc2497b2d23d0da90e96e669d938ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc2497b2d23d0da90e96e669d938ce0">&#9670;&nbsp;</a></span>ZSTD_getErrorName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ZSTD_getErrorName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>provides readable string from a function result</p>
<p><a class="el" href="zstd_8c.html#a7bc2497b2d23d0da90e96e669d938ce0">ZSTD_getErrorName()</a> : provides error code string from function result (useful for debugging) </p>

</div>
</div>
<a id="aa0e4ecc8ea4ad6359cdc9112661bfd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e4ecc8ea4ad6359cdc9112661bfd2b">&#9670;&nbsp;</a></span>ZSTD_getErrorString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ZSTD_getErrorString </td>
          <td>(</td>
          <td class="paramtype">ZSTD_ErrorCode&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as ZSTD_getErrorName, but using a <code>ZSTD_ErrorCode</code> enum argument</p>
<p><a class="el" href="zstd_8c.html#aa0e4ecc8ea4ad6359cdc9112661bfd2b">ZSTD_getErrorString()</a> : provides error code string from enum </p>

</div>
</div>
<a id="a9e5f5f8580da4af3bf95471bb2420bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5f5f8580da4af3bf95471bb2420bee">&#9670;&nbsp;</a></span>ZSTD_getFrameContentSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long ZSTD_getFrameContentSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9e5f5f8580da4af3bf95471bb2420bee">ZSTD_getFrameContentSize()</a> : compatible with legacy mode </p><dl class="section return"><dt>Returns</dt><dd>: decompressed size of the single frame pointed to be <code>src</code> if known, otherwise<ul>
<li>ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined</li>
<li>ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aff97a2bf22193cbc22660738a34b09e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff97a2bf22193cbc22660738a34b09e6">&#9670;&nbsp;</a></span>ZSTD_getFrameHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_getFrameHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__FrameHeader.html">ZSTD_FrameHeader</a> *&#160;</td>
          <td class="paramname"><em>zfhPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aff97a2bf22193cbc22660738a34b09e6">ZSTD_getFrameHeader()</a> : decode Frame Header into <code>zfhPtr</code>, or requires larger <code>srcSize</code>. </p><dl class="section return"><dt>Returns</dt><dd>: 0 =&gt; header is complete, <code>zfhPtr</code> is correctly filled, &gt;0 =&gt; <code>srcSize</code> is too small, </dd>
<dd>
value is the wanted <code>srcSize</code> amount, <code>zfhPtr</code> is not filled, or an error code, which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a></dd></dl>
<p><a class="el" href="zstd_8c.html#aff97a2bf22193cbc22660738a34b09e6">ZSTD_getFrameHeader()</a> : decode Frame Header, or require larger <code>srcSize</code>. note : this function does not consume input, it only reads it. </p><dl class="section return"><dt>Returns</dt><dd>: 0, <code>zfhPtr</code> is correctly filled, &gt;0, <code>srcSize</code> is too small, value is wanted <code>srcSize</code> amount, or an error code, which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a> </dd></dl>

</div>
</div>
<a id="a7a477ddc60a332b675db0a8f1c0cac8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a477ddc60a332b675db0a8f1c0cac8e">&#9670;&nbsp;</a></span>ZSTD_getFrameHeader_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_getFrameHeader_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__FrameHeader.html">ZSTD_FrameHeader</a> *&#160;</td>
          <td class="paramname"><em>zfhPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_format_e&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a7a477ddc60a332b675db0a8f1c0cac8e">ZSTD_getFrameHeader_advanced()</a> : same as <a class="el" href="zstd_8c.html#aff97a2bf22193cbc22660738a34b09e6">ZSTD_getFrameHeader()</a>, with added capability to select a format (like ZSTD_f_zstd1_magicless)</p>
<p><a class="el" href="zstd_8c.html#a7a477ddc60a332b675db0a8f1c0cac8e">ZSTD_getFrameHeader_advanced()</a> : decode Frame Header, or require larger <code>srcSize</code>. note : only works for formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless </p><dl class="section return"><dt>Returns</dt><dd>: 0, <code>zfhPtr</code> is correctly filled, &gt;0, <code>srcSize</code> is too small, value is wanted <code>srcSize</code> amount, or an error code, which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a> </dd></dl>

</div>
</div>
<a id="a490a09a11a85f1d07f0fd24616025627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490a09a11a85f1d07f0fd24616025627">&#9670;&nbsp;</a></span>ZSTD_getLowestMatchIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC U32 ZSTD_getLowestMatchIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>windowLog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the lowest allowed match index. It may either be in the ext-dict or the prefix. </p>

</div>
</div>
<a id="a0fac416e05311464f030f33ee6264253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fac416e05311464f030f33ee6264253">&#9670;&nbsp;</a></span>ZSTD_getLowestPrefixIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC U32 ZSTD_getLowestPrefixIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>windowLog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the lowest allowed match index in the prefix. </p>

</div>
</div>
<a id="a7405de0de5192513fdc308082a88d926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7405de0de5192513fdc308082a88d926">&#9670;&nbsp;</a></span>ZSTD_getParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a> ZSTD_getParams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>srcSizeHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a7405de0de5192513fdc308082a88d926">ZSTD_getParams()</a> : same as <a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams()</a>, but </p><dl class="section return"><dt>Returns</dt><dd>a full <code><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a></code> object instead of sub-component <code><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a></code>. All fields of <code><a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a></code> are set to default : contentSize=1, checksum=0, noDictID=0</dd></dl>
<p><a class="el" href="zstd_8c.html#a7405de0de5192513fdc308082a88d926">ZSTD_getParams()</a> : same idea as <a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams()</a> </p><dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a></code> structure (instead of <code><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a></code>). Fields of <code><a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a></code> are set to default values </dd></dl>

</div>
</div>
<a id="ab6fe97fad779223a0024b6f8f036b32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fe97fad779223a0024b6f8f036b32b">&#9670;&nbsp;</a></span>ZSTD_getSequenceLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC <a class="el" href="structZSTD__SequenceLength.html">ZSTD_SequenceLength</a> ZSTD_getSequenceLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSeqStore__t.html">SeqStore_t</a> const *&#160;</td>
          <td class="paramname"><em>seqStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSeqDef__s.html">SeqDef</a> const *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="structZSTD__SequenceLength.html">ZSTD_SequenceLength</a> for the given sequences. It handles the decoding of long sequences indicated by longLengthPos and longLengthType, and adds MINMATCH back to matchLength. </p>

</div>
</div>
<a id="a6b60144bc8895bcbc214bb6209529039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b60144bc8895bcbc214bb6209529039">&#9670;&nbsp;</a></span>ZSTD_initCStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initCStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to: </p><pre class="fragment">ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
</pre><p> Note that <a class="el" href="zstd_8c.html#a6b60144bc8895bcbc214bb6209529039">ZSTD_initCStream()</a> clears any previously set dictionary. Use the new API to compress with a dictionary. </p>

</div>
</div>
<a id="aab1721218446169ecdacca560ced7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1721218446169ecdacca560ced7ae3">&#9670;&nbsp;</a></span>ZSTD_initCStream_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initCStream_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__parameters.html">ZSTD_parameters</a>&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aab1721218446169ecdacca560ced7ae3">ZSTD_initCStream_advanced()</a> : This function is DEPRECATED, and is equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_setParams(zcs, params); ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize); ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);</p>
<p>dict is loaded with ZSTD_dct_auto and ZSTD_dlm_byCopy. pledgedSrcSize must be correct. If srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN. This prototype will generate compilation warnings. </p>

</div>
</div>
<a id="a997205b667d236d5164f6481e657f7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997205b667d236d5164f6481e657f7e0">&#9670;&nbsp;</a></span>ZSTD_initCStream_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initCStream_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a997205b667d236d5164f6481e657f7e0">ZSTD_initCStream_internal()</a> : Private use only. Init streaming operation. expects params to be valid. must receive dict, or cdict, or none, but not both. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code</dd></dl>
<p><a class="el" href="zstd_8c.html#a997205b667d236d5164f6481e657f7e0">ZSTD_initCStream_internal()</a> : Note : for lib/compress only. Used by zstdmt_compress.c. Assumption 1 : params are valid Assumption 2 : either dict, or cdict, is defined, not both </p>

</div>
</div>
<a id="a9b2c3cdba14edfbcaec1d2d04c3c6be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2c3cdba14edfbcaec1d2d04c3c6be8">&#9670;&nbsp;</a></span>ZSTD_initCStream_srcSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initCStream_srcSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9b2c3cdba14edfbcaec1d2d04c3c6be8">ZSTD_initCStream_srcSize()</a> : This function is DEPRECATED, and equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any) ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel); ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);</p>
<p>pledgedSrcSize must be correct. If it is not known at init time, use ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs, "0" also disables frame content size field. It may be enabled in the future. This prototype will generate compilation warnings. </p>

</div>
</div>
<a id="a09b0b13da1840a10013a46f4b0c0e20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b0b13da1840a10013a46f4b0c0e20d">&#9670;&nbsp;</a></span>ZSTD_initCStream_usingCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initCStream_usingCDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a09b0b13da1840a10013a46f4b0c0e20d">ZSTD_initCStream_usingCDict()</a> : This function is DEPRECATED, and equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_refCDict(zcs, cdict);</p>
<p>note : cdict will just be referenced, and must outlive compression session This prototype will generate compilation warnings. </p>

</div>
</div>
<a id="a5bdba91ef84207e599df426633f8b94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdba91ef84207e599df426633f8b94d">&#9670;&nbsp;</a></span>ZSTD_initCStream_usingCDict_advanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initCStream_usingCDict_advanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__frameParameters.html">ZSTD_frameParameters</a>&#160;</td>
          <td class="paramname"><em>fParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a5bdba91ef84207e599df426633f8b94d">ZSTD_initCStream_usingCDict_advanced()</a> : This function is DEPRECATED, and is equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_setFParams(zcs, fParams); ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize); ZSTD_CCtx_refCDict(zcs, cdict);</p>
<p>same as <a class="el" href="zstd_8c.html#a09b0b13da1840a10013a46f4b0c0e20d">ZSTD_initCStream_usingCDict()</a>, with control over frame parameters. pledgedSrcSize must be correct. If srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN. This prototype will generate compilation warnings. </p>

</div>
</div>
<a id="a9bbfb3dd2cf3a661417dc6aed8c50bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbfb3dd2cf3a661417dc6aed8c50bb0">&#9670;&nbsp;</a></span>ZSTD_initCStream_usingDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initCStream_usingDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9bbfb3dd2cf3a661417dc6aed8c50bb0">ZSTD_initCStream_usingDict()</a> : This function is DEPRECATED, and is equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel); ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);</p>
<p>Creates of an internal CDict (incompatible with static CCtx), except if dict == NULL or dictSize &lt; 8, in which case no dict is used. Note: dict is loaded with ZSTD_dct_auto (treated as a full zstd dictionary if it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy. This prototype will generate compilation warnings. </p>

</div>
</div>
<a id="a6a019b45680ffdceacb717fd2f9cc02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a019b45680ffdceacb717fd2f9cc02c">&#9670;&nbsp;</a></span>ZSTD_initDStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initDStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *&#160;</td>
          <td class="paramname"><em>zds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a6a019b45680ffdceacb717fd2f9cc02c">ZSTD_initDStream()</a> : Initialize/reset DStream state for new decompression operation. Call before new decompression operation using same DStream.</p>
<p>Note : This function is redundant with the advanced API and equivalent to: ZSTD_DCtx_reset(zds, ZSTD_reset_session_only); ZSTD_DCtx_refDDict(zds, NULL); </p>

</div>
</div>
<a id="a3e888f5bf6ca75c11876d3173a87f56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e888f5bf6ca75c11876d3173a87f56d">&#9670;&nbsp;</a></span>ZSTD_initDStream_usingDDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initDStream_usingDDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *&#160;</td>
          <td class="paramname"><em>zds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__DDict__s.html">ZSTD_DDict</a> *&#160;</td>
          <td class="paramname"><em>ddict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is deprecated, and is equivalent to: </p><pre class="fragment">ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
ZSTD_DCtx_refDDict(zds, ddict);
</pre><p> note : ddict is referenced, it must outlive decompression session </p>

</div>
</div>
<a id="acd20682299443222dcbd71b1db0ae29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd20682299443222dcbd71b1db0ae29e">&#9670;&nbsp;</a></span>ZSTD_initDStream_usingDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_initDStream_usingDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *&#160;</td>
          <td class="paramname"><em>zds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is deprecated, and is equivalent to: </p><pre class="fragment">ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
ZSTD_DCtx_loadDictionary(zds, dict, dictSize);
</pre><p> note: no dictionary will be used if dict == NULL or dictSize &lt; 8 </p>

</div>
</div>
<a id="a546bc4b164b95226389a530c50782860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546bc4b164b95226389a530c50782860">&#9670;&nbsp;</a></span>ZSTD_initStaticCCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> * ZSTD_initStaticCCtx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workspaceSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_initStatic*() : Initialize an object using a pre-allocated fixed-size buffer. workspace: The memory area to emplace the object into. Provided pointer <em>must be 8-bytes aligned</em>. Buffer must outlive object. workspaceSize: Use ZSTD_estimate*Size() to determine how large workspace must be to support target scenario. </p><dl class="section return"><dt>Returns</dt><dd>: pointer to object (same address as workspace, just different type), or NULL if error (size too small, incorrect alignment, etc.) Note : zstd will never resize nor malloc() when using a static buffer. If the object requires more memory than available, zstd will just error out (typically ZSTD_error_memory_allocation). Note 2 : there is no corresponding "free" function. Since workspace is allocated externally, it must be freed externally too. Note 3 : cParams : use <a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams()</a> to convert a compression level into its associated cParams. Limitation 1 : currently not compatible with internal dictionary creation, triggered by <a class="el" href="zstd_8c.html#a9f03e49aafdf252d4e9a10fdee0db68b">ZSTD_CCtx_loadDictionary()</a>, <a class="el" href="zstd_8c.html#a9bbfb3dd2cf3a661417dc6aed8c50bb0">ZSTD_initCStream_usingDict()</a> or <a class="el" href="zstd_8c.html#acd20682299443222dcbd71b1db0ae29e">ZSTD_initDStream_usingDict()</a>. Limitation 2 : static cctx currently not compatible with multi-threading. Limitation 3 : static dctx is incompatible with legacy support. </dd></dl>

</div>
</div>
<a id="af423c780d1eb3dc57c4e2a1446c4c59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af423c780d1eb3dc57c4e2a1446c4c59a">&#9670;&nbsp;</a></span>ZSTD_initStaticCDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> * ZSTD_initStaticCDict </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workspaceSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#af9b07eb9d181ba9a9085f75d52b3d839">ZSTD_dictLoadMethod_e</a>&#160;</td>
          <td class="paramname"><em>dictLoadMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dictContentType_e&#160;</td>
          <td class="paramname"><em>dictContentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a>&#160;</td>
          <td class="paramname"><em>cParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_initStaticCDict_advanced() : Generate a digested dictionary in provided memory area. workspace: The memory area to emplace the dictionary into. Provided pointer must 8-bytes aligned. It must outlive dictionary usage. workspaceSize: Use <a class="el" href="zstd_8c.html#af5a1d21490a08200ea600cae0fb3e350">ZSTD_estimateCDictSize()</a> to determine how large workspace must be. cParams : use <a class="el" href="zstd_8c.html#ae0ff760b75dc576f1cd0d2f9b2aab232">ZSTD_getCParams()</a> to transform a compression level into its relevant cParams. </p><dl class="section return"><dt>Returns</dt><dd>: pointer to ZSTD_CDict*, or NULL if error (size too small) Note : there is no corresponding "free" function. Since workspace was allocated externally, it must be freed externally. </dd></dl>

</div>
</div>
<a id="a335eee8a5e5b93b43017b2d71f5e9535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335eee8a5e5b93b43017b2d71f5e9535">&#9670;&nbsp;</a></span>ZSTD_initStaticCStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> * ZSTD_initStaticCStream </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workspaceSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as <a class="el" href="zstd_8c.html#a546bc4b164b95226389a530c50782860">ZSTD_initStaticCCtx()</a> </p>

</div>
</div>
<a id="a7217d0e1ebb5d623eb163584602ee736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7217d0e1ebb5d623eb163584602ee736">&#9670;&nbsp;</a></span>ZSTD_initStaticDStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> * ZSTD_initStaticDStream </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workspaceSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as ZSTD_initStaticDCtx() </p>

</div>
</div>
<a id="ad324c6f4cfa62ee290f487baba56a87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad324c6f4cfa62ee290f487baba56a87f">&#9670;&nbsp;</a></span>ZSTD_insertBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_insertBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__DCtx__s.html">ZSTD_DCtx</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>insert uncompressed block into <code>dctx</code> history. Useful for multi-blocks decompression.</p>
<p><a class="el" href="zstd_8c.html#ad324c6f4cfa62ee290f487baba56a87f">ZSTD_insertBlock()</a> : insert <code>src</code> block into <code>dctx</code> history. Useful to track uncompressed blocks. </p>

</div>
</div>
<a id="a9aa5ce80027dc7ed0a3dc65dffa1d5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa5ce80027dc7ed0a3dc65dffa1d5ef">&#9670;&nbsp;</a></span>ZSTD_isDeterministicBuild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ZSTD_isDeterministicBuild </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9aa5ce80027dc7ed0a3dc65dffa1d5ef">ZSTD_isDeterministicBuild()</a> : Returns 1 if the library is built using standard compilation flags, and participates in determinism guarantees with other builds of the same version. If this function returns 0, it means the library was compiled with non-standard compilation flags that change the output of the compressor. This is mainly used for Zstd's determinism test suite, which is only run when this function returns 1. </p>

</div>
</div>
<a id="abbd9d17bd95d6109c21f92c569e32fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd9d17bd95d6109c21f92c569e32fd3">&#9670;&nbsp;</a></span>ZSTD_isError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZSTD_isError </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>tells if a <code>size_t</code> function result is an error code</p>
<p><a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a> : tells if a return value is an error code symbol is required for external callers </p>

</div>
</div>
<a id="acf200ef640d9d65be6c6fac35c6aebda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf200ef640d9d65be6c6fac35c6aebda">&#9670;&nbsp;</a></span>ZSTD_isFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZSTD_isFrame </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#acf200ef640d9d65be6c6fac35c6aebda">ZSTD_isFrame()</a> : Tells if the content of <code>buffer</code> starts with a valid Frame Identifier. Note : Frame Identifier is 4 bytes. If <code>size &lt; 4</code>, </p><dl class="section return"><dt>Returns</dt><dd>will always be 0. Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled. Note 3 : Skippable Frame Identifiers are considered valid. </dd></dl>

</div>
</div>
<a id="a8bf7dde6fc5edae03ee53dfccdce9d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf7dde6fc5edae03ee53dfccdce9d47">&#9670;&nbsp;</a></span>ZSTD_isSkippableFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZSTD_isSkippableFrame </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a8bf7dde6fc5edae03ee53dfccdce9d47">ZSTD_isSkippableFrame()</a> : Tells if the content of <code>buffer</code> starts with a valid Frame Identifier for a skippable frame.</p>
<p><a class="el" href="zstd_8c.html#a8bf7dde6fc5edae03ee53dfccdce9d47">ZSTD_isSkippableFrame()</a> : Tells if the content of <code>buffer</code> starts with a valid Frame Identifier for a skippable frame. Note : Frame Identifier is 4 bytes. If <code>size &lt; 4</code>, </p><dl class="section return"><dt>Returns</dt><dd>will always be 0. </dd></dl>

</div>
</div>
<a id="a516b3c0b84a8f87c0257e945fccbb1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516b3c0b84a8f87c0257e945fccbb1a3">&#9670;&nbsp;</a></span>ZSTD_ldm_adjustParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZSTD_ldm_adjustParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structldmParams__t.html">ldmParams_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__compressionParameters.html">ZSTD_compressionParameters</a> const *&#160;</td>
          <td class="paramname"><em>cParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a516b3c0b84a8f87c0257e945fccbb1a3">ZSTD_ldm_adjustParameters()</a> : If the params-&gt;hashRateLog is not set, set it to its default value based on windowLog and params-&gt;hashLog.</p>
<p>Ensures that params-&gt;bucketSizeLog is &lt;= params-&gt;hashLog (setting it to params-&gt;hashLog if it is not).</p>
<p>Ensures that the minMatchLength &gt;= targetLength during optimal parsing. </p>

</div>
</div>
<a id="a87025f90027ce06919c80a0e6858dc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87025f90027ce06919c80a0e6858dc38">&#9670;&nbsp;</a></span>ZSTD_ldm_blockCompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_ldm_blockCompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRawSeqStore__t.html">RawSeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>rawSeqStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSeqStore__t.html">SeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>seqStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>rep</em>[ZSTD_REP_NUM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_ParamSwitch_e&#160;</td>
          <td class="paramname"><em>useRowMatchFinder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a87025f90027ce06919c80a0e6858dc38">ZSTD_ldm_blockCompress()</a>:</p>
<p>Compresses a block using the predefined sequences, along with a secondary block compressor. The literals section of every sequence is passed to the secondary block compressor, and those sequences are interspersed with the predefined sequences. Returns the length of the last literals. Updates <code>rawSeqStore.pos</code> to indicate how many sequences have been consumed. <code>rawSeqStore.seq</code> may also be updated to split the last sequence between two blocks. </p><dl class="section return"><dt>Returns</dt><dd>The length of the last literals.</dd></dl>
<p>NOTE: The source must be at most the maximum block size, but the predefined sequences can be any size, and may be longer than the block. In the case that they are longer than the block, the last sequences may need to be split into two. We handle that case correctly, and update <code>rawSeqStore</code> appropriately. NOTE: This function does not return any errors. </p>

</div>
</div>
<a id="abc5c9ac495d0bdcdfe9884ef3539b34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5c9ac495d0bdcdfe9884ef3539b34f">&#9670;&nbsp;</a></span>ZSTD_ldm_generateSequences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_ldm_generateSequences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structldmState__t.html">ldmState_t</a> *&#160;</td>
          <td class="paramname"><em>ldms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRawSeqStore__t.html">RawSeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>sequences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structldmParams__t.html">ldmParams_t</a> const *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#abc5c9ac495d0bdcdfe9884ef3539b34f">ZSTD_ldm_generateSequences()</a>:</p>
<p>Generates the sequences using the long distance match finder. Generates long range matching sequences in <code>sequences</code>, which parse a prefix of the source. <code>sequences</code> must be large enough to store every sequence, which can be checked with <code><a class="el" href="zstd_8c.html#a8e65e54701af3291da1246800b46cc81">ZSTD_ldm_getMaxNbSeq()</a></code>. </p><dl class="section return"><dt>Returns</dt><dd>0 or an error code.</dd></dl>
<p>NOTE: The user must have called <a class="el" href="zstd_8c.html#a31a04814aabcae6a2990b9c342be3f7e">ZSTD_window_update()</a> for all of the input they have, even if they pass it to <a class="el" href="zstd_8c.html#abc5c9ac495d0bdcdfe9884ef3539b34f">ZSTD_ldm_generateSequences()</a> in chunks. NOTE: This function returns an error if it runs out of space to store sequences. </p>

</div>
</div>
<a id="a8e65e54701af3291da1246800b46cc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e65e54701af3291da1246800b46cc81">&#9670;&nbsp;</a></span>ZSTD_ldm_getMaxNbSeq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_ldm_getMaxNbSeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structldmParams__t.html">ldmParams_t</a>&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxChunkSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_ldm_getSeqSpace() : Return an upper bound on the number of sequences that can be produced by the long distance matcher, or 0 if LDM is disabled. </p>

</div>
</div>
<a id="af3a6ee793b025994c7102e0b08918129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a6ee793b025994c7102e0b08918129">&#9670;&nbsp;</a></span>ZSTD_ldm_getTableSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_ldm_getTableSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structldmParams__t.html">ldmParams_t</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#af3a6ee793b025994c7102e0b08918129">ZSTD_ldm_getTableSize()</a> : Estimate the space needed for long distance matching tables or 0 if LDM is disabled. </p>

</div>
</div>
<a id="a1d0669d4bb3b7e8a22e6a0604938aca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0669d4bb3b7e8a22e6a0604938aca1">&#9670;&nbsp;</a></span>ZSTD_ldm_skipSequences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZSTD_ldm_skipSequences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRawSeqStore__t.html">RawSeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>rawSeqStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 const&#160;</td>
          <td class="paramname"><em>minMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a1d0669d4bb3b7e8a22e6a0604938aca1">ZSTD_ldm_skipSequences()</a>:</p>
<p>Skip past <code>srcSize</code> bytes worth of sequences in <code>rawSeqStore</code>. Avoids emitting matches less than <code>minMatch</code> bytes. Must be called for data that is not passed to <a class="el" href="zstd_8c.html#a87025f90027ce06919c80a0e6858dc38">ZSTD_ldm_blockCompress()</a>. </p>

</div>
</div>
<a id="a6af4eab5a51ba4fcef1a28f25a44f0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af4eab5a51ba4fcef1a28f25a44f0a5">&#9670;&nbsp;</a></span>ZSTD_loadDEntropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_loadDEntropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__entropyDTables__t.html">ZSTD_entropyDTables_t</a> *&#160;</td>
          <td class="paramname"><em>entropy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>dictSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a6af4eab5a51ba4fcef1a28f25a44f0a5">ZSTD_loadDEntropy()</a> : dict : must point at beginning of a valid zstd dictionary. </p><dl class="section return"><dt>Returns</dt><dd>: size of dictionary header (size of magic number + dict ID + entropy tables)</dd></dl>
<p><a class="el" href="zstd_8c.html#a6af4eab5a51ba4fcef1a28f25a44f0a5">ZSTD_loadDEntropy()</a> : dict : must point at beginning of a valid zstd dictionary. </p><dl class="section return"><dt>Returns</dt><dd>: size of entropy tables read </dd></dl>

</div>
</div>
<a id="a271b90fe6607653a89b99c4926cc9d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271b90fe6607653a89b99c4926cc9d5f">&#9670;&nbsp;</a></span>ZSTD_matchState_dictMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC ZSTD_dictMode_e ZSTD_matchState_dictMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a271b90fe6607653a89b99c4926cc9d5f">ZSTD_matchState_dictMode()</a>: Inspects the provided matchState and figures out what dictMode should be passed to the compressor. </p>

</div>
</div>
<a id="a98a3c5d5d32c4a8d758813054dfff72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a3c5d5d32c4a8d758813054dfff72f">&#9670;&nbsp;</a></span>ZSTD_maxCLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ZSTD_maxCLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum compression level available </p>

</div>
</div>
<a id="a899d0f1cff2c0925aae29d3620e91771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899d0f1cff2c0925aae29d3620e91771">&#9670;&nbsp;</a></span>ZSTD_maybeNullPtrAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void* ZSTD_maybeNullPtrAdd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to add to a pointer that works around C's undefined behavior of adding 0 to NULL.</p>
<dl class="section return"><dt>Returns</dt><dd><code>ptr + add</code> except it defines <code>NULL + 0 == NULL</code>. </dd></dl>

</div>
</div>
<a id="a3d70fd7f4b968b28b5bbaceed675e4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d70fd7f4b968b28b5bbaceed675e4d9">&#9670;&nbsp;</a></span>ZSTD_mergeBlockDelimiters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_mergeBlockDelimiters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a> *&#160;</td>
          <td class="paramname"><em>sequences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seqsSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a3d70fd7f4b968b28b5bbaceed675e4d9">ZSTD_mergeBlockDelimiters()</a> : Given an array of <a class="el" href="structZSTD__Sequence.html">ZSTD_Sequence</a>, remove all sequences that represent block delimiters/last literals by merging them into the literals of the next sequence.</p>
<p>As such, the final generated result has no explicit representation of block boundaries, and the final last literals segment is not represented in the sequences.</p>
<p>The output of this function can be fed into <a class="el" href="zstd_8c.html#a3ea6e28236d8dc969c6296ab7896926c">ZSTD_compressSequences()</a> with CCtx setting of ZSTD_c_blockDelimiters as ZSTD_sf_noBlockDelimiters </p><dl class="section return"><dt>Returns</dt><dd>: number of sequences left after merging </dd></dl>

</div>
</div>
<a id="ac1643fe2e77209052fc9266f9e0aa8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1643fe2e77209052fc9266f9e0aa8a3">&#9670;&nbsp;</a></span>ZSTD_minCLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ZSTD_minCLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimum negative compression level allowed, requires v1.4.0+ </p>

</div>
</div>
<a id="a14bb8df3c6a43218a558c2ce1a69b3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bb8df3c6a43218a558c2ce1a69b3f4">&#9670;&nbsp;</a></span>ZSTD_overlapCopy8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> void ZSTD_overlapCopy8 </td>
          <td>(</td>
          <td class="paramtype">BYTE **&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE const **&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a14bb8df3c6a43218a558c2ce1a69b3f4">ZSTD_overlapCopy8()</a> : Copies 8 bytes from ip to op and updates op and ip where ip &lt;= op. If the offset is &lt; 8 then the offset is spread to at least 8 bytes.</p>
<p>Precondition: *ip &lt;= *op Postcondition: *op - *op &gt;= 8 </p>

</div>
</div>
<a id="af75d4dcdac1651618b3bc792957181d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75d4dcdac1651618b3bc792957181d8">&#9670;&nbsp;</a></span>ZSTD_readSkippableFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_readSkippableFrame </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>magicVariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#af75d4dcdac1651618b3bc792957181d8">ZSTD_readSkippableFrame()</a> : Retrieves the content of a zstd skippable frame starting at @src, and writes it to @dst buffer.</p>
<p>The parameter @magicVariant will receive the magicVariant that was supplied when the frame was written, i.e. magicNumber - ZSTD_MAGIC_SKIPPABLE_START. This can be NULL if the caller is not interested in the magicVariant.</p>
<p>Returns an error if destination buffer is not large enough, or if the frame is not skippable.</p>
<dl class="section return"><dt>Returns</dt><dd>: number of bytes written or a ZSTD error.</dd></dl>
<p><a class="el" href="zstd_8c.html#af75d4dcdac1651618b3bc792957181d8">ZSTD_readSkippableFrame()</a> : Retrieves content of a skippable frame, and writes it to dst buffer.</p>
<p>The parameter magicVariant will receive the magicVariant that was supplied when the frame was written, i.e. magicNumber - ZSTD_MAGIC_SKIPPABLE_START. This can be NULL if the caller is not interested in the magicVariant.</p>
<p>Returns an error if destination buffer is not large enough, or if this is not a valid skippable frame.</p>
<dl class="section return"><dt>Returns</dt><dd>: number of bytes written or a ZSTD error. </dd></dl>

</div>
</div>
<a id="a1c1bca487b05d262cc8c91a5e999e785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1bca487b05d262cc8c91a5e999e785">&#9670;&nbsp;</a></span>ZSTD_reduceTable_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> void ZSTD_reduceTable_internal </td>
          <td>(</td>
          <td class="paramtype">U32 *const&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 const&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 const&#160;</td>
          <td class="paramname"><em>reducerValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>preserveMark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_reduceTable() : reduce table indexes by <code>reducerValue</code>, or squash to zero. PreserveMark preserves "unsorted mark" for btlazy2 strategy. It must be set to a clear 0/1 value, to remove branch during inlining. Presume table size is a multiple of ZSTD_ROWSIZE to help auto-vectorization </p>

</div>
</div>
<a id="a82b046dad80364659876af1447f09f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b046dad80364659876af1447f09f63">&#9670;&nbsp;</a></span>ZSTD_registerSequenceProducer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZSTD_registerSequenceProducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sequenceProducerState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_sequenceProducer_F&#160;</td>
          <td class="paramname"><em>sequenceProducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a82b046dad80364659876af1447f09f63">ZSTD_registerSequenceProducer()</a> : Instruct zstd to use a block-level external sequence producer function.</p>
<p>The sequenceProducerState must be initialized by the caller, and the caller is responsible for managing its lifetime. This parameter is sticky across compressions. It will remain set until the user explicitly resets compression parameters.</p>
<p>Sequence producer registration is considered to be an "advanced parameter", part of the "advanced API". This means it will only have an effect on compression APIs which respect advanced parameters, such as compress2() and compressStream2(). Older compression APIs such as compressCCtx(), which predate the introduction of "advanced parameters", will ignore any external sequence producer setting.</p>
<p>The sequence producer can be "cleared" by registering a NULL function pointer. This removes all limitations described above in the "LIMITATIONS" section of the API docs.</p>
<p>The user is strongly encouraged to read the full API documentation (above) before calling this function. </p>

</div>
</div>
<a id="a26382abc133c15147af8501c19b66db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26382abc133c15147af8501c19b66db7">&#9670;&nbsp;</a></span>ZSTD_resetCStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_resetCStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#a7591551effb218c2750f0f57ba62809a">ZSTD_CStream</a> *&#160;</td>
          <td class="paramname"><em>zcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a26382abc133c15147af8501c19b66db7">ZSTD_resetCStream()</a> : This function is DEPRECATED, and is equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize); Note: <a class="el" href="zstd_8c.html#a26382abc133c15147af8501c19b66db7">ZSTD_resetCStream()</a> interprets pledgedSrcSize == 0 as ZSTD_CONTENTSIZE_UNKNOWN, but <a class="el" href="zstd_8c.html#a8e0795af794521da3907efa8fe850ed4">ZSTD_CCtx_setPledgedSrcSize()</a> does not do the same, so ZSTD_CONTENTSIZE_UNKNOWN must be explicitly specified.</p>
<p>start a new frame, using same parameters from previous frame. This is typically useful to skip dictionary loading stage, since it will reuse it in-place. Note that zcs must be init at least once before using <a class="el" href="zstd_8c.html#a26382abc133c15147af8501c19b66db7">ZSTD_resetCStream()</a>. If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN. If pledgedSrcSize &gt; 0, its value must be correct, as it will be written in header, and controlled at the end. For the time being, pledgedSrcSize==0 is interpreted as "srcSize unknown" for compatibility with older programs, but it will change to mean "empty" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code (which can be tested using <a class="el" href="zstd_8c.html#abbd9d17bd95d6109c21f92c569e32fd3">ZSTD_isError()</a>) This prototype will generate compilation warnings. </dd></dl>

</div>
</div>
<a id="a5d1259efc8de4e58cbb0a08f1067fb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1259efc8de4e58cbb0a08f1067fb1b">&#9670;&nbsp;</a></span>ZSTD_resetDStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_resetDStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zstd_8c.html#abc6473440df4dc8a7ce82443825c47df">ZSTD_DStream</a> *&#160;</td>
          <td class="paramname"><em>zds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is deprecated, and is equivalent to: </p><pre class="fragment">ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
</pre><p> reuse decompression parameters from previous init; saves dictionary loading </p>

</div>
</div>
<a id="a34bc513996e13d72e5b0cc6d11c21970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bc513996e13d72e5b0cc6d11c21970">&#9670;&nbsp;</a></span>ZSTD_rollingHash_compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC U64 ZSTD_rollingHash_compute </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a34bc513996e13d72e5b0cc6d11c21970">ZSTD_rollingHash_compute()</a> : Compute the rolling hash value of the buffer. </p>

</div>
</div>
<a id="a602fbbe915e54e330f1cc6252080d7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602fbbe915e54e330f1cc6252080d7a7">&#9670;&nbsp;</a></span>ZSTD_rollingHash_primePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC U64 ZSTD_rollingHash_primePower </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a602fbbe915e54e330f1cc6252080d7a7">ZSTD_rollingHash_primePower()</a> : Compute the primePower to be passed to <a class="el" href="zstd_8c.html#a3724dab957ebcd9f208ee18737d99bec">ZSTD_rollingHash_rotate()</a> for a hash over a window of length bytes. </p>

</div>
</div>
<a id="a3724dab957ebcd9f208ee18737d99bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3724dab957ebcd9f208ee18737d99bec">&#9670;&nbsp;</a></span>ZSTD_rollingHash_rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC U64 ZSTD_rollingHash_rotate </td>
          <td>(</td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>toRemove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>toAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>primePower</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a3724dab957ebcd9f208ee18737d99bec">ZSTD_rollingHash_rotate()</a> : Rotate the rolling hash by one byte. </p>

</div>
</div>
<a id="a56d83089efbda033b3ff3ac36e1e52b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d83089efbda033b3ff3ac36e1e52b6">&#9670;&nbsp;</a></span>ZSTD_searchMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#abf752dd6259117e6d4da3b8b1fb13aaf">FORCE_INLINE_TEMPLATE</a> size_t ZSTD_searchMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>iend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offsetPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 const&#160;</td>
          <td class="paramname"><em>mls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 const&#160;</td>
          <td class="paramname"><em>rowLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">searchMethod_e const&#160;</td>
          <td class="paramname"><em>searchMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dictMode_e const&#160;</td>
          <td class="paramname"><em>dictMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the longest match at <code>ip</code>. Dispatches to the correct implementation function based on the (searchMethod, dictMode, mls, rowLog). We use switch statements here instead of using an indirect function call through a function pointer because after Spectre and Meltdown mitigations, indirect function calls can be very costly, especially in the kernel.</p>
<p>NOTE: dictMode and searchMethod should be templated, so those switch statements should be optimized out. Only the mls &amp; rowLog switches should be left.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ms</td><td>The match state. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ip</td><td>The position to search at. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iend</td><td>The end of the input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offsetPtr</td><td>Stores the match offset into this pointer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mls</td><td>The minimum search length, in the range [4, 6]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rowLog</td><td>The row log (if applicable), in the range [4, 6]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">searchMethod</td><td>The search method to use (templated). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dictMode</td><td>The dictMode (templated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the longest match found, or &lt; mls if no match is found. If a match is found its offset is stored in <code>offsetPtr</code>. </dd></dl>

</div>
</div>
<a id="a66a83864277b6c6c6387cda028851100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a83864277b6c6c6387cda028851100">&#9670;&nbsp;</a></span>ZSTD_sequenceBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_sequenceBound </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a66a83864277b6c6c6387cda028851100">ZSTD_sequenceBound()</a> : <code>srcSize</code> : size of the input buffer </p><dl class="section return"><dt>Returns</dt><dd>: upper-bound for the number of sequences that can be generated from a buffer of srcSize bytes</dd></dl>
<p>note : returns number of sequences - to get bytes, multiply by sizeof(ZSTD_Sequence). </p>

</div>
</div>
<a id="a0a810611d44d7c2f604c6bc4bd677ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a810611d44d7c2f604c6bc4bd677ed3">&#9670;&nbsp;</a></span>ZSTD_sizeof_CCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_sizeof_CCtx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ZSTD_sizeof_*() : Requires v1.4.0+ These functions give the <em>current</em> memory usage of selected object. Note that object memory usage can evolve (increase or decrease) over time. </p>

</div>
</div>
<a id="ab42cff93ddcb09ef56fe0bc4f3d2f8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42cff93ddcb09ef56fe0bc4f3d2f8d3">&#9670;&nbsp;</a></span>ZSTD_storeSeq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> UNUSED_ATTR void ZSTD_storeSeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSeqStore__t.html">SeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>seqStorePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>litLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>literals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>litLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>offBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>matchLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ab42cff93ddcb09ef56fe0bc4f3d2f8d3">ZSTD_storeSeq()</a> : Store a sequence (litlen, litPtr, offBase and matchLength) into <a class="el" href="structSeqStore__t.html">SeqStore_t</a>. @offBase : Users should employ macros REPCODE_TO_OFFBASE() and OFFSET_TO_OFFBASE(). @matchLength : must be &gt;= MINMATCH Allowed to over-read literals up to litLimit. </p>

</div>
</div>
<a id="a43b5bce120d275827e4c1da586aa26ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b5bce120d275827e4c1da586aa26ef">&#9670;&nbsp;</a></span>ZSTD_storeSeqOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zstd_8c.html#a18e6fde6004400522b2ff1da3c080363">HINT_INLINE</a> UNUSED_ATTR void ZSTD_storeSeqOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSeqStore__t.html">SeqStore_t</a> *&#160;</td>
          <td class="paramname"><em>seqStorePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>litLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>offBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>matchLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a43b5bce120d275827e4c1da586aa26ef">ZSTD_storeSeqOnly()</a> : Store a sequence (litlen, litPtr, offBase and matchLength) into <a class="el" href="structSeqStore__t.html">SeqStore_t</a>. Literals themselves are not copied, but @litPtr is updated. @offBase : Users should employ macros REPCODE_TO_OFFBASE() and OFFSET_TO_OFFBASE(). @matchLength : must be &gt;= MINMATCH </p>

</div>
</div>
<a id="a69d02b3a890470f88ff278cbf56a2545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d02b3a890470f88ff278cbf56a2545">&#9670;&nbsp;</a></span>ZSTD_toFlushNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_toFlushNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__s.html">ZSTD_CCtx</a> *&#160;</td>
          <td class="paramname"><em>cctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a69d02b3a890470f88ff278cbf56a2545">ZSTD_toFlushNow()</a> : Tell how many bytes are ready to be flushed immediately. Useful for multithreading scenarios (nbWorkers &gt;= 1). Probe the oldest active job, defined as oldest job not yet entirely flushed, and check its output buffer. </p><dl class="section return"><dt>Returns</dt><dd>: amount of data stored in oldest job and ready to be flushed immediately. if </dd>
<dd>
== 0, it means either :<ul>
<li>there is no active job (could be checked with <a class="el" href="structZSTD__frameProgression.html">ZSTD_frameProgression()</a>), or</li>
<li>oldest job is still actively compressing data, but everything it has produced has also been flushed so far, therefore flush speed is limited by production speed of oldest job irrespective of the speed of concurrent (and newer) jobs.</li>
</ul>
</dd></dl>
<p><a class="el" href="zstd_8c.html#a69d02b3a890470f88ff278cbf56a2545">ZSTD_toFlushNow()</a> Only useful for multithreading scenarios currently (nbWorkers &gt;= 1). </p>

</div>
</div>
<a id="a9514c179be6ddc5ceab1ee75d631d27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9514c179be6ddc5ceab1ee75d631d27a">&#9670;&nbsp;</a></span>ZSTD_versionNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ZSTD_versionNumber </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9514c179be6ddc5ceab1ee75d631d27a">ZSTD_versionNumber()</a> : Return runtime library version, the value is (MAJOR*100*100 + MINOR*100 + RELEASE). </p>

</div>
</div>
<a id="a88e9b58e46bb6e3ed78cd596aedeab4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e9b58e46bb6e3ed78cd596aedeab4e">&#9670;&nbsp;</a></span>ZSTD_versionString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ZSTD_versionString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a88e9b58e46bb6e3ed78cd596aedeab4e">ZSTD_versionString()</a> : Return runtime library version, like "1.4.5". Requires v1.3.0+. </p>

</div>
</div>
<a id="ac30bb0eb81bd37e9868e6603ef3c5893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30bb0eb81bd37e9868e6603ef3c5893">&#9670;&nbsp;</a></span>ZSTD_wildcopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC FORCE_INLINE_ATTR void ZSTD_wildcopy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_overlap_e const&#160;</td>
          <td class="paramname"><em>ovtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#ac30bb0eb81bd37e9868e6603ef3c5893">ZSTD_wildcopy()</a> : Custom version of ZSTD_memcpy(), can over read/write up to WILDCOPY_OVERLENGTH bytes (if length==0) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ovtype</td><td>controls the overlap detection<ul>
<li>ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.</li>
<li>ZSTD_overlap_src_before_dst: The src and dst may overlap, but they MUST be at least 8 bytes apart. The src buffer must be before the dst buffer. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fc8b3af4bbb26a05f4fcf52145c20e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc8b3af4bbb26a05f4fcf52145c20e9">&#9670;&nbsp;</a></span>ZSTD_window_canOverflowCorrect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC U32 ZSTD_window_canOverflowCorrect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> const&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>cycleLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>loadedDictEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a9fc8b3af4bbb26a05f4fcf52145c20e9">ZSTD_window_canOverflowCorrect()</a>: Returns non-zero if the indices are large enough for overflow correction to work correctly without impacting compression ratio. </p>

</div>
</div>
<a id="a2b1754250a088c051bfdaa3722b196f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1754250a088c051bfdaa3722b196f6">&#9670;&nbsp;</a></span>ZSTD_window_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void ZSTD_window_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a2b1754250a088c051bfdaa3722b196f6">ZSTD_window_clear()</a>: Clears the window containing the history by simply setting it to empty. </p>

</div>
</div>
<a id="a909342229fb07f0ff63025cdff6a69f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909342229fb07f0ff63025cdff6a69f4">&#9670;&nbsp;</a></span>ZSTD_window_correctOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> U32 ZSTD_window_correctOverflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>cycleLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a909342229fb07f0ff63025cdff6a69f4">ZSTD_window_correctOverflow()</a>: Reduces the indices to protect from index overflow. Returns the correction made to the indices, which must be applied to every stored index.</p>
<p>The least significant cycleLog bits of the indices must remain the same, which may be 0. Every index up to maxDist in the past must be valid. </p>

</div>
</div>
<a id="a3cf5737b37d58228f331a8e47ad0142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf5737b37d58228f331a8e47ad0142a">&#9670;&nbsp;</a></span>ZSTD_window_enforceMaxDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC void ZSTD_window_enforceMaxDist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>loadedDictEndPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__MatchState__t.html">ZSTD_MatchState_t</a> **&#160;</td>
          <td class="paramname"><em>dictMatchStatePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a3cf5737b37d58228f331a8e47ad0142a">ZSTD_window_enforceMaxDist()</a>: Updates lowLimit so that: (srcEnd - base) - lowLimit == maxDist + loadedDictEnd</p>
<p>It ensures index is valid as long as index &gt;= lowLimit. This must be called before a block compression call.</p>
<p>loadedDictEnd is only defined if a dictionary is in use for current compression. As the name implies, loadedDictEnd represents the index at end of dictionary. The value lies within context's referential, it can be directly compared to blockEndIdx.</p>
<p>If loadedDictEndPtr is NULL, no dictionary is in use, and we use loadedDictEnd == 0. If loadedDictEndPtr is not NULL, we set it to zero after updating lowLimit. This is because dictionaries are allowed to be referenced fully as long as the last byte of the dictionary is in the window. Once input has progressed beyond window size, dictionary cannot be referenced anymore.</p>
<p>In normal dict mode, the dictionary lies between lowLimit and dictLimit. In dictMatchState mode, lowLimit and dictLimit are the same, and the dictionary is below them. forceWindow and dictMatchState are therefore incompatible. </p>

</div>
</div>
<a id="a76aeb6153e79460e67e19938c5376e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76aeb6153e79460e67e19938c5376e0d">&#9670;&nbsp;</a></span>ZSTD_window_hasExtDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC U32 ZSTD_window_hasExtDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> const&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a76aeb6153e79460e67e19938c5376e0d">ZSTD_window_hasExtDict()</a>: Returns non-zero if the window has a non-empty extDict. </p>

</div>
</div>
<a id="a1af7a893a783cfcdd6e3738674344f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af7a893a783cfcdd6e3738674344f48">&#9670;&nbsp;</a></span>ZSTD_window_needOverflowCorrection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC U32 ZSTD_window_needOverflowCorrection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> const&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>cycleLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>loadedDictEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>srcEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a1af7a893a783cfcdd6e3738674344f48">ZSTD_window_needOverflowCorrection()</a>: Returns non-zero if the indices are getting too large and need overflow protection. </p>

</div>
</div>
<a id="a31a04814aabcae6a2990b9c342be3f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a04814aabcae6a2990b9c342be3f7e">&#9670;&nbsp;</a></span>ZSTD_window_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> U32 ZSTD_window_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTD__window__t.html">ZSTD_window_t</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>forceNonContiguous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a31a04814aabcae6a2990b9c342be3f7e">ZSTD_window_update()</a>: Updates the window by appending [src, src + srcSize) to the window. If it is not contiguous, the current prefix becomes the extDict, and we forget about the extDict. Handles overlap of the prefix and extDict. Returns non-zero if the segment is contiguous. </p>

</div>
</div>
<a id="a5515677ed3ff5244f9d64604bbebc541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5515677ed3ff5244f9d64604bbebc541">&#9670;&nbsp;</a></span>ZSTD_wrappedPtrAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> const void* ZSTD_wrappedPtrAdd </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to perform a wrapped pointer add without triggering UBSAN.</p>
<dl class="section return"><dt>Returns</dt><dd>ptr + add with wrapping </dd></dl>

</div>
</div>
<a id="a42e01b39b589cdfa16b1a952ebe472e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e01b39b589cdfa16b1a952ebe472e5">&#9670;&nbsp;</a></span>ZSTD_wrappedPtrDiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> ptrdiff_t ZSTD_wrappedPtrDiff </td>
          <td>(</td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to perform a wrapped pointer difference without triggering UBSAN.</p>
<dl class="section return"><dt>Returns</dt><dd>lhs - rhs with wrapping </dd></dl>

</div>
</div>
<a id="a4ee7f4ff2f1b7edb326c6bc5dad52b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee7f4ff2f1b7edb326c6bc5dad52b18">&#9670;&nbsp;</a></span>ZSTD_wrappedPtrSub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEM_STATIC <a class="el" href="zstd_8c.html#ae888a667f541f813c6766c53154e99cd">ZSTD_ALLOW_POINTER_OVERFLOW_ATTR</a> const void* ZSTD_wrappedPtrSub </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to perform a wrapped pointer subtraction without triggering UBSAN.</p>
<dl class="section return"><dt>Returns</dt><dd>ptr - sub with wrapping </dd></dl>

</div>
</div>
<a id="a12b7454a690528d1416a42c3047d0981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b7454a690528d1416a42c3047d0981">&#9670;&nbsp;</a></span>ZSTD_writeSkippableFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTD_writeSkippableFrame </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>magicVariant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a12b7454a690528d1416a42c3047d0981">ZSTD_writeSkippableFrame()</a> : Generates a zstd skippable frame containing data given by src, and writes it to dst buffer.</p>
<p>Skippable frames begin with a 4-byte magic number. There are 16 possible choices of magic number, ranging from ZSTD_MAGIC_SKIPPABLE_START to ZSTD_MAGIC_SKIPPABLE_START+15. As such, the parameter magicVariant controls the exact skippable frame magic number variant used, so the magic number used will be ZSTD_MAGIC_SKIPPABLE_START + magicVariant.</p>
<p>Returns an error if destination buffer is not large enough, if the source size is not representable with a 4-byte unsigned int, or if the parameter magicVariant is greater than 15 (and therefore invalid).</p>
<dl class="section return"><dt>Returns</dt><dd>: number of bytes written or a ZSTD error. </dd></dl>

</div>
</div>
<a id="a1ac5048ac979153a18b921b710e3e8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac5048ac979153a18b921b710e3e8d1">&#9670;&nbsp;</a></span>ZSTDMT_compressStream_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTDMT_compressStream_generic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *&#160;</td>
          <td class="paramname"><em>mtctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__outBuffer__s.html">ZSTD_outBuffer</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__inBuffer__s.html">ZSTD_inBuffer</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_EndDirective&#160;</td>
          <td class="paramname"><em>endOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a1ac5048ac979153a18b921b710e3e8d1">ZSTDMT_compressStream_generic()</a> : Combines ZSTDMT_compressStream() with optional ZSTDMT_flushStream() or ZSTDMT_endStream() depending on flush directive. </p><dl class="section return"><dt>Returns</dt><dd>: minimum amount of data still to be flushed 0 if fully flushed or an error code note : needs to be init using any ZSTD_initCStream*() variant</dd></dl>
<p><a class="el" href="zstd_8c.html#a1ac5048ac979153a18b921b710e3e8d1">ZSTDMT_compressStream_generic()</a> : internal use only - exposed to be invoked from zstd_compress.c assumption : output and input are valid (pos &lt;= size) </p><dl class="section return"><dt>Returns</dt><dd>: minimum amount of data remaining to flush, 0 if none </dd></dl>

</div>
</div>
<a id="a3c822c10aa6f503cebf7e35746b7c206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c822c10aa6f503cebf7e35746b7c206">&#9670;&nbsp;</a></span>ZSTDMT_getFrameProgression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structZSTD__frameProgression.html">ZSTD_frameProgression</a> ZSTDMT_getFrameProgression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *&#160;</td>
          <td class="paramname"><em>mtctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a3c822c10aa6f503cebf7e35746b7c206">ZSTDMT_getFrameProgression()</a>: tells how much data has been consumed (input) and produced (output) for current frame. able to count progression inside worker threads. </p>

</div>
</div>
<a id="aa12f1edba314c587743801d624f71873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12f1edba314c587743801d624f71873">&#9670;&nbsp;</a></span>ZSTDMT_initCStream_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTDMT_initCStream_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *&#160;</td>
          <td class="paramname"><em>mtctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dictSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZSTD_dictContentType_e&#160;</td>
          <td class="paramname"><em>dictContentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CDict__s.html">ZSTD_CDict</a> *&#160;</td>
          <td class="paramname"><em>cdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a>&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>pledgedSrcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#aa12f1edba314c587743801d624f71873">ZSTDMT_initCStream_internal()</a> : Private use only. Init streaming operation. expects params to be valid. must receive dict, or cdict, or none, but not both. mtctx can be freshly constructed or reused from a prior compression. If mtctx is reused, memory allocations from the prior compression may not be freed, even if they are not needed for the current compression. </p><dl class="section return"><dt>Returns</dt><dd>: 0, or an error code </dd></dl>

</div>
</div>
<a id="a0d200c4c6b7a3c7a045a181dfa29c322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d200c4c6b7a3c7a045a181dfa29c322">&#9670;&nbsp;</a></span>ZSTDMT_toFlushNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ZSTDMT_toFlushNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *&#160;</td>
          <td class="paramname"><em>mtctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a0d200c4c6b7a3c7a045a181dfa29c322">ZSTDMT_toFlushNow()</a> Tell how many bytes are ready to be flushed immediately. Probe the oldest active job (not yet entirely flushed) and check its output buffer. If return 0, it means there is no active job, or, it means oldest job is still active, but everything produced has been flushed so far, therefore flushing is limited by speed of oldest job. </p>

</div>
</div>
<a id="a3f5723a37881527037ffcdfbc157c121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5723a37881527037ffcdfbc157c121">&#9670;&nbsp;</a></span>ZSTDMT_updateCParams_whileCompressing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZSTDMT_updateCParams_whileCompressing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structZSTDMT__CCtx__s.html">ZSTDMT_CCtx</a> *&#160;</td>
          <td class="paramname"><em>mtctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structZSTD__CCtx__params__s.html">ZSTD_CCtx_params</a> *&#160;</td>
          <td class="paramname"><em>cctxParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="zstd_8c.html#a3f5723a37881527037ffcdfbc157c121">ZSTDMT_updateCParams_whileCompressing()</a> : Updates only a selected set of compression parameters, to remain compatible with current frame. New parameters will be applied to next compression job.</p>
<p><a class="el" href="zstd_8c.html#a3f5723a37881527037ffcdfbc157c121">ZSTDMT_updateCParams_whileCompressing()</a> : Updates a selected set of compression parameters, remaining compatible with currently active frame. New parameters will be applied to next compression job. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
